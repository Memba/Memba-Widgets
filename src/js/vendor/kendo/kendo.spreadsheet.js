/** 
 * Kendo UI v2022.1.412 (http://www.telerik.com/kendo-ui)                                                                                                                                               
 * Copyright 2022 Progress Software Corporation and/or one of its subsidiaries or affiliates. All rights reserved.                                                                                      
 *                                                                                                                                                                                                      
 * Kendo UI commercial licenses may be obtained at                                                                                                                                                      
 * http://www.telerik.com/purchase/license-agreement/kendo-ui-complete                                                                                                                                  
 * If you do not own a commercial license, this file shall be governed by the trial license terms.                                                                                                      
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       
                                                                                                                                                                                                       

*/
(function(f, define){
    define('util/undoredostack',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {
    var UndoRedoStack = kendo.Observable.extend({
        init: function(options) {
            kendo.Observable.fn.init.call(this, options);
            this.clear();
        },
        events: [ "undo", "redo" ],
        push: function (command) {
            this.stack = this.stack.slice(0, this.currentCommandIndex + 1);
            this.currentCommandIndex = this.stack.push(command) - 1;
        },
        undo: function () {
            if (this.canUndo()) {
                var command = this.stack[this.currentCommandIndex--];
                command.undo();
                this.trigger("undo", { command: command });
            }
        },
        redo: function () {
            if (this.canRedo()) {
                var command = this.stack[++this.currentCommandIndex];
                command.redo();
                this.trigger("redo", { command: command });
            }
        },
        clear: function() {
            this.stack = [];
            this.currentCommandIndex = -1;
        },
        canUndo: function () {
            return this.currentCommandIndex >= 0;
        },
        canRedo: function () {
            return this.currentCommandIndex != this.stack.length - 1;
        }
    });

    kendo.deepExtend(kendo, {
        util: {
            UndoRedoStack: UndoRedoStack
        }
    });
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

/***********************************************************************
 * WARNING: this file is auto-generated.  If you change it directly,
 * your modifications will eventually be lost.  The source code is in
 * `kendo-drawing` repository, you should make your changes there and
 * run `src-modules/sync.sh` in this repository.
 */
(function(f, define){
    define('util/text-metrics',[
        "../kendo.core"
    ], f);
})(function(){

(function ($) {

window.kendo.util = window.kendo.util || {};

var LRUCache = kendo.Class.extend({
    init: function(size) {

        this._size = size;
        this._length = 0;
        this._map = {};
    },

    put: function(key, value) {
        var map = this._map;
        var entry = { key: key, value: value };

        map[key] = entry;

        if (!this._head) {
            this._head = this._tail = entry;
        } else {
            this._tail.newer = entry;
            entry.older = this._tail;
            this._tail = entry;
        }

        if (this._length >= this._size) {
            map[this._head.key] = null;
            this._head = this._head.newer;
            this._head.older = null;
        } else {
            this._length++;
        }
    },

    get: function(key) {
        var entry = this._map[key];

        if (entry) {
            if (entry === this._head && entry !== this._tail) {
                this._head = entry.newer;
                this._head.older = null;
            }

            if (entry !== this._tail) {
                if (entry.older) {
                    entry.older.newer = entry.newer;
                    entry.newer.older = entry.older;
                }

                entry.older = this._tail;
                entry.newer = null;

                this._tail.newer = entry;
                this._tail = entry;
            }

            return entry.value;
        }
    }
});

var REPLACE_REGEX = /\r?\n|\r|\t/g;
var SPACE = ' ';

function normalizeText(text) {
    return String(text).replace(REPLACE_REGEX, SPACE);
}

function objectKey(object) {
    var parts = [];
    for (var key in object) {
        parts.push(key + object[key]);
    }

    return parts.sort().join("");
}

// Computes FNV-1 hash
// See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
function hashKey(str) {
    // 32-bit FNV-1 offset basis
    // See http://isthe.com/chongo/tech/comp/fnv/#FNV-param
    var hash = 0x811C9DC5;

    for (var i = 0; i < str.length; ++i) {
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
        hash ^= str.charCodeAt(i);
    }

    return hash >>> 0;
}

function zeroSize() {
    return { width: 0, height: 0, baseline: 0 };
}

var DEFAULT_OPTIONS = {
    baselineMarkerSize: 1
};

var defaultMeasureBox;

if (typeof document !== "undefined") {
    defaultMeasureBox = document.createElement("div");
    defaultMeasureBox.style.cssText = "position: absolute !important; top: -4000px !important; width: auto !important; height: auto !important;" +
              "padding: 0 !important; margin: 0 !important; border: 0 !important;" +
              "line-height: normal !important; visibility: hidden !important; white-space: pre!important;";
}

var TextMetrics = kendo.Class.extend({
    init: function(options) {

        this._cache = new LRUCache(1000);
        this.options = $.extend({}, DEFAULT_OPTIONS, options);
    },

    measure: function(text, style, options) {
        if (options === void 0) { options = {}; }

        if (typeof text === 'undefined' || text === null) {
            return zeroSize();
        }

        var styleKey = objectKey(style);
        var cacheKey = hashKey(text + styleKey);
        var cachedResult = this._cache.get(cacheKey);

        if (cachedResult) {
            return cachedResult;
        }

        var size = zeroSize();
        var measureBox = options.box || defaultMeasureBox;
        var baselineMarker = this._baselineMarker().cloneNode(false);

        for (var key in style) {
            var value = style[key];
            if (typeof value !== "undefined") {
                measureBox.style[key] = value;
            }
        }

        var textStr = options.normalizeText !== false ? normalizeText(text) : String(text);

        measureBox.textContent = textStr;
        measureBox.appendChild(baselineMarker);
        document.body.appendChild(measureBox);

        if (textStr.length) {
            size.width = measureBox.offsetWidth - this.options.baselineMarkerSize;
            size.height = measureBox.offsetHeight;
            size.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;
        }

        if (size.width > 0 && size.height > 0) {
            this._cache.put(cacheKey, size);
        }

        measureBox.parentNode.removeChild(measureBox);

        return size;
    },

    _baselineMarker: function() {
        var marker = document.createElement("div");
        marker.style.cssText = "display: inline-block; vertical-align: baseline;width: " +
            this.options.baselineMarkerSize + "px; height: " + this.options.baselineMarkerSize + "px;overflow: hidden;";

        return marker;
    }
});

TextMetrics.current = new TextMetrics();

function measureText(text, style, measureBox) {
    return TextMetrics.current.measure(text, style, measureBox);
}

kendo.deepExtend(kendo.util, {
    LRUCache: LRUCache,
    TextMetrics: TextMetrics,
    measureText: measureText,
    objectKey: objectKey,
    hashKey: hashKey,
    normalizeText: normalizeText
});

})(window.kendo.jQuery);

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });
(function(f, define) {
    define('util/main',[
        "../kendo.core"
    ], f);
})(function() {

(function () {
    // Imports ================================================================
    var kendo = window.kendo,
        deepExtend = kendo.deepExtend;

    function sqr(value) {
        return value * value;
    }

    var now = Date.now;
    if (!now) {
        now = function() {
            return new Date().getTime();
        };
    }

    // Template helpers =======================================================

    function renderSize(size) {
        if (typeof size !== "string") {
            size += "px";
        }

        return size;
    }

    function renderPos(pos) {
        var result = [];

        if (pos) {
            var parts = kendo.toHyphens(pos).split("-");

            for (var i = 0; i < parts.length; i++) {
                result.push("k-pos-" + parts[i]);
            }
        }

        return result.join(" ");
    }

    function arabicToRoman(n) {
        var literals = {
            1    : "i",       10   : "x",       100  : "c",
            2    : "ii",      20   : "xx",      200  : "cc",
            3    : "iii",     30   : "xxx",     300  : "ccc",
            4    : "iv",      40   : "xl",      400  : "cd",
            5    : "v",       50   : "l",       500  : "d",
            6    : "vi",      60   : "lx",      600  : "dc",
            7    : "vii",     70   : "lxx",     700  : "dcc",
            8    : "viii",    80   : "lxxx",    800  : "dccc",
            9    : "ix",      90   : "xc",      900  : "cm",
            1000 : "m"
        };
        var values = [ 1000,
                       900 , 800, 700, 600, 500, 400, 300, 200, 100,
                       90  , 80 , 70 , 60 , 50 , 40 , 30 , 20 , 10 ,
                       9   , 8  , 7  , 6  , 5  , 4  , 3  , 2  , 1 ];
        var roman = "";
        while (n > 0) {
            if (n < values[0]) {
                values.shift();
            } else {
                roman += literals[values[0]];
                n -= values[0];
            }
        }
        return roman;
    }

    function romanToArabic(r) {
        r = r.toLowerCase();
        var digits = {
            i: 1,
            v: 5,
            x: 10,
            l: 50,
            c: 100,
            d: 500,
            m: 1000
        };
        var value = 0, prev = 0;
        for (var i = 0; i < r.length; ++i) {
            var v = digits[r.charAt(i)];
            if (!v) {
                return null;
            }
            value += v;
            if (v > prev) {
                value -= 2 * prev;
            }
            prev = v;
        }
        return value;
    }

    function memoize(f) {
        var cache = Object.create(null);
        return function() {
            var id = "";
            for (var i = arguments.length; --i >= 0;) {
                id += ":" + arguments[i];
            }
            return id in cache ? cache[id] : (cache[id] = f.apply(this, arguments));
        };
    }

    function isUnicodeLetter(ch) {
        return RX_UNICODE_LETTER.test(ch);
    }

    function withExit(f, obj) {
        try {
            return f.call(obj, function(value){
                throw new Return(value);
            });
        } catch(ex) {
            if (ex instanceof Return) {
                return ex.value;
            }
            throw ex;
        }
        function Return(value) {
            this.value = value;
        }
    }

    // Exports ================================================================
    deepExtend(kendo, {
        util: {
            now: now,
            renderPos: renderPos,
            renderSize: renderSize,
            sqr: sqr,
            romanToArabic: romanToArabic,
            arabicToRoman: arabicToRoman,
            memoize: memoize,
            isUnicodeLetter: isUnicodeLetter,
            withExit: withExit
        }
    });

    var RX_UNICODE_LETTER = new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");

})();

return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('util/parse-xml',[ "../kendo.core", "./main" ], f);
})(function(){
    "use strict";

    // SAX-style XML parser ====================================================
    var STRING = String.fromCharCode;

    // XXX: add more here?
    var ENTITIES = {
        "amp"  : 38,
        "lt"   : 60,
        "gt"   : 62,
        "quot" : 34,
        "apos" : 39,
        "nbsp" : 160
    };

    function CODE(str) {
        var out = [];
        for (var i = 0; i < str.length; ++i) {
            out.push(str.charCodeAt(i));
        }
        return out;
    }

    function UCS2(out, code) {
        if (code > 0xFFFF) {
            code -= 0x10000;
            out.push(code >>> 10 & 0x3FF | 0xD800,
                     0xDC00 | code & 0x3FF);
        } else {
            out.push(code);
        }
    }

    var START_CDATA     = CODE("<![CDATA[");
    var END_CDATA       = CODE("]]>");
    var END_COMMENT     = CODE("-->");
    var START_COMMENT   = CODE("!--");
    var END_SHORT_TAG   = CODE("/>");
    var END_TAG         = CODE("</");
    var END_DECLARATION = CODE("?>");
    var QUESTION_MARK   = CODE("?");
    var LESS_THAN       = CODE("<");
    var GREATER_THAN    = CODE(">");
    var SEMICOLON       = CODE(";");
    var EQUAL           = CODE("=");
    var AMPERSAND       = CODE("&");
    var QUOTE           = CODE('"');
    var APOSTROPHE      = CODE("'");
    var SHARP           = CODE("#");
    var LOWERCASE_X     = CODE("x");
    var UPPERCASE_X     = CODE("X");

    var EXIT = {};

    function parse(data, callbacks) {
        var index = 0;
        var stack = [];
        var object = {
            is: function(selector) {
                var i = stack.length, j = selector.length;
                while (--i >= 0 && --j >= 0) {
                    if (stack[i].$tag != selector[j] && selector[j] != "*") {
                        return false;
                    }
                }
                return j < 0 ? stack[stack.length - 1] : null;
            },
            exit: function() {
                throw EXIT;
            },
            stack: stack
        };

        function readChar(body) {
            var code = data[index++];
            if (!(code & 0xF0 ^ 0xF0)) {// 4 bytes
                UCS2(body,
                     ((code & 0x03) << 18) |
                     ((data[index++] & 0x3F) << 12) |
                     ((data[index++] & 0x3F) << 6) |
                     (data[index++] & 0x3F));
            } else if (!(code & 0xE0 ^ 0xE0)) {// 3 bytes
                UCS2(body,
                     ((code & 0x0F) << 12) |
                     ((data[index++] & 0x3F) << 6) |
                     (data[index++] & 0x3F));
            } else if (!(code & 0xC0 ^ 0xC0)) {// 2 bytes
                UCS2(body,
                     ((code & 0x1F) << 6) |
                     (data[index++] & 0x3F));
            } else {
                body.push(code);
            }
        }

        function croak(msg) {
            throw new Error(msg + ", at " + index);
        }

        function readWhile(pred) {
            var a = [];
            while (index < data.length && pred(data[index])) {
                a.push(data[index++]);
            }
            return a;
        }

        function readAsciiWhile(pred) {
            return STRING.apply(0, readWhile(pred));
        }

        function skipWhitespace() {
            readWhile(isWhitespace);
        }

        function eat(a) {
            var save = index;
            for (var i = 0; i < a.length; ++i) {
                if (data[index++] != a[i]) {
                    index = save;
                    return false;
                }
            }
            return a;
        }

        function skip(code) {
            if (!eat(code)) {
                croak("Expecting " + code.join(", "));
            }
        }

        function isWhitespace(code) {
            return code == 9 || code == 10 || code == 13 || code == 32;
        }

        function isDigit(code) {
            return code >= 48 && code <= 57;
        }

        function isHexDigit(code) {
            return (code >= 48 && code <= 57) ||
                   ((code|=32) >= 97 && code <= 102); // a..f or A..F
        }

        function isNameStart(code) {
            return code == 58 ||                      // :
                   code == 95 ||                      // _
                   ((code|=32) >= 97 && code <= 122); // a..z or A..Z
        }

        function isName(code) {
            return code == 45 ||                      // -
                   isDigit(code) ||
                   isNameStart(code);
        }

        function xmlComment() {
            var body = [];
            while (index < data.length) {
                if (eat(END_COMMENT)) {
                    return call("comment", STRING.apply(0, body));
                }
                readChar(body);
            }
        }

        function xmlTag() {
            var name, attrs;
            if (eat(QUESTION_MARK)) {
                xmlDecl();
            } else if (eat(START_COMMENT)) {
                xmlComment();
            } else {
                name = xmlName();
                attrs = xmlAttrs(name);
                stack.push(attrs);
                if (eat(END_SHORT_TAG)) {
                    call("enter", name, attrs, true);
                } else {
                    skip(GREATER_THAN);
                    call("enter", name, attrs);
                    xmlContent(name);
                    if (name != xmlName()) {
                        croak("Bad closing tag");
                    }
                    call("leave", name, attrs);
                    skipWhitespace();
                    skip(GREATER_THAN);
                }
                stack.pop();
            }
        }

        function xmlContent(name) {
            var body = [];
            while (index < data.length) {
                if (eat(END_TAG)) {
                    return body.length && call("text", STRING.apply(0, body));
                } else if (eat(START_CDATA)) {
                    while (index < data.length && !eat(END_CDATA)) {
                        readChar(body);
                    }
                } else if (eat(LESS_THAN)) {
                    if (body.length) {
                        call("text", STRING.apply(0, body));
                    }
                    xmlTag();
                    body = [];
                } else if (eat(AMPERSAND)) {
                    xmlEntity(body);
                } else {
                    readChar(body);
                }
            }
            croak("Unclosed tag " + name);
        }

        function xmlName() {
            if (!isNameStart(data[index])) {
                croak("Expecting XML name");
            }
            return readAsciiWhile(isName);
        }

        function xmlString() {
            var quote = eat(QUOTE) || eat(APOSTROPHE);
            if (!quote) {
                croak("Expecting string");
            }
            var body = [];
            while (index < data.length) {
                if (eat(quote)) {
                    return STRING.apply(0, body);
                } else if (eat(AMPERSAND)) {
                    xmlEntity(body);
                } else {
                    readChar(body);
                }
            }
            croak("Unfinished string");
        }

        function xmlEntity(body) {
            var code;
            if (eat(SHARP)) {
                if (eat(LOWERCASE_X) || eat(UPPERCASE_X)) {
                    code = parseInt(readAsciiWhile(isHexDigit), 16);
                } else {
                    code = parseInt(readAsciiWhile(isDigit), 10);
                }
                if (isNaN(code)) {
                    croak("Bad numeric entity");
                }
            } else {
                var name = xmlName();
                code = ENTITIES[name];
                if (code === undefined) {
                    croak("Unknown entity " + name);
                }
            }
            UCS2(body, code);
            skip(SEMICOLON);
        }

        function xmlDecl() {
            call("decl", xmlName(), xmlAttrs());
            skip(END_DECLARATION);
        }

        function xmlAttrs(name) {
            var map = { $tag: name };
            while (index < data.length) {
                skipWhitespace();
                var code = data[index];
                if (code == 63 || code == 62 || code == 47) { // ?, > or /
                    break;
                }
                map[xmlName()] = ( skip(EQUAL), xmlString() );
            }
            return map;
        }

        function call(what, thing, arg1, arg2) {
            var f = callbacks && callbacks[what];
            if (f) {
                f.call(object, thing, arg1, arg2);
            }
        }

        // skip BOM
        var tmp = [];
        readChar(tmp);
        if (tmp[0] != 65279) {
            index = 0;
        }

        while (index < data.length) {
            skipWhitespace();
            skip(LESS_THAN);
            xmlTag();
            skipWhitespace();
        }
    }

    // Exports ================================================================
    kendo.util.parseXML = function parseXML() {
        try {
            return parse.apply(this, arguments);
        } catch(ex) {
            if (ex !== EXIT) {
                throw ex;
            }
        }
    };

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/commands',[
        "../kendo.core",
        "../kendo.binder",
        "../kendo.window",
        "../kendo.list",
        "../kendo.tabstrip"
    ], f);
})(function(){

(function(kendo) {

    /* jshint laxbreak:true */

    var $ = kendo.jQuery;

    var COMMAND_TYPES = {
        AUTO_FILL: "autoFill",
        CLEAR: "clear",
        CUT: "cut",
        EDIT: "edit",
        PASTE: "paste",
        VALIDATION: "validation"
    };

    var Command = kendo.spreadsheet.Command = kendo.Class.extend({
        init: function(options) {
            this.options = options;
            this._workbook = options.workbook;
            this._property = options && options.property;
            this._state = {};
        },
        range: function(range) {
            if (range !== undefined) {
                this._setRange(range);
            }

            return this._range;
        },
        _setRange: function(range) {
            this._range = range;
        },
        redo: function() {
            this.range().select();
            this.exec();
        },
        undo: function() {
            this.setState(this._state);
        },
        getState: function() {
            this._state = this.range().getState(this._property);
        },
        setState: function(state) {
            this.range().setState(state);
        },
        rejectState: function(validationState) {
            this.undo();
            return {
                title: validationState.title,
                body: validationState.message,
                reason: "error",
                type: "validationError"
            };
        },
        _forEachCell: function(callback) {
            var range = this.range();
            var ref = range._ref;

            ref.forEach(function(ref) {
                range.sheet().forEach(ref.toRangeRef(), callback.bind(this));
            }.bind(this));
        },
        usesImage: function(/* image id from workbook._images */) {
            return false;
        }
    });

    kendo.spreadsheet.DrawingUpdateCommand = Command.extend({
        init: function(options) {
            this._sheet = options.sheet;
            this._drawing = options.drawing;
            this._orig = this._drawing.clone();
            this._previous = options.previous;
        },
        exec: function() {},
        undo: function() {
            this._drawing.reset(this._previous);
            this._sheet._activeDrawing = this._drawing;
            this._sheet.triggerChange({ layout: true });
        },
        redo: function() {
            this._drawing.reset(this._orig);
            this._sheet._activeDrawing = this._drawing;
            this._sheet.triggerChange({ layout: true });
        },
        usesImage: function(img) {
            return this._drawing.image === img
                || this._orig.image === img
                || this._previous.image === img;
        }
    });

    var DrawingCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._drawing = options.drawing;
        },
        usesImage: function(img) {
            return this._drawing.image === img;
        }
    });

    kendo.spreadsheet.InsertImageCommand = DrawingCommand.extend({
        init: function(options) {
            DrawingCommand.fn.init.call(this, options);
            this._blob = options.blob;
            this._width = options.width;
            this._height = options.height;
        },
        exec: function() {
            var range = this.range();
            var sheet = range.sheet();
            var width = this._width;
            var height = this._height;
            var aspect = width / height;
            if (width > height) {
                width = Math.min(width, 300);
                height = width / aspect;
            } else {
                height = Math.min(height, 300);
                width = height * aspect;
            }
            this._drawing = sheet.addDrawing({
                topLeftCell : range.topLeft(),
                offsetX     : 5,
                offsetY     : 5,
                width       : width,
                height      : height,
                opacity     : 1,
                image       : this._workbook.addImage(this._blob)
            }, true);
            this._blob = null;
        },
        undo: function() {
            var sheet = this.range().sheet();
            sheet._activeDrawing = null;
            sheet.removeDrawing(this._drawing);
        },
        redo: function() {
            var sheet = this.range().sheet();
            sheet._activeDrawing = this._drawing;
            sheet.addDrawing(this._drawing);
        }
    });

    kendo.spreadsheet.DeleteDrawingCommand = DrawingCommand.extend({
        exec: function() {
            var sheet = this.range().sheet();
            sheet._activeDrawing = null;
            sheet.removeDrawing(this._drawing);
        },
        undo: function() {
            var sheet = this.range().sheet();
            sheet._activeDrawing = this._drawing;
            sheet.addDrawing(this._drawing);
        },
        redo: function() {
            this.exec();
        }
    });

    var ReorderDrawingsCommand = DrawingCommand.extend({
        exec: function() {
            var sheet = this.range().sheet();
            this._origIndex = sheet._drawings.indexOf(this._drawing);
            sheet._drawings.splice(this._origIndex, 1);
            this._newIndex = this._reorder();
            sheet._drawings.splice(this._newIndex, 0, this._drawing);
            sheet.triggerChange({ drawings: true });
        },
        undo: function() {
            var sheet = this.range().sheet();
            sheet._drawings.splice(this._newIndex, 1);
            sheet._drawings.splice(this._origIndex, 0, this._drawing);
            sheet.triggerChange({ drawings: true });
        }
    });

    kendo.spreadsheet.BringToFrontCommand = ReorderDrawingsCommand.extend({
        _reorder: function() {
            return this.range().sheet()._drawings.length;
        }
    });

    kendo.spreadsheet.SendToBackCommand = ReorderDrawingsCommand.extend({
        _reorder: function() {
            return 0;
        }
    });

    var TargetValueCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._target = options.target;
            this._value = options.value;
        },
        exec: function() {
            this.getState();
            this.setState(this._value);
        }
    });

    kendo.spreadsheet.ColumnWidthCommand = TargetValueCommand.extend({
        getState: function() {
            this._state = this.range().sheet().columnWidth(this._target);
        },
        setState: function(state) {
            this.range().sheet().columnWidth(this._target, state);
        }
    });

    kendo.spreadsheet.RowHeightCommand = TargetValueCommand.extend({
        getState: function() {
            this._state = this.range().sheet().rowHeight(this._target);
        },
        setState: function(state) {
            this.range().sheet().rowHeight(this._target, state);
        }
    });

    kendo.spreadsheet.HyperlinkCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._link = options.link;
        },
        exec: function() {
            var range = this.range();
            this._prevLink = range.link();
            this._prevUnderline = range.underline();
            range.link(this._link);
            range.underline(true);
            if (range.value() == null) { // jshint ignore:line
                this._hasSetValue = true;
                range.value(this._link);
            }
        },
        undo: function() {
            var range = this.range();
            range.link(this._prevLink);
            range.underline(this._prevUnderline);
            if (this._hasSetValue) {
                range.value(null);
            }
        }
    });

    kendo.spreadsheet.GridLinesChangeCommand = TargetValueCommand.extend({
        getState: function() {
            this._state = this._range.sheet().showGridLines();
        },
        setState: function(v) {
            this._range.sheet().showGridLines(v);
        }
    });

    var PropertyChangeCommand = kendo.spreadsheet.PropertyChangeCommand = Command.extend({
        _setRange: function(range) {
            Command.prototype._setRange.call(this, range.skipHiddenCells());
        },
        init: function(options) {
            Command.fn.init.call(this, options);
            this._value = options.value;
        },
        exec: function() {
            var range = this.range();
            if (range.enable()) {
                this.getState();

                if (this.options.property === "format") {
                    this._workbook.trigger("changeFormat", { range: range });
                }

                range[this._property](this._value);
            }
        }
    });

    kendo.spreadsheet.ClearContentCommand = Command.extend({
        exec: function() {
            var values = [], range, rowValues, nullValues, validationState, currentRange;
            if (!this.range().enable()) {
                return { reason: "error", type: "cannotModifyDisabled" };
            }
            if (!this.range().canEditArrayFormula()) {
                return { reason: "error", type: "intersectsArray" };
            }
            this.getState();
            range = this.range().skipHiddenCells();

            if(range._ref.refs && range._ref.refs.length > 1) {
                range._ref.refs.forEach(function(ref) {
                    currentRange = range.sheet().range(ref);
                    values = values.concat(currentRange.values());
                });
            } else {
                values = range.values();
            }
            nullValues = [];
            values.forEach(function(row) {
                rowValues = [];
                row.forEach(function() {
                    rowValues.push(null);
                });
                nullValues.push(rowValues);
            });
            if (range.sheet().trigger("changing", { data: nullValues, range: range, changeType: COMMAND_TYPES.CLEAR })) {
                return;
            }
            range.clearContent();
            validationState = range._getValidationState();
            if (validationState) {
                return this.rejectState(validationState);
            }
        },
        undo: function() {
            var range = this.range().skipHiddenCells();
            var sheet = range.sheet();
            var data = this._state.data;
            var values = [];
            var rowValues;
            data.forEach(function(row) {
                rowValues = [];
                row.forEach(function(cell) {
                    rowValues.push(cell.value);
                });
                values.push(rowValues);
            });
            if (sheet.trigger("changing", { data: values, range: range, changeType: COMMAND_TYPES.CLEAR })) {
                return;
            }
            this.setState(this._state);
        }
    });

    kendo.spreadsheet.EditCommand = PropertyChangeCommand.extend({
        init: function(options) {
            options.property = options.property || "input";
            PropertyChangeCommand.fn.init.call(this, options);
        },
        _setRange: function(range) {
            PropertyChangeCommand.prototype._setRange.apply(this, arguments);
            this._editRange = this.options.arrayFormula ? range : range.sheet().activeCellSelection();
        },
        getState: function() {
            this._state = this.range().getState();
        },
        exec: function() {
            return this.range().sheet().withCultureDecimals(this._exec.bind(this));
        },
        undo: function() {
            var editRange = this._editRange;
            var state = this._state;
            if (editRange.sheet().trigger("changing", { data: state.data[0][0].value, range: editRange, changeType: COMMAND_TYPES.EDIT })) {
                return;
            }
            this.setState(this._state);
        },
        _exec: function() {
            var arrayFormula = this.options.arrayFormula;
            var editRange = this._editRange;

            if (!editRange.enable()) {
                return { reason: "error", type: "rangeDisabled" };
            }

            if (!editRange.canEditArrayFormula()) {
                return { reason: "error", type: "intersectsArray" };
            }

            var value = this._value;
            this.getState();
            if (this.range().sheet().trigger("changing", { data: value, range: this._editRange, changeType: COMMAND_TYPES.EDIT })) {
                return;
            }

            if (this._property == "value") {
                editRange.value(value);
                return;
            }

            try {
                editRange.link(null);
                if (value === "") {
                    editRange.value(null);
                } else {
                    editRange.input(value, { arrayFormula: arrayFormula });
                    if (/\n/.test(editRange.value())) {
                        editRange.wrap(true);
                    }
                }
                editRange._adjustRowHeight();

                var validationState = editRange._getValidationState();
                if (validationState) {
                    return this.rejectState(validationState);
                }
            } catch(ex) {
                if (ex instanceof kendo.spreadsheet.calc.ParseError) {
                    return {
                        title : "Error in formula",
                        body  : ex+"",
                        reason: "error"
                    };
                } else {
                    throw ex;
                }
            }
        }
    });

    kendo.spreadsheet.InsertCommentCommand = PropertyChangeCommand.extend({
        init: function(options) {
            options.property = "comment";
            PropertyChangeCommand.fn.init.call(this, options);
        }
    });

    kendo.spreadsheet.TextWrapCommand = PropertyChangeCommand.extend({
        init: function(options) {
            options.property = "wrap";
            PropertyChangeCommand.fn.init.call(this, options);

            this._value = options.value;
        },
        getState: function() {
            var rowHeight = {};
            this.range().forEachRow(function(range) {
                var index = range.topLeft().row;

                rowHeight[index] = range.sheet().rowHeight(index);
            });

            this._state = this.range().getState(this._property);
            this._rowHeight = rowHeight;
        },
        undo: function() {
            var sheet = this.range().sheet();
            var rowHeight = this._rowHeight;

            this.range().setState(this._state);

            for (var row in rowHeight) {
                sheet.rowHeight(row, rowHeight[row]);
            }
        }
    });

    kendo.spreadsheet.AdjustDecimalsCommand = Command.extend({
        init: function(options) {
            this._delta = options.value;
            options.property = "format";
            Command.fn.init.call(this, options);
        },
        exec: function() {
            var sheet = this.range().sheet();
            var delta = this._delta;
            var formatting = kendo.spreadsheet.formatting;

            this.getState();

            sheet.batch(function() {
                this.range().forEachCell(function(row, col, cell) {
                    var format = cell.format;

                    if (!format) {
                        var value = cell.value;
                        if (typeof value == "number" && /\./.test(value)) {
                            format = "0." + String(value).split(".")[1].replace(/\d/g, "0");
                        }
                    }

                    if (format || delta > 0) {
                        format = formatting.adjustDecimals(format || "0", delta);
                        sheet.range(row, col).format(format);
                    }
                });
            }.bind(this));
        }
    });

    kendo.spreadsheet.BorderChangeCommand = Command.extend({
        init: function(options) {
            options.property = "border";
            Command.fn.init.call(this, options);
            this._type = options.border;
            this._style = options.style;
        },
        _batch: function(f) {
            return this.range().sheet().batch(f, {});
        },
        exec: function() {
            var self = this;
            self.getState();
            self._batch(function(){
                self[self._type](self._style);
            });
        },
        noBorders: function() {
            this.range().insideBorders(null);
            this.outsideBorders(null);
        },
        allBorders: function(style) {
            this.range().insideBorders(style);
            this.outsideBorders(style);
        },
        leftBorder: function(style) {
            this.range().leftColumn().borderLeft(style);
        },
        rightBorder: function(style) {
            this.range().rightColumn().borderRight(style);
        },
        topBorder: function(style) {
            this.range().topRow().borderTop(style);
        },
        bottomBorder: function(style) {
            this.range().bottomRow().borderBottom(style);
        },
        outsideBorders: function(style) {
            var range = this.range();
            range.leftColumn().borderLeft(style);
            range.topRow().borderTop(style);
            range.rightColumn().borderRight(style);
            range.bottomRow().borderBottom(style);
        },
        insideBorders: function(style) {
            this.range().insideBorders(style);
            this.outsideBorders(null);
        },
        insideHorizontalBorders: function(style) {
            this.range().insideHorizontalBorders(style);
        },
        insideVerticalBorders: function(style) {
            this.range().insideVerticalBorders(style);
        }
    });

    kendo.spreadsheet.MergeCellCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._type = options.value;
        },
        exec: function() {
            this.getState();
            this[this._type]();
            this.range().sheet().triggerChange({ recalc: true });
        },
        activate: function(ref) {
            this.range().sheet().activeCell(ref);
        },
        getState: function() {
            this._state = this.range().getState();
        },
        undo: function() {
            if (this._type !== "unmerge") {
                this.range().unmerge();
                this.activate(this.range().topLeft());
            }
            this.range().setState(this._state);
        },
        cells: function() {
            var range = this.range();
            var ref = range._ref;

            range.merge();
            this.activate(ref);
        },
        horizontally: function() {
            var ref = this.range().topRow()._ref;

            this.range().forEachRow(function(range) {
                range.merge();
            });

            this.activate(ref);
        },
        vertically: function() {
            var ref = this.range().leftColumn()._ref;

            this.range().forEachColumn(function(range) {
                range.merge();
            });

            this.activate(ref);
        },
        unmerge: function() {
            var range = this.range();
            var ref = range._ref.topLeft;

            range.unmerge();
            this.activate(ref);
        }
    });

    kendo.spreadsheet.FreezePanesCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._type = options.value;
        },
        exec: function() {
            this.getState();
            this._topLeft = this.range().topLeft();
            this[this._type]();
        },
        getState: function() {
            this._state = this.range().sheet().getState();
        },
        undo: function() {
            this.range().sheet().setState(this._state);
        },
        panes: function() {
            var topLeft = this._topLeft;
            var sheet = this.range().sheet();

            sheet.frozenColumns(topLeft.col).frozenRows(topLeft.row);
        },
        rows: function() {
            var topLeft = this._topLeft;
            var sheet = this.range().sheet();

            sheet.frozenRows(topLeft.row);
        },
        columns: function() {
            var topLeft = this._topLeft;
            var sheet = this.range().sheet();

            sheet.frozenColumns(topLeft.col);
        },
        unfreeze: function() {
            var sheet = this.range().sheet();
            sheet.frozenRows(0).frozenColumns(0);
        }
    });

    kendo.spreadsheet.PasteCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._clipboard = options.workbook.clipboard();
            this._clipboard.parse();
            this._event = options.event;
            this._clipboardContent = this._clipboard._content;
            this._sheet = this._workbook.activeSheet();
            this._range = this._sheet.selection ? this._sheet.selection() : this._sheet.range(this._clipboard.pasteRef());
            this._state = this._range.getState();
            this._targetRangeRefs = (this._range._ref instanceof kendo.spreadsheet.UnionRef ? this._range._ref.refs : [this._range._ref]).map(function(ref){
                return ref.toRangeRef();
            });
        },
        exec: function() {
            return this.range().sheet().withCultureDecimals(this._exec.bind(this));
        },
        undo: function() {
            var sheet = this._sheet;
            var range = this._range;

            if (sheet.trigger("changing", { data: this._state.data, range: range, changeType: COMMAND_TYPES.PASTE })) {
                return;
            }

            this.setState(this._state);
        },
        _exec: function() {
            var status = this._clipboard.canPaste();

            if (!status.canPaste) {
                if (status.menuInvoked) {
                    return { reason: "error", type: "useKeyboard" };
                }
                if (status.pasteOnMerged) {
                    return { reason: "error", type: "modifyMerged" };
                }
                if (status.pasteOnDisabled) {
                    this._event.preventDefault();
                    return { reason: "error", type: "cannotModifyDisabled" };
                }
                return { reason: "error" };
            }

            var sheet = this._sheet;
            var range = this._range;

            if(this._workbook.trigger("paste", {range: range, clipboardContent: this._clipboardContent}) ||
                sheet.trigger("changing", { data: this._clipboardContent.data, range: range, changeType: COMMAND_TYPES.PASTE })) {
                this._event.preventDefault();
                return;
            } else {
                this._processPaste();
            }
        },
        _adjustPasteTarget: function(multipliers, sourceRows, sourceCols) {
            var that = this;
            var targetRangeRefs = that._targetRangeRefs;
            var sheet = that._sheet;
            var RangeRef = kendo.spreadsheet.RangeRef;
            var UnionRef = kendo.spreadsheet.UnionRef;
            var refs = [];
            var compare = function (a, b) {
                var result = 0;
                var topLeftA = a.topLeft;
                var topLeftB = b.topLeft;

                if (topLeftA.row > topLeftB.row) {
                    result = 1;
                } else if (topLeftA.row < topLeftB.row) {
                    result = -1;
                } else if (topLeftA.col > topLeftB.col) {
                    result = 1;
                } else if (topLeftA.col < topLeftB.col) {
                    result = -1;
                }

                return result;
            };

            var refToSelect, rangeToSelect, ref, topLeft, multiplier, i, bottomRight;

            for(i = 0; i < targetRangeRefs.length; i += 1) {
                ref = targetRangeRefs[i];
                multiplier = multipliers[i];
                topLeft = ref.topLeft;
                bottomRight = {
                    row: multiplier.rows * sourceRows + topLeft.row - 1,
                    col: multiplier.cols * sourceCols + topLeft.col - 1
                };

                refToSelect = new RangeRef(topLeft, bottomRight);
                refs.push(refToSelect);
            }

            if(refs.length === 1) {
                rangeToSelect = sheet.range(refToSelect);
            } else {
                refs.sort(compare);
                rangeToSelect = sheet.range(new UnionRef(refs));
            }

            rangeToSelect.select();
            that._range = rangeToSelect;
            that._state = that._range.getState();
        },
        _processPaste: function() {
            var that = this;
            var sheet = that._sheet;
            var clipboardContent = that._clipboardContent;
            var range = that._range;
            var sourceData = clipboardContent.data;
            var sourceRows = sourceData.length;
            var sourceCols = sourceData[0].length;
            var targetRangeRefs = that._targetRangeRefs;
            var multipliers = that._targetRanges(sourceRows, sourceCols);
            var i;

            var pasteRef = this._clipboard.pasteRef();
            if (pasteRef.bottomRight.row >= sheet._rows._count || pasteRef.bottomRight.col >= sheet._columns._count) {
                sheet.resize(
                    Math.max(pasteRef.bottomRight.row + 1, sheet._rows._count),
                    Math.max(pasteRef.bottomRight.col + 1, sheet._columns._count)
                );
            }

            that._adjustPasteTarget(multipliers, sourceRows, sourceCols);

            sheet.batch(function() {
                for(i = 0; i < targetRangeRefs.length; i++) {
                    that._populateTargetRange(targetRangeRefs[i], sourceRows, sourceCols, multipliers[i]);
                }
            }, {
                recalc: true,
                ref: that._range._ref
            });

            range._adjustRowHeight();
        },
        _populateTargetRange: function(ref, sourceRows, sourceCols, multipliers) {
            var topLeft = ref.topLeft;
            var range, i, j;

            for(i = 0; i < multipliers.rows; i++) {
                for(j = 0; j < multipliers.cols; j++) {
                    range = this._sheet.range(topLeft.row + sourceRows * i, topLeft.col + sourceCols * j);
                    range.setState(this._clipboardContent, this._clipboard);
                }
            }
        },
        _targetRangeDimensions: function(ref, sourceRows, sourceCols) {
            var topLeft = ref.topLeft;
            var bottomRight = ref.bottomRight;
            var targetRangeRows = bottomRight.row - topLeft.row + 1;
            var targetRangeCols = bottomRight.col - topLeft.col + 1;
            var rowsMultiplier = 1;
            var colsMultiplier = 1;

            if((targetRangeRows % sourceRows === 0 && targetRangeCols % sourceCols === 0)) {
                rowsMultiplier = targetRangeRows / sourceRows;
                colsMultiplier = targetRangeCols / sourceCols;
            }

            return {
                rows: rowsMultiplier,
                cols: colsMultiplier
            };
        },
        _targetRanges: function(sourceRows, sourceCols) {
            var targetRangeRefs = this._targetRangeRefs;
            var multipliers = [];
            var i;

            for(i = 0; i < targetRangeRefs.length; i++) {
                multipliers.push(this._targetRangeDimensions(targetRangeRefs[i], sourceRows, sourceCols));
            }

            return multipliers;
        }
    });

    kendo.spreadsheet.AdjustRowHeightCommand = Command.extend({
        exec: function() {
            var options = this.options;
            var sheet = this._workbook.activeSheet();
            var range = options.range || sheet.range(options.rowIndex);

            range._adjustRowHeight();
        }
    });

    kendo.spreadsheet.ToolbarPasteCommand = Command.extend({
        exec: function() {
            if (kendo.support.clipboard.paste) {
                this._workbook._view.clipboard.focus().select();
                //reason : focusclipbord
                document.execCommand('paste');
            } else {
                return { reason: "error", type: "useKeyboard" };
            }
        }
    });

    kendo.spreadsheet.CutCommand = Command.extend({
        _eventType: "cut",
        init: function(options) {
            Command.fn.init.call(this, options);
            this._clipboard = options.workbook.clipboard();
            this._event = options.event;
        },
        exec: function() {
            var status = this._clipboard.canCopy();
            var data = [], rangeValues, currentRow;
            if (!status.canCopy) {
                if (status.menuInvoked) {
                    return { reason: "error", type: "useKeyboard" };
                } else if (status.multiSelection) {
                    return { reason: "error", type: "unsupportedSelection" };
                }
                return;
            }
            var range = this._workbook.activeSheet().selection();
            if (this._eventType == "cut") {
                if (!range.enable()) {
                    this._event.preventDefault();
                    return { reason: "error", type: "cannotModifyDisabled" };
                }
                this.getState();
            }
            if (this._workbook.trigger(this._eventType, { range: range })) {
                this._event.preventDefault();
            } else if (this._eventType == "cut") {
                rangeValues = range.values();
                rangeValues.forEach(function(row){
                    currentRow = [];
                    row.forEach(function(){
                        currentRow.push({});
                    });
                    data.push(currentRow);
                });
                if (range.sheet().trigger("changing", { data: data, range: range, changeType: COMMAND_TYPES.CUT })) {
                    return;
                }
                this._clipboard.cut();
            } else {
                this._clipboard.copy();
            }
        },
        undo: function() {
            var range = this.range();
            if (range.sheet().trigger("changing", { data: this._state.data, range: range, changeType: COMMAND_TYPES.CUT })) {
                return;
            }
            this.setState(this._state);
        }
    });

    kendo.spreadsheet.CopyCommand = kendo.spreadsheet.CutCommand.extend({
        _eventType: "copy",
        undo: $.noop
    });

    // function copyToClipboard(html) {
    //     var textarea = document.createElement('textarea');
    //     $(textarea).addClass("k-spreadsheet-clipboard")
    //         .val(html)
    //         .appendTo(document.body)
    //         .trigger("focus")
    //         .select();

    //     document.execCommand('copy');

    //     $(textarea).remove();
    // }

    kendo.spreadsheet.ToolbarCopyCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._clipboard = options.workbook.clipboard();
        },
        undo: $.noop,
        exec: function() {
            if (kendo.support.clipboard.copy) {
                document.execCommand('copy');
            } else {
                return { reason: "error", type: "useKeyboard" };
            }
        }
    });

    kendo.spreadsheet.AutoFillCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
        },
        origin: function(origin) {
            this._origin = origin;
        },
        exec: function() {
            var range = this.range(), autoFillData;
            if (!range.enable()) {
                return { reason: "error", type: "rangeDisabled" };
            }
            if (range.intersectingArrayFormula()) {
                return { reason: "error", type: "intersectsArray" };
            }
            this.getState();
            try {
                autoFillData = range._previewFillFrom(this._origin);
                if (range.sheet().trigger("changing", { data: autoFillData.props, range: autoFillData.dest, changeType: COMMAND_TYPES.AUTO_FILL })) {
                    return;
                }
                autoFillData.dest._properties(autoFillData.props, true);
            } catch(ex) {
                if (ex instanceof kendo.spreadsheet.Range.FillError) {
                    return { reason: "error", type: ex.code };
                }
                throw ex;
            }
        },
        undo: function() {
            var range = this.range();
            var state = this._state;
            if (range.sheet().trigger("changing", { data: state.data, range: range, changeType: COMMAND_TYPES.AUTO_FILL })) {
                return;
            }
            this.setState(this._state);
        }
    });

    kendo.spreadsheet.ToolbarCutCommand = Command.extend({
        cannotUndo: true,
        init: function(options) {
            Command.fn.init.call(this, options);
            this._clipboard = options.workbook.clipboard();
        },
        exec: function() {
            if (kendo.support.clipboard.copy) {
                document.execCommand('cut');
            } else {
                return { reason: "error", type: "useKeyboard" };
            }
        }
    });

    kendo.spreadsheet.FilterCommand = Command.extend({
        undo: function() {
            this.range().filter(this._state);
        },
        exec: function() {
            var range = this.range();
            this._state = range.hasFilter();
            range.filter(!this._state);
        }
    });

    kendo.spreadsheet.SortCommand = Command.extend({
        undo: function() {
            var sheet = this.range().sheet();
            sheet.setState(this._state);
        },
        exec: function() {
            var range = this.range();
            var sheet = range.sheet();
            var activeCell = sheet.activeCell();
            var col = this.options.sheet ? activeCell.topLeft.col : (this.options.column || 0);
            var ascending = this.options.value === "asc" ? true : false;

            this._state = sheet.getState();

            if (this.options.sheet) {
                range = this.expandRange();
            }

            var reason = range.cantSort();
            if (reason) {
                return { reason: "error", type: reason.code };
            }

            range.sort({ column: col, ascending: ascending });
        },
        expandRange: function() {
            var sheet = this.range().sheet();
            return new kendo.spreadsheet.Range(sheet._sheetRef, sheet);
        }
    });

    var ApplyFilterCommand = kendo.spreadsheet.ApplyFilterCommand = Command.extend({
        column: function() {
            return this.options.column || 0;
        },
        undo: function() {
            var sheet = this.range().sheet();

            sheet.clearFilter(this.column());

            if (this._state.length) {
                this.range().filter(this._state);
            }
        },
        getState: function() {
            var sheet = this.range().sheet();
            var current = sheet.filter();

            if (current) {
                this._state = current.columns.filter(function(c) {
                    return c.index == this.column();
                }.bind(this));
            }
        },
        exec: function() {
            var range = this.range();
            var column = this.column();
            var current = range.sheet().filter();
            var options;
            var filterRule;
            var exists = false;

            if (this.options.valueFilter) {
                filterRule = { column: column, filter: new kendo.spreadsheet.ValueFilter(this.options.valueFilter) };
            } else if (this.options.customFilter) {
                filterRule = { column: column, filter: new kendo.spreadsheet.CustomFilter(this.options.customFilter) };
            }

            this.getState();

            if (current && current.ref.eq(range._ref) && current.columns.length) {
                current.columns.forEach(function(element) {
                    if (element.index === column) {
                        exists = true;
                    }
                });

                options = current.columns.map(function(element) {
                    return element.index === column ? filterRule : { column: element.index, filter: element.filter };
                });

                if (!exists) {
                    options.push(filterRule);
                }
            } else {
                options = filterRule;
            }

            range.filter(options);
        }
    });

    kendo.spreadsheet.ClearFilterCommand = ApplyFilterCommand.extend({
        exec: function() {
            var range = this.range();
            var column = this.column();

            this.getState();
            range.clearFilter(column);
        }
    });

    kendo.spreadsheet.HideLineCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this.axis = options.axis;
        },

        undo: function() {
            var sheet = this.range().sheet();
            sheet.setAxisState(this._state);
        },

        exec: function() {
            var sheet = this.range().sheet();
            this._state = sheet.getAxisState();

            if (this.axis == "row") {
                sheet.axisManager().hideSelectedRows();
            } else {
                sheet.axisManager().hideSelectedColumns();
            }
        }
    });

    kendo.spreadsheet.UnHideLineCommand = kendo.spreadsheet.HideLineCommand.extend({
        exec: function() {
            var sheet = this.range().sheet();
            this._state = sheet.getAxisState();

            if (this.axis == "row") {
                sheet.axisManager().unhideSelectedRows();
            } else {
                sheet.axisManager().unhideSelectedColumns();
            }
        }
    });

    var DeleteCommand = Command.extend({
        exec: function() {
            this._expandedRange = this._expand(this.range());
            this._state = this._expandedRange.getState();
            this._indexes = this._exec(this._expandedRange.sheet());
        },
        undo: function() {
            var self = this;
            var range = self._expandedRange;
            var sheet = range.sheet();
            sheet.batch(function(){
                self._indexes.forEach(function(x){
                    self._undoOne(sheet, x);
                    sheet._restoreModifiedFormulas(x.formulas);
                });
                range.setState(self._state);
            }, { layout: true, recalc: true, ref: range._ref });
        }
    });

    kendo.spreadsheet.DeleteRowCommand = DeleteCommand.extend({
        _expand: function(range) {
            return range.resize({ left: -Infinity, right: +Infinity });
        },
        _exec: function(sheet) {
            return sheet.axisManager().deleteSelectedRows();
        },
        _undoOne: function(sheet, x) {
            sheet.insertRow(x.index);
            sheet.rowHeight(x.index, x.height);
        }
    });

    kendo.spreadsheet.DeleteColumnCommand = DeleteCommand.extend({
        _expand: function(range) {
            return range.resize({ top: -Infinity, bottom: +Infinity });
        },
        _exec: function(sheet) {
            return sheet.axisManager().deleteSelectedColumns();
        },
        _undoOne: function(sheet, x) {
            sheet.insertColumn(x.index);
            sheet.columnWidth(x.index, x.width);
        }
    });

    var AddCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._value = options.value;
        },
        undo: function() {
            var self = this;
            var sheet = self.range().sheet();
            sheet.batch(function(){
                for (var i = self._pos.count; --i >= 0;) {
                    self._undoOne(sheet, self._pos.base);
                }
            }, { layout: true, recalc: true });
        }
    });

    kendo.spreadsheet.AddColumnCommand = AddCommand.extend({
        exec: function() {
            var value = this._value;
            var sheet = this.range().sheet();

            if (value === "left") {
                this._pos = sheet.axisManager().addColumnLeft();
            } else {
                this._pos = sheet.axisManager().addColumnRight();
            }
        },
        _undoOne: function(sheet, index) {
            sheet.deleteColumn(index);
        }
    });

    kendo.spreadsheet.AddRowCommand = AddCommand.extend({
        exec: function() {
            var value = this._value;
            var sheet = this.range().sheet();

            if (value === "above") {
                this._pos = sheet.axisManager().addRowAbove();
            } else {
                this._pos = sheet.axisManager().addRowBelow();
            }
        },
        _undoOne: function(sheet, index) {
            sheet.deleteRow(index);
        }
    });

    kendo.spreadsheet.EditValidationCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._value = options.value;
        },
        exec: function() {
            var self = this, sheet = self.range().sheet();
            this.getState();
            if (sheet.trigger("changing", { data: self._value, range: self.range(), changeType: COMMAND_TYPES.VALIDATION })) {
                return;
            }
            try {
                sheet.withCultureDecimals(function(){
                    self.range().validation(self._value);
                });
            } catch(ex) {
                if (ex instanceof kendo.spreadsheet.calc.ParseError) {
                    return {
                        title : "Error in formula",
                        body  : ex+"",
                        reason: "error"
                    };
                } else {
                    throw ex;
                }
            }
        },
        undo: function() {
            var editRange = this.range();
            var state = this._state;
            if (editRange.sheet().trigger("changing", { data: state.data[0][0].validation, range: editRange, changeType: COMMAND_TYPES.VALIDATION })) {
                return;
            }
            this.setState(this._state);
        }
    });

    kendo.spreadsheet.OpenCommand = Command.extend({
        cannotUndo: true,
        exec: function() {
            var file = this.options.file;
            if (file.name.match(/.xlsx$/i) === null) {
                return { reason: "error", type: "openUnsupported" };
            }

            var workbook = this.options.workbook;
            workbook.fromFile(this.options.file).then(function(){
                var errors = workbook.excelImportErrors;
                if (errors && errors.length) {
                    workbook._view.openDialog("importError", {
                        errors: errors
                    });
                }
            });
        }
    });

    kendo.spreadsheet.SaveAsCommand = Command.extend({
        cannotUndo: true,
        exec: function() {
            var fileName = this.options.name + this.options.extension;
            if (this.options.extension === ".xlsx") {
                this.options.workbook.saveAsExcel({
                    fileName: fileName
                });
            } else if (this.options.extension === ".pdf") {
                this.options.workbook.saveAsPDF($.extend(this.options.pdf, {workbook: this.options.workbook, fileName: fileName}));
            }
        }
    });

    var NameCommand = Command.extend({
        init: function(options) {
            Command.fn.init.call(this, options);
            this._name = options.name;
            this._value = options.value;
        },
        getState: function() {
            this._state = this._workbook.nameDefinition(this._name);
        },
        setState: function() {
            this._workbook.nameDefinition(this._name, this._state);
            this._workbook.trigger("change", { recalc: true });
        }
    });

    kendo.spreadsheet.DefineNameCommand = NameCommand.extend({
        exec: function() {
            this.getState();
            try {
                this._workbook.defineName(this._name, this._value);
                this._workbook.trigger("change", { recalc: true });
            } catch(ex) {
                return {
                    title: "Error",
                    body: ex+"",
                    reason: "error"
                };
            }
        }
    });

    kendo.spreadsheet.DeleteNameCommand = NameCommand.extend({
        exec: function() {
            this.getState();
            this._workbook.undefineName(this._name);
            this._workbook.trigger("change", { recalc: true });
        }
    });

})(kendo);

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/formulabar',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var $ = kendo.jQuery;

    var classNames = {
        wrapper: "k-spreadsheet-formula-bar"
    };

    var FormulaBar = kendo.ui.Widget.extend({
        init: function(element, options) {
            kendo.ui.Widget.call(this, element, options);

            element = this.element.addClass(FormulaBar.classNames.wrapper);

            $("<span class='k-icon k-i-formula-fx' />").prependTo(element);

            var formulaBarWidth = element.width();

            this.formulaInput = new kendo.spreadsheet.FormulaInput($("<div/>")
                .appendTo(element), { formulaBarWidth: formulaBarWidth });
        },

        destroy: function() {
            if (this.formulaInput) {
                this.formulaInput.destroy();
            }
            this.formulaInput = null;
        }
    });

    kendo.spreadsheet.FormulaBar = FormulaBar;
    $.extend(true, FormulaBar, { classNames: classNames });
})(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/formulainput',[ "../kendo.core" ], f);
})(function(){

(function(kendo, window) {

    /* jshint eqnull:true */
    /* jshint latedef: nofunc */

    var $ = kendo.jQuery;
    var Widget = kendo.ui.Widget;
    var ns = ".kendoFormulaInput";
    var keys = kendo.keys;
    var classNames = {
        wrapper: "k-spreadsheet-formula-input",
        listWrapper: "k-spreadsheet-formula-list"
    };
    var styles = [
        "font-family",
        "font-size",
        "font-stretch",
        "font-style",
        "font-weight",
        "letter-spacing",
        "text-transform",
        "line-height"
    ];

    //move to core
    var KEY_NAMES = {
        27: 'esc',
        37: 'left',
        39: 'right',
        35: 'end',
        36: 'home',
        32: 'spacebar'
    };

    var PRIVATE_FORMULA_CHECK = /(^_|[^a-z0-9]$)/i;

    var FormulaInput = Widget.extend({
        init: function(element, options) {
            Widget.call(this, element, options);

            element = this.element;

            element.addClass(FormulaInput.classNames.wrapper)
                .attr("contenteditable", true)
                .attr("spellcheck", false)
                .css("white-space", "pre");

            if (options && options.formulaBarWidth) {
                element.css("max-width", options.formulaBarWidth - 16 + "px");
            }

            if (this.options.autoScale) {
                element.on("input", this.scale.bind(this));
            }

            this._highlightedRefs = [];

            this._formulaSource();

            this._formulaList();

            this._popup();

            this._tooltip();

            element
                .on("keydown", this._keydown.bind(this))
                .on("keyup", this._keyup.bind(this))
                .on("blur", this._blur.bind(this))
                .on("input click", this._input.bind(this))
                .on("focus", this._focus.bind(this))
                .on("paste", this._paste.bind(this));
        },

        options: {
            name: "FormulaInput",
            autoScale: false,
            filterOperator: "startswith",
            scalePadding: 30,
            minLength: 1,
            formulaBarWidth: null
        },

        events: [
            "keyup",
            "focus"
        ],

        enable: function(enable) {
            if (enable === undefined) {
                return this.element.attr("contenteditable") === "true";
            }

            if (enable) {
                this.element.attr("contenteditable", enable);
            } else {
                this.element.removeAttr("contenteditable");
            }

            this.element.toggleClass("k-state-disabled", !enable);
        },

        getPos: function() {
            var div = this.element[0];
            var sel = window.getSelection();
            var a = lookup(sel.focusNode, sel.focusOffset);
            var b = lookup(sel.anchorNode, sel.anchorOffset);
            if (a != null && b != null) {
                if (a > b) {
                    var tmp = a;
                    a = b;
                    b = tmp;
                }
                return { begin: a, end: b, collapsed: a == b };
            }
            function lookup(lookupNode, pos) {
                try {
                    (function loop(node){
                        if (node === lookupNode) {
                            throw pos;
                        } else if (node.nodeType == 1 /* Element */) {
                            for (var i = node.firstChild; i; i = i.nextSibling) {
                                loop(i);
                            }
                        } else if (node.nodeType == 3 /* Text */) {
                            pos += node.nodeValue.length;
                        }
                    })(div);
                } catch (index) {
                    return index;
                }
            }
        },

        setPos: function(begin, end) {
            var eiv = this.element[0];
            begin = lookup(eiv, begin);
            if (end != null) {
                end = lookup(eiv, end);
            } else {
                end = begin;
            }
            if (begin && end) {
                var range = document.createRange();
                range.setStart(begin.node, begin.pos);
                range.setEnd(end.node, end.pos);
                var sel = window.getSelection();
                var currentRange = sel.getRangeAt(0);
                if (differ(range, currentRange))  {
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }
            function differ(a, b) {
                return (
                    a.startOffset != b.startOffset ||
                    a.endOffset != b.endOffset ||
                    a.startContainer != b.endContainer ||
                    a.endContainer != b.endContainer
                );
            }
            function lookup(node, pos) {
                try {
                    (function loop(node){
                        if (node.nodeType == 3 /* Text */) {
                            var len = node.nodeValue.length;
                            if (len >= pos) {
                                throw node;
                            }
                            pos -= len;
                        } else if (node.nodeType == 1 /* Element */) {
                            for (var i = node.firstChild; i; i = i.nextSibling) {
                                loop(i);
                            }
                        }
                    })(node);
                } catch (el) {
                    return { node: el, pos: pos };
                }
            }
        },

        end: function() {
            this.setPos(this.length());
        },

        home: function() {
            this.setPos(0);
        },

        select: function() {
            this.setPos(0, this.length());
        },

        length: function() {
            return this.value().length;
        },

        _formulaSource: function() {
            var result = [];
            var value;

            for (var key in kendo.spreadsheet.calc.runtime.FUNCS) {
                if (!PRIVATE_FORMULA_CHECK.test(key)) {
                    value = key.toUpperCase();
                    result.push({ value: value, text: value });
                }
            }

            this.formulaSource = new kendo.data.DataSource({ data: result });
        },

        _formulaList: function() {
            this.list = new kendo.ui.StaticList($('<ul />')
                .addClass(FormulaInput.classNames.listWrapper)
                .insertAfter(this.element), {
                    autoBind: false,
                    selectable: true,
                    change: this._formulaListChange.bind(this),
                    dataSource: this.formulaSource,
                    dataValueField: "value",
                    template: "#:data.value#"
                });

            this.list.element.on("mousedown", function(e) {
                e.preventDefault();
            });
        },

        _formulaListChange: function() {
            var tokenCtx = this._tokenContext();

            if (!tokenCtx || this._mute) {
                return;
            }

            var activeToken = tokenCtx.token;
            var completion = this.list.value()[0];
            var ctx = {
                replace: true,
                token: activeToken,
                end: activeToken.end
            };

            if (!tokenCtx.nextToken || tokenCtx.nextToken.value != "(") {
                completion += "(";
            }

            this._replaceAt(ctx, completion);
            this.popup.close();
        },

        _popup: function() {
            this.popup = new kendo.ui.Popup(this.list.element, {
                anchor: this.element
            });
        },

        _blur: function() {
            this.popup.close();
            clearTimeout(this._focusId);
            this.trigger("blur");
        },

        _isFormula: function() {
            return /^=/.test(this.value());
        },

        _keydown: function(e) {
            var key = e.keyCode;
            var that = this;

            if (KEY_NAMES[key]) {
                that.popup.close();
                that._navigated = true;
            } else if (that._move(key)) {
                that._navigated = true;
                e.preventDefault();
            }

            that._keyDownTimeout = setTimeout(that._syntaxHighlight.bind(that));
        },

        _keyup: function() {
            var popup = this.popup;
            var value;

            if (this._isFormula() && !this._navigated) {
                value = ((this._tokenContext() || {}).token || {}).value;

                this.filter(value);

                if (!value || !this.formulaSource.view().length) {
                    popup.close();
                } else {
                    popup[popup.visible() ? "position" : "open"]();
                    this.list.focusFirst();
                }
            }

            this._navigated = false;
            this._syntaxHighlight();

            this.trigger("keyup");
        },

        _input: function() {
            this._syntaxHighlight();
        },

        _focus: function() {
            setTimeout(this._sync.bind(this));
            this._focusTimeout = setTimeout(this._syntaxHighlight.bind(this));
            this.trigger("focus");
        },

        _paste: function(ev) {
            ev.preventDefault();
            var pos = this.getPos();
            var text;
            if (kendo.support.browser.msie) {
                text = window.clipboardData.getData("Text");
            } else {
                text = ev.originalEvent.clipboardData.getData("text/plain");
            }
            var val = this.value();
            val = val.substr(0, pos.begin) + text + val.substr(pos.end);
            this.value(val);
            this.setPos(pos.begin + text.length);
            this.scale();
        },

        _move: function(key) {
            var list = this.list;
            var popup = this.popup;
            if (popup.visible()) {
                if (key === keys.DOWN) {
                    list.focusNext();
                    if (!list.focus()) {
                        list.focusFirst();
                    }
                    return true;
                }
                if (key === keys.UP) {
                    list.focusPrev();
                    if (!list.focus()) {
                        list.focusLast();
                    }
                    return true;
                }
                if (key === keys.ENTER) {
                    list.select(list.focus());
                    popup.close();
                    return true;
                }
                if (key === keys.TAB) {
                    list.select(list.focus());
                    popup.close();
                    return true;
                }
                if (key === keys.PAGEUP) {
                    list.focusFirst();
                    return true;
                }
                if (key === keys.PAGEDOWN) {
                    list.focusLast();
                    return true;
                }
            }
            return key === keys.ENTER || key === keys.TAB;
        },

        _tokenContext: function() {
            var point = this.getPos();
            var value = this.value();

            if (!value || !point || !point.collapsed) {
                return null;
            }

            var tokens = kendo.spreadsheet.calc.tokenize(value, this.row(), this.col());
            var tok;

            for (var i = 0; i < tokens.length; ++i) {
                tok = tokens[i];
                if (touches(tok, point) && /^(?:str|sym|func)$/.test(tok.type)) {
                    return { token: tok, nextToken: tokens[i + 1] };
                }
            }

            return null;
        },

        _sync: function() {
            if (this._editorToSync && this.isActive()) {
                this._editorToSync.value(this.value());
            }
        },

        _textContainer: function() {
            var computedStyles = kendo.getComputedStyles(this.element[0], styles);

            computedStyles.position = "absolute";
            computedStyles.visibility = "hidden";
            computedStyles.whiteSpace = "pre";
            computedStyles.top = -3333;
            computedStyles.left = -3333;

            this._span = $("<span style='white-space: pre'/>").css(computedStyles).insertAfter(this.element);
        },

        _tooltip: function() {
            this._cellTooltip = $('<div class="k-widget k-tooltip" style="position:absolute; display:none">A1</div>').insertAfter(this.element);
        },

        tooltip: function(value) {
            this._cellTooltip.text(value);
        },

        toggleTooltip: function(show) {
            this._cellTooltip.toggle(show);
        },

        isActive: function() {
            return this.element[0] === kendo._activeElement();
        },

        filter: function(value) {
            if (!value || value.length < this.options.minLength) {
                return;
            }

            this._mute = true;
            this.list.select(-1);
            this._mute = false;

            this.formulaSource.filter({
                field: this.list.options.dataValueField,
                operator: this.options.filterOperator,
                value: value
            });
        },

        hide: function() {
            this.enable(false);
            this.element.hide();
            this._cellTooltip.hide();
        },

        show: function() {
            this.enable(true);
            this.element.show();
        },

        row: function() {
            if (this.activeCell) {
                return this.activeCell.row;
            }
        },

        col: function() {
            if (this.activeCell) {
                return this.activeCell.col;
            }
        },

        position: function(rectangle) {
            if (!rectangle) {
                return;
            }

            this.show();

            this.element
                .css({
                    "top": rectangle.top + 1 + "px",
                    "left": rectangle.left + 1 + "px"
                });

            this._cellTooltip.css({
                "top": (rectangle.top - this._cellTooltip.height() - 10) + "px",
                "left": rectangle.left
            });
        },

        resize: function(rectangle) {
            if (!rectangle) {
                return;
            }

            this.element.css({
                width: rectangle.width - 1,
                height: rectangle.height - 1
            });
        },

        canInsertRef: function(isKeyboardAction) {
            return this._canInsertRef(isKeyboardAction);
        },

        _canInsertRef: function(isKeyboardAction) {
            if (this.popup.visible()) {
                return null;
            }
            var strictMode = isKeyboardAction;
            var point = this.getPos();
            var tokens, tok;

            if (point && this._isFormula()) {
                if (point.begin === 0) {
                    return null;
                }

                tokens = kendo.spreadsheet.calc.tokenize(this.value(), this.row(), this.col());

                for (var i = 0; i < tokens.length; ++i) {
                    tok = tokens[i];
                    if (touches(tok, point)) {
                        return canReplace(tok);
                    }
                    if (afterPoint(tok)) {
                        return canInsertBetween(tokens[i-1], tok);
                    }
                }
                return canInsertBetween(tok, null);
            }

            return null;

            function afterPoint(tok) {
                return tok.begin > point.begin;
            }
            function canReplace(tok) {
                if (tok) {
                    if (/^(?:num|str|bool|sym|ref)$/.test(tok.type)) {
                        return { replace: true, token: tok, end: tok.end };
                    }
                    if (/^(?:op|punc|startexp)$/.test(tok.type)) {
                        if (tok.end == point.end) {
                            return canInsertBetween(tok, tokens[i+1]);
                        }
                        return canInsertBetween(tokens[i-1], tok);
                    }
                }
            }
            function canInsertBetween(left, right) {
                if (left == null) {
                    return null;
                }
                if (right == null) {
                    if (/^(?:op|startexp)$/.test(left.type) || isOpenParen(left.value)) {
                        return { token: left, end: point.end };
                    }
                    return null;
                }
                if (strictMode) {
                    if (left.type == "op" && /^(?:punc|op)$/.test(right.type)) {
                        return { token: left, end: point.end };
                    }
                } else {
                    if (left.type == "startexp") {
                        return { token: left, end: point.end };
                    }
                    if (/^(?:op|punc)$/.test(left.type) && /^[,;({]$/.test(left.value)) {
                        return { token: left, end: point.end };
                    }
                    if (/^(?:ref|sym)/.test(left.type)) {
                        return { token: left, replace: true, end: left.end };
                    }
                    if (/^(?:ref|sym)/.test(right.type)) {
                        return { token: right, replace: true, end: right.end };
                    }
                }
                return false;
            }
        },

        refAtPoint: function(sheet) {
            var x = this._canInsertRef();
            if (x) {
                var ref = sheet.selection()._ref.simplify().clone().relative(0, 0, 3);
                if (sheet.isMerged(ref)) {
                    ref = ref.topLeft;
                }
                if (sheet !== this.activeSheet) {
                    ref = ref.setSheet(sheet.name(), true);
                }
                this._replaceAt(x, ref.print(0, 0));
            }
        },

        _replaceAt: function(ctx, newValue) {
            var value = this.value();
            var tok = ctx.token;
            var rest = value.substr(ctx.end);
            value = value.substr(0, ctx.replace ? tok.begin : ctx.end) + newValue;
            var point = value.length;
            value += rest;
            this._value(value);
            this.setPos(point);
            this.scale();
            this._syntaxHighlight();
        },

        syncWith: function(formulaInput) {
            var self = this;

            // IE does not support "input" event on elements with contenteditable
            // https://developer.mozilla.org/en-US/docs/Web/Events/input#Browser_compatibility
            var eventName = "input" + ns;
            var handler = self._sync.bind(self), iehandler;
            if (kendo.support.browser.msie) {
                eventName = "keydown" + ns;
                iehandler = function() {
                    setTimeout(handler);
                };
            }

            self._editorToSync = formulaInput;
            self.element.off(eventName).on(eventName, iehandler || handler);
        },

        scale: function() {
            var element = this.element;
            var width, height;

            if (!this._span) {
                this._textContainer();
            }

            this._span.html(element.html());

            width = this._span.width() + this.options.scalePadding;
            height = this._span.height();

            if (width > element.width()) {
                element.width(width);
            }
            if (height > element.height()) {
                element.height(height);
            }

            this._sync();
        },

        _value: function(value) {
            this.element.text(value);
        },

        value: function(value) {
            if (value === undefined) {
                // jQuery's .text() discards the newlines for some reason
                var txt = this.element[0].innerText;
                return txt.replace(/\n$/, "");
            }

            this._value(value);
            this._syntaxHighlight();
        },

        highlightedRefs: function() {
            return this._highlightedRefs.slice();
        },

        _syntaxHighlight: function() {
            var pos = this.getPos();
            var value = this.value();
            var refClasses = kendo.spreadsheet.Pane.classNames.series;
            var highlightedRefs = [];
            var refIndex = 0;
            var parens = [];
            var tokens = [];
            var activeToken;

            if (pos && !pos.collapsed) {
                // Backward selection (hold shift, move right to left)
                // will not work properly if we continuously re-set
                // the HTML.  If the selection is on, presumably the
                // text has already been highlighted, so stop here.
                return;
            }

            if (!(/^=/.test(value))) {
                // if an user deleted the initial =, reset the text to
                // discard any highlighting.  Only do that once.
                if (this._highlightedRefs.length) {
                    this._highlightedRefs = [];
                    this.element.text(value);
                }

                // also make sure the completion popup goes away
                if (this.popup) {
                    this.popup.close();
                }

                return; // avoid messing with the cursor position below
            } else {
                tokens = kendo.spreadsheet.calc.tokenize(value, this.row(), this.col());
                tokens.forEach(function(tok){
                    tok.active = false;
                    tok.cls = [ "k-syntax-" + tok.type ];

                    if (tok.type == "ref") {
                        tok.colorClass = refClasses[(refIndex++) % refClasses.length];
                        tok.cls.push(tok.colorClass);
                        highlightedRefs.push(tok);
                    }
                    if (pos && tok.type == "punc") {
                        if (isOpenParen(tok.value)) {
                            parens.unshift(tok);
                        } else if (isCloseParen(tok.value)) {
                            var open = parens.shift();
                            if (open) {
                                if (isMatchingParen(tok.value, open.value)) {
                                    if (touches(tok, pos) || touches(open, pos)) {
                                        tok.cls.push("k-syntax-paren-match");
                                        open.cls.push("k-syntax-paren-match");
                                    }
                                } else {
                                    tok.cls.push("k-syntax-error");
                                    open.cls.push("k-syntax-error");
                                }
                            } else {
                                tok.cls.push("k-syntax-error");
                            }
                        }
                    }
                    if (pos && touches(tok, pos)) {
                        tok.cls.push("k-syntax-at-point");
                        tok.active = true;
                        activeToken = tok;
                    }
                    if (tok.type == "func" && !knownFunction(tok.value) && (!pos || !touches(tok, pos))) {
                        tok.cls.push("k-syntax-error");
                    }
                });
                tokens.reverse().forEach(function(tok){
                    var begin = tok.begin, end = tok.end;
                    var text = kendo.htmlEncode(value.substring(begin, end));
                    value = value.substr(0, begin) +
                        "<span class='" + tok.cls.join(" ") + "'>" + text + "</span>" +
                        value.substr(end);
                });
                this.element.html(value);
            }
            if (pos) {
                this.setPos(pos.begin, pos.end);
            }

            this._highlightedRefs = highlightedRefs;
        },

        destroy: function() {
            this._editorToSync = null;

            this.element.off(ns);

            clearTimeout(this._focusTimeout);
            clearTimeout(this._keyDownTimeout);

            this._cellTooltip = null;
            this._span = null;

            this.popup.destroy();
            this.popup = null;

            Widget.fn.destroy.call(this);
        },

        insertNewline: function() {
            var val = this.value();
            var pos = this.getPos();
            var eof = pos.end == val.length;
            val = val.substr(0, pos.begin) + (eof ? "\n\n" : "\n" + val.substr(pos.end));
            this.value(val);
            this.setPos(pos.begin + 1);
        }
    });

    function isOpenParen(ch) {
        return ch == "(" || ch == "[" || ch == "{";
    }

    function isCloseParen(ch) {
        return ch == ")" || ch == "]" || ch == "}";
    }

    function isMatchingParen(close, open) {
        return open == "(" ? close == ")"
            :  open == "[" ? close == "]"
            :  open == "{" ? close == "}"
            :  false;
    }

    function touches(pos, target) {
        return pos.begin <= target.begin && pos.end >= target.end;
    }

    function knownFunction(name) {
        return kendo.spreadsheet.calc.runtime.FUNCS[name.toLowerCase()];
    }

    kendo.spreadsheet.FormulaInput = FormulaInput;
    $.extend(true, FormulaInput, { classNames: classNames });
})(kendo, window);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/eventlistener',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var $ = kendo.jQuery;

    var KEY_NAMES = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        27: 'esc',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        35: 'end',
        36: 'home',
        32: 'spacebar',
        33: 'pageup',
        34: 'pagedown',
        46: 'delete',
        113: ':edit'
    };

    var Mac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;

    var isAlphaNum = function(keyCode) {
        if ((keyCode > 47 && keyCode < 58)   || // number keys
            (keyCode > 64 && keyCode < 91)   || // letter keys
            (keyCode > 95 && keyCode < 112)  || // numpad keys
            (keyCode > 185 && keyCode < 193) || // ;=,-./` (in order)
            (keyCode > 218 && keyCode < 223) || // [\]' (in order)
            (keyCode === 229)                   // combined key event?
           ) {
            return true;
        }

        return false;
    };

    var keyName = function(event) {
        var keyCode = event.keyCode;
        var name = KEY_NAMES[keyCode];

        if (!name && isAlphaNum(keyCode)) {
            name = ":alphanum";
        }

        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
        //
        // Fix for https://github.com/telerik/kendo-ui-core/issues/2284
        // (starting editor with `=` on Firefox)
        if (!name && event.key && event.key.length == 1) {
            name = ":alphanum";
        }

        return name;
    };

    var EventListener = kendo.Class.extend({
        init: function(target, observer, handlers) {
            this._handlers = {};
            this.target = target;
            this._observer = observer || window;

            this.keyDownProxy = this.keyDown.bind(this);
            this.mouseProxy = this.mouse.bind(this);
            this.touchProxy = this.touch.bind(this);
            this.threshold = 5;
            this._pressLocation = null;

            target.on("keydown", this.keyDownProxy);
            target.on("contextmenu mousedown cut copy paste scroll wheel click dblclick focus", this.mouseProxy);
            target.on("touchmove touchend", this.touchProxy);

            $(document.documentElement).on("mousemove mouseup", this.mouseProxy);
            $(document.documentElement).on("touchmove touchend", this.touchProxy);

            if (handlers) {
                for (var key in handlers) {
                    this.on(key, handlers[key]);
                }
            }
        },

        keyDown: function(e) {
            this.handleEvent(e, keyName(e.originalEvent));
        },

        touch: function(e) {
            this.handleEvent(e, e.type);
        },

        mouse: function(e) {

            var rightClick;

            if (e.which) {
                rightClick = (e.which == 3);
            } else if (e.button) {
                rightClick = (e.button == 2);
            }

            var type = e.type;

            if (type === "mousedown") {
                if (rightClick) {
                   type = "rightmousedown";
                } else {
                    this._pressLocation = { x: e.pageX, y: e.pageY };
                }
            }

            if (type === "mouseup") {
                if (!rightClick) {
                    this._pressLocation = null;
                }
            }

            if (type === "mousemove" && this._pressLocation) {
                var dx = this._pressLocation.x - e.pageX;
                var dy = this._pressLocation.y - e.pageY;
                var distance = Math.sqrt(dx*dx + dy*dy);

                if (distance > this.threshold) {
                    type = "mousedrag";
                }
            }

            this.handleEvent(e, type);
        },

        handleEvent: function(e, name) {
            var eventKey = "";

            e.mod = Mac ? e.metaKey : (e.ctrlKey && !e.altKey);

            if (e.altKey) {
                eventKey += "alt+";
            }

            if (e.shiftKey) {
                eventKey += "shift+";
            }

            if (e.ctrlKey) {
                eventKey += "ctrl+";
            }

            eventKey += name;

            var catchAllHandler = this._handlers['*+' + name];

            if (catchAllHandler) {
                catchAllHandler.call(this._observer, e, eventKey);
            }

            var handler = this._handlers[eventKey];

            if (handler) {
                handler.call(this._observer, e, eventKey);
            }
        },

        on: function(event, callback) {
            var handlers = this._handlers;

            if (typeof callback === "string") {
                callback = this._observer[callback];
            }

            if (typeof event === "string") {
                event = event.split(",");
            }

            event.forEach(function(e) {
                handlers[e] = callback;
            });
        },

        destroy: function() {
            this.target.off("keydown", this.keyDownProxy);
            this.target.off("keydown", this.mouseProxy);
            $(document.documentElement).off("mousemove mouseup", this.mouseProxy);
        }
    });

    kendo.spreadsheet.EventListener = EventListener;
})(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/rangelist',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var RangeTreeNode = kendo.Class.extend({
        init: function Node(level, value, left, right) {
            this.level = level;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    });

    var NilNode = new (function NIL() { // jshint ignore:line
        this.left = this;
        this.right = this;
        this.level = 0;
    })();

    function skew(node) {
        if (node.left.level === node.level) {
            var temp = node;
            node = node.left;
            temp.left = node.right;
            node.right = temp;
        }

        return node;
    }

    function split(node) {
        if (node.right.right.level === node.level) {
            var temp = node;
            node = node.right;
            temp.right = node.left;
            node.left = temp;
            node.level += 1;
        }

        return node;
    }

    function insert(node, value) {
        if (node === NilNode) {
            return new RangeTreeNode(1, value, NilNode, NilNode);
        } else if (node.value.start > value.start) {
            node.left = insert(node.left, value);
        } else {
            node.right = insert(node.right, value);
        }

        return split(skew(node));
    }

    function remove(node, value) {
        if (node === NilNode) {
            return node;
        }

        var diff = node.value.start - value.start;
        if (diff === 0) {
            if (node.left !== NilNode && node.right !== NilNode) {
                var heir = node.left;

                while (heir.right !== NilNode) {
                    heir = heir.right;
                }

                node.value = heir.value;
                node.left = remove(node.left, node.value);
            } else if (node.left === NilNode) {
                node = node.right;
            } else {
                node = node.left;
            }
        } else if (diff > 0) {
            node.left = remove(node.left, value);
        } else {
            node.right = remove(node.right, value);
        }

        if (node.left.level < (node.level - 1) || node.right.level < (node.level - 1)) {
            node.level -= 1;
            if (node.right.level > node.level) {
                node.right.level = node.level;
            }

            node = skew(node);
            node.right = skew(node.right);
            node.right.right = skew(node.right.right);
            node = split(node);
            node.right = split(node.right);
        }

        return node;
    }

    var Range = kendo.Class.extend({
        init: function ValueRange(start, end, value) {
            this.start = start;
            this.end = end;
            this.value = value;
        },

        intersects: function(range) {
            return range.start <= this.end && range.end >= this.start;
        },

        clone: function() {
            return new Range(this.start, this.end, this.value);
        }
    });

    var RangeTree = kendo.Class.extend({
        init: function RangeTree() {
            this.root = NilNode;
        },

        insert: function(value) {
            this.root = insert(this.root, value);
        },

        remove: function(value) {
            this.root = remove(this.root, value);
        },

        findrange: function(value) {
            var node = this.root;

            while (node != NilNode) {
                if (value < node.value.start) {
                    node = node.left;
                } else if (value > node.value.end) {
                    node = node.right;
                } else {
                    return node.value;
                }
            }

            return null;
        },

        values: function() {
            var result = [];
            values(this.root, result);
            return result;
        },

        intersecting: function(start, end) {
            var ranges = [];
            intersecting(this.root, new Range(start, end), ranges);
            return ranges;
        },

        map: function(callback) {
            var tree = new RangeTree();
            map(tree, this.root, callback);
            return tree;
        },

        forEach: function(callback) {
            forEach(this.root, callback);
        },

        clone: function() {
            return this.map(function(value) {
                return value.clone();
            });
        },

        first: function() {
            var first = this.root;
            while(first.left != NilNode) {
                first = first.left;
            }

            return first;
        },

        last: function() {
            var last = this.root;
            while(last.right != NilNode) {
                last = last.right;
            }

            return last;
        }
    });

    function values(node, result) {
        if (node === NilNode) {
            return;
        }

        values(node.left, result);
        result.push(node.value);
        values(node.right, result);
    }

    function intersecting(node, range, ranges) {
        if (node === NilNode) {
            return;
        }

        var value = node.value;

        if (range.start < value.start) {
            intersecting(node.left, range, ranges);
        }

        if (value.intersects(range)) {
            ranges.push(value);
        }

        if (range.end > value.end) {
            intersecting(node.right, range, ranges);
        }
    }

    function map(tree, root, callback) {
        if (root === NilNode) {
            return;
        }
        map(tree, root.left, callback);
        tree.insert(callback(root.value));
        map(tree, root.right, callback);
    }

    function forEach(root, callback) {
        if (root === NilNode) {
            return;
        }
        forEach(root.left, callback);
        callback(root.value);
        forEach(root.right, callback);
    }

    var RangeList = kendo.Class.extend({
        init: function RangeList(start, end, value) {
            if (end === undefined) {
                this.tree = start;
            } else {
                this.tree = new RangeTree();
                this.tree.insert(new Range(start, end, value));
            }
        },

        values: function() {
            return this.tree.values();
        },

        map: function(callback) {
            return new RangeList(this.tree.map(callback));
        },

        forEach: function(callback) {
            this.tree.forEach(callback);
        },

        intersecting: function(start, end) {
            return this.tree.intersecting(start, end);
        },

        first: function() {
            return this.tree.first().value;
        },

        last: function() {
            return this.tree.last().value;
        },

        insert: function(start, end, value) {
            return this.tree.insert(new Range(start, end, value));
        },

        value: function(start, end, value) {
            if (value === undefined) {
                if (end === undefined) {
                    end = start;
                }
                return this.intersecting(start, end)[0].value;
            }

            var ranges = this.tree.intersecting(start - 1, end + 1);

            if (ranges.length) {
                var firstRange = ranges[0], lastRange = ranges[ranges.length - 1];

                if (firstRange.end < start) {
                    if (firstRange.value === value) {
                        start = firstRange.start;
                    } else {
                        ranges.shift();
                    }
                }

                if (lastRange.start > end) {
                    if (lastRange.value === value) {
                        end = lastRange.end;
                    } else {
                        ranges.pop();
                    }
                }

                for (var i = 0, length = ranges.length; i < length; i++) {
                    var range = ranges[i];
                    var rangeValue = range.value;
                    var rangeStart = range.start;
                    var rangeEnd = range.end;

                    this.tree.remove(range);

                    if (rangeStart < start) {
                        if (rangeValue !== value) {
                            this.insert(rangeStart, start - 1, rangeValue);
                        } else {
                            start = rangeStart;
                        }
                    }

                    if (rangeEnd > end) {
                        if (rangeValue !== value) {
                            this.insert(end + 1, rangeEnd, rangeValue);
                        } else {
                            end = rangeEnd;
                        }
                    }
                }
            }

            this.insert(start, end, value);
        },

        expandedValues: function(start, end) {
            var ranges = this.intersecting(start, end);
            var result = [];

            var rangeIndex = 0;

            for (var i = start; i <= end; i++) {
                if (ranges[rangeIndex].end < i) {
                    rangeIndex ++;
                }

                result.push({ index: i - start, value: ranges[rangeIndex].value });
            }

            return result;
        },

        sortedIndices: function(start, end, valueComparer, indices) {
            var result = this.expandedValues(start, end);

            var comparer = function(a, b) {
                if (a.value === b.value) {
                    return a.index - b.index;
                }

                return valueComparer(a.value, b.value);
            };

            if (indices) {
                comparer = function(a, b) {
                    var x = indices[a.index];
                    var y = indices[b.index];

                    if (x.value === y.value) {
                        return valueComparer(a.value, b.value);
                    }

                    return a.index - b.index;
                };
            }

            result.sort(comparer);

            return result;
        },

        sort: function(start, end, indices) {
            if (this.intersecting(start, end).length === 1) {
                return;
            }

            var values = this.expandedValues(start, end);

            for (var i = 0, len = indices.length; i < len; i++) {
                this.value(i + start, i + start, values[indices[i].index].value);
            }
        },

        copy: function(sourceStart, sourceEnd, targetStart) {
            var values = this.intersecting(sourceStart, sourceEnd);

            var start = targetStart;
            var end;

            for (var i = 0, len = values.length; i < len; i++) {
                var rangeStart = values[i].start;

                if (rangeStart < sourceStart) {
                    rangeStart = sourceStart;
                }

                var rangeEnd = values[i].end;

                if (rangeEnd > sourceEnd) {
                    rangeEnd = sourceEnd;
                }

                end = start + (rangeEnd - rangeStart);

                this.value(start, end, values[i].value);

                start = ++end;
            }
        },

        iterator: function(start, end) {
            return new Iterator(start, end, this.intersecting(start, end));
        },

        getState: function() {
            return this.tree.clone();
        },

        setState: function(state) {
            this.tree = state.clone();
        },

        toJSON: function() {
            return this.values();
        },

        fromJSON: function(values) {
            values.forEach(function(v){
                this.value(v.start, v.end, v.value);
            }, this);
        }
    });

    var Iterator = kendo.Class.extend({
        init: function(start, end, ranges) {
            this.start = start;
            this.end = end;
            this.index = 0;
            this.ranges = ranges;
        },

        unique: function() {
            return this.ranges.map(function(range) {
                return range.value;
            });
        },

        at: function(index) {
            while (this.ranges[this.index] && this.ranges[this.index].end < index) {
                this.index ++;
            }

            return this.ranges[this.index] && this.ranges[this.index].value;
        },

        forEach: function(callback) {
            for (var i = this.start; i <= this.end; i++) {
                callback(this.at(i), i);
            }

            this.index = 0;
        }
    });

    var SparseRangeList = RangeList.extend({
        init: function(start, end, value) {
            this.tree = new RangeTree();
            this.range = new Range(start, end, value);
        },

        intersecting: function(start, end) {
            var ranges = this.tree.intersecting(start, end);
            var result = [];
            var range;

            if (!ranges.length) {
                return [this.range];
            }

            for (var i = 0, len = ranges.length; i < len; i++) {
                range = ranges[i];
                if (range.start > start) {
                    result.push(new Range(start, range.start - 1, this.range.value));
                }

                result.push(range);
                start = range.end + 1;
            }

            if (range.end < end) {
                result.push(new Range(range.end + 1, end, this.range.value));
            }

            return result;
        },

        insert: function(start, end, value) {
            if (value !== this.range.value) {
                this.tree.insert(new Range(start, end, value));
            }
        },

        lastRangeStart: function() {
            var node = this.tree.root;

            if (node === NilNode) {
                return this.range.start;
            }

            while(node.right !== NilNode) {
                node = node.right;
            }

            return node.value.end + 1;
        }
    });


    kendo.spreadsheet.RangeTree = RangeTree;
    kendo.spreadsheet.RangeList = RangeList;
    kendo.spreadsheet.SparseRangeList = SparseRangeList;
    kendo.spreadsheet.ValueRange = Range;
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/propertybag',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var Property = kendo.Class.extend({
        init: function(list) {
            this.list = list;
        },

        get: function(index) {
            return this.parse(this.list.value(index, index));
        },

        set: function(start, end, value) {
            if (value === undefined) {
                value = end;
                end = start;
            }

            this.list.value(start, end, value);
        },

        parse: function(value) {
            return value;
        },

        copy: function(start, end, dst) {
            this.list.copy(start, end, dst);
        },

        iterator: function(start, end) {
            return this.list.iterator(start, end);
        }
    });

    var JsonProperty = Property.extend({
        set: function(start, end, value) {
            this.list.value(start, end, JSON.stringify(value));
        },

        parse: function(value) {
            return JSON.parse(value);
        }
    });

    var ValueProperty = Property.extend({
        init: function(values, formats) {
            Property.prototype.init.call(this, values);
            this.formats = formats;
        },

        set: function(start, end, value) {
            if (value instanceof Date) {
                value = kendo.spreadsheet.dateToNumber(value);
                if (!this.formats.value(start,end)) {
                    this.formats.value(start, end, toExcelFormat(kendo.culture().calendar.patterns.d));
                }
            } else if (typeof value == "number") {
                value = kendo.spreadsheet.calc.runtime.limitPrecision(value);
            }

            this.list.value(start, end, value);
        }
    });

    function toExcelFormat(format) {
        return format.replace(/M/g, "m").replace(/'/g, '"').replace(/tt/, "am/pm");
    }

    kendo.spreadsheet.PropertyBag = kendo.Class.extend({
        specs: [
            { property: Property, name: "format", value: null, sortable: true, serializable: true },
            { property: ValueProperty, name: "value", value: null, sortable: true, serializable: true, depends: "format" },
            { property: Property, name: "formula", value: null, sortable: true, serializable: true },
            { property: Property, name: "background", value: null, sortable: true, serializable: true },
            { property: JsonProperty, name: "vBorders", value: null, sortable: false, serializable: false },
            { property: JsonProperty, name: "hBorders", value: null, sortable: false, serializable: false },
            { property: Property, name: "color", value: null, sortable: true, serializable: true },
            { property: Property, name: "fontFamily", value: null, sortable: true, serializable: true },
            { property: Property, name: "underline", value: null, sortable: true, serializable: true },
            { property: Property, name: "fontSize", value: null, sortable: true, serializable: true },
            { property: Property, name: "italic", value: null, sortable: true, serializable: true },
            { property: Property, name: "bold", value: null, sortable: true, serializable: true },
            { property: Property, name: "textAlign", value: null, sortable: true, serializable: true },
            { property: Property, name: "indent", value: null, sortable: true, serializable: true },
            { property: Property, name: "verticalAlign", value: null, sortable: true, serializable: true },
            { property: Property, name: "wrap", value: null, sortable: true, serializable: true },
            { property: Property, name: "validation", value: null, sortable: false, serializable: true },
            { property: Property, name: "enable", value: null, sortable: false, serializable: true },
            { property: Property, name: "link", value: null, sortable: true, serializable: true },
            { property: Property, name: "editor", value: null, sortable: true, serializable: true },
            { property: Property, name: "comment", value: null, sortable: true, serializable: true },
            { property: Property, name: "html", value: null, sortable: true, serializable: true }
        ],

        init: function(rowCount, columnCount, defaultValues) {
            defaultValues = defaultValues || {};
            var cellCount = rowCount * columnCount - 1;

            this.rowCount = rowCount;
            this.columnCount = columnCount;
            this.cellCount = cellCount;
            this.properties = {};
            this.lists = {};

            this.specs.forEach(function(spec) {
                var name = spec.name;
                var value = defaultValues[name];
                if (value === undefined) {
                    value = spec.value;
                }
                this.lists[name] = new kendo.spreadsheet.SparseRangeList(0, cellCount, value);
                var prop = this.properties[name] = new spec.property(this.lists[name], this.lists[spec.depends]);
                prop.spec = spec;
            }, this);

            // XXX: this is a hack but I have no better ideas at this
            // point.  The getState() method in a SparseRangeList
            // clones the tree (which just copies values over), but
            // formulas are objects maintaining complex state.
            // https://github.com/telerik/kendo-ui-core/issues/2816
            this.lists.formula.tree.clone = cloneFormulaTree;
            this.lists.validation.tree.clone = cloneFormulaTree;
        },

        _resize: function(new_rows, new_cols) {
            var self = this;
            var old_rows = self.rowCount;
            var cell_count = new_rows * new_cols - 1;
            function scaleIndex(index) {
                var col = index / old_rows | 0;
                var row = index % old_rows;
                return col * new_rows + row;
            }
            function scaleNode(node) {
                // node is a ValueRange from rangelist.js
                // start/end are rowCount * col + row
                node.start = scaleIndex(node.start);
                node.end = scaleIndex(node.end);
            }
            Object.keys(self.lists).forEach(function(name) {
                var list = self.lists[name];
                if (new_rows != old_rows) {
                    list.forEach(scaleNode);
                }
                list.range.end = cell_count;
            });
            self.rowCount = new_rows;
            self.columnCount = new_cols;
            self.cellCount = cell_count;
        },

        getState: function() {
            var state = {};

            this.specs.forEach(function(spec) {
               state[spec.name] = this.lists[spec.name].getState();
            }, this);

            return state;
        },

        setState: function(state) {
            this.specs.forEach(function(spec) {
                this.lists[spec.name].setState(state[spec.name]);
            }, this);
        },

        get: function(name, index) {
            if (index === undefined) {
                return this.lists[name];
            }

            switch (name) {
              case "borderRight":
                index += this.rowCount;
                /* falls through */
              case "borderLeft":
                name = "vBorders";
                break;

              case "borderBottom":
                index++;
                /* falls through */
              case "borderTop":
                name = "hBorders";
                break;
            }
            return index > this.cellCount ? null : this.properties[name].get(index);
        },

        set: function(name, start, end, value) {
            switch (name) {
              case "borderRight":
                start += this.rowCount;
                end += this.rowCount;
                /* falls through */
              case "borderLeft":
                name = "vBorders";
                break;

              case "borderBottom":
                start++;
                end++;
                /* falls through */
              case "borderTop":
                name = "hBorders";
                break;
            }
            if (start <= end && end <= this.cellCount) {
                this.properties[name].set(start, end, value);
            }
        },

        fromJSON: function(index, value) {
            for (var si = 0; si < this.specs.length; si++) {
                var spec = this.specs[si];

                if (spec.serializable) {
                    if (value[spec.name] !== undefined) {
                        this.set(spec.name, index, index, value[spec.name], false);
                    }
                }
            }

            [ "borderLeft", "borderRight", "borderTop", "borderBottom" ].forEach(function(b){
                if (value[b] !== undefined) {
                    this.set(b, index, index, value[b]);
                }
            }, this);
        },

        copy: function(sourceStart, sourceEnd, targetStart) {
            this.specs.forEach(function(spec) {
                this.properties[spec.name].copy(sourceStart, sourceEnd, targetStart);
            }, this);
        },

        iterator: function(name, start, end) {
            var prop = this.properties[name];
            var iter = prop.iterator(start, end), at = iter.at;
            var cellCount = this.cellCount;
            iter.at = function(index) {
                return index > cellCount ? null : prop.parse(at.call(iter, index));
            };
            iter.name = name;
            iter.value = prop.spec.value;
            return iter;
        },

        sortable: function() {
            return this.specs.filter(function(spec) { return spec.sortable; })
                .map(function(spec) {
                    return this.lists[spec.name];
                }, this);
        },

        iterators: function(start, end) {
            return this.specs.reduce(function(ret, spec) {
                if (spec.serializable) {
                    ret.push(this.iterator(spec.name, start, end));
                }
                return ret;
            }.bind(this), []);
        },

        forEach: function(start, end, callback) {
            var iterators = this.iterators(start, end);
            var hBorders = this.iterator("hBorders", start, end + 1);
            var leftBorders = this.iterator("vBorders", start, end);
            var rightBorders = this.iterator("vBorders", start + this.rowCount, end + this.rowCount);
            var values, index;

            function addBorder(name, iterator, index) {
                var val = iterator.at(index);
                if (val !== iterator.value) {
                    values[name] = val;
                }
            }

            for (index = start; index <= end; index++) {
                values = {};

                for (var i = 0; i < iterators.length; i++) {
                    var iterator = iterators[i];
                    var value = iterator.at(index);

                    if (value !== iterator.value) {
                        values[iterator.name] = value;
                    }
                }

                addBorder("borderLeft", leftBorders, index);
                addBorder("borderRight", rightBorders, index + this.rowCount);
                addBorder("borderTop", hBorders, index);
                if ((index + 1) % this.rowCount) {
                    addBorder("borderBottom", hBorders, index + 1);
                }

                callback(values);
            }
        },

        forEachProperty: function(callback) {
            for (var name in this.properties) {
                callback(this.properties[name]);
            }
        }
    });

    function cloneFormulaValue(x) {
        x = x.clone();
        x.value = x.value.deepClone(); // x.value is Formula or Validation
        return x;
    }

    function cloneFormulaTree() {
        var tree = this.map(cloneFormulaValue);
        tree.clone = cloneFormulaTree; // because it's a new RangeTree now
        return tree;
    }

    kendo.spreadsheet.ALL_PROPERTIES = kendo.spreadsheet.PropertyBag.prototype.specs.reduce(function(a, spec) {
        if (spec.serializable) {
            a.push(spec.name);
        }
        return a;
    }, [ "borderTop", "borderRight", "borderBottom", "borderLeft" ]);

})(window.kendo);

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

// -*- fill-column: 100 -*-

(function(f, define){
    define('spreadsheet/references',["../kendo.core"], f);
})(function(){
    // WARNING: removing the following jshint declaration and turning
    // == into === to make JSHint happy will break functionality.
    /* jshint eqnull:true, laxbreak:true */

    "use strict";

    var spreadsheet = kendo.spreadsheet;
    var Class = kendo.Class;

    function columnName(colIndex) {
        var letter = Math.floor(colIndex / 26) - 1;
        return (letter >= 0 ? columnName(letter) : "") + String.fromCharCode(65 + (colIndex % 26));
    }

    function displaySheet(sheet) {
        if (/^[a-z_][a-z0-9_]*$/i.test(sheet)) {
            return sheet;
        }
        return "'" + sheet.replace(/\x27/g, "\\'") + "'";
    }

    function displayRef(sheet, row, col, rel) {
        var aa = "";

        ++row;

        if (!isFinite(row)) {
            row = "";
        }
        else if (rel != null && !(rel & 2)) {
            row = "$" + row;
        }

        if (!isFinite(col)) {
            col = "";
        }
        else {
            aa = columnName(col);
            if (rel != null && !(rel & 1)) {
                aa = "$" + aa;
            }
        }

        if (sheet) {
            return displaySheet(sheet) + "!" + aa + row;
        } else {
            return aa + row;
        }
    }

    /* -----[ References ]----- */

    var Ref = Class.extend({
        type: "ref",
        sheet: "",
        clone: function() {
            return this;
        },
        hasSheet: function() {
            return this._hasSheet;
        },
        simplify: function() {
            return this;
        },
        setSheet: function(sheet, hasSheet) {
            this.sheet = sheet;
            if (hasSheet != null) {
                this._hasSheet = hasSheet;
            }
            return this;
        },
        absolute: function(){
            return this;
        },
        relative: function(){
            return this;
        },
        adjust: function(){
            return this;
        },
        toString: function() {
            return this.relative(0, 0, 3, 3).print(0, 0);
        },
        forEach: function(callback, obj) {
            callback.call(obj, this);
        },
        map: function(callback, obj) {
            return callback.call(obj, this);
        },
        intersects: function(ref) {
            return this.intersect(ref) !== NULL;
        },
        isCell: function() {
            return false;
        },
        toRow: function() {
            return this;
        },
        toColumn: function() {
            return this;
        },

        // UnionRef overrides these, to access its subranges.
        first: function() {
            return this;
        },
        lastRange: function() {
            return this;
        },
        size: function() {
            return 1;
        },
        rangeAt: function() {
            return this;
        },
        nextRangeIndex: function() {
            return 0;
        },
        previousRangeIndex: function() {
            return 0;
        },
        eq: function(reference) {
            var r1 = this;
            var r2 = reference;

            if (r1 === NULL || r2 === NULL) {
                return r1 === r2;
            }

            // make positions consistent
            if ((r2 instanceof CellRef) || (r2 instanceof RangeRef && !(r1 instanceof CellRef))) {
               r1 = reference;
               r2 = this;
            }

            if (r1 instanceof CellRef) { // cell eq *
                r2 = r2.simplify();
                return r2 instanceof CellRef && r1.row == r2.row && r1.col == r2.col && r1.sheet == r2.sheet;
            }
            else if (r1 instanceof RangeRef) { // range eq range/union
                if (r2 instanceof RangeRef) {
                    return r2.topLeft.eq(r1.topLeft) && r2.bottomRight.eq(r1.bottomRight);
                }
                if (r2 instanceof UnionRef) {
                    return r2.single() && r1.eq(r2.refs[0]);
                }
            }
            else if (r1 instanceof UnionRef && r2 instanceof UnionRef) { // union eq union
                var refs1 = r1.refs;
                var refs2 = r2.refs;
                if (refs1.length != refs2.length) {
                   return false;
                }

                for (var i = 0, len = refs1.length; i < len; i++) {
                    if (!refs1[i].eq(refs2[i])) {
                        return false;
                    }
                }

                return true;
            }

            return r1 === r2;   // XXX: possibly NameRef when we'll support it.
        },

        concat: function(ref) {
            return new UnionRef([this, ref]);
        },

        replaceAt: function(index, ref) {
            return ref;
        },

        forEachColumnIndex: function(callback) {
            this.forEachAxisIndex('col', callback);
        },

        forEachRowIndex: function(callback) {
            this.forEachAxisIndex('row', callback);
        },

        forEachAxisIndex: function(axis, callback) {
            var sorted = [];

            var method = axis === 'row' ? 'forEachRow' : 'forEachColumn';

            this[method](function(ref) {
                var index = ref.first()[axis];
                if (sorted.indexOf(index) === -1) {
                    sorted.push(index);
                }
            });

            sorted.sort(function(a,b) {
                return a > b ? 1 : (a < b ? -1 : 0);
            }).forEach(callback);
        },

        valid: function() {
            return false;
        },

        renameSheet: function(oldSheetName, newSheetName) {
            if (this.sheet && this.sheet.toLowerCase() == oldSheetName.toLowerCase()) {
                this.sheet = newSheetName;
                return true;
            }
        }
    });

    Ref.display = displayRef;

    /* -----[ Null reference ]----- */

    var NULL = new (Ref.extend({
        init: function NullRef(){},
        print: function() {
            return "#NULL!";
        },
        eq: function(ref) {
            return ref === this;
        },
        forEach: function() {}
    }))();

    /* -----[ Name reference ]----- */

    var NameRef = Ref.extend({
        ref: "name",
        init: function NameRef(name){
            this.name = name;
        },
        clone: function() {
            return new NameRef(this.name)
                .setSheet(this.sheet, this.hasSheet());
        },
        print: function() {
            var ret = displaySheet(this.name);
            if (this.hasSheet()) {
                ret = displaySheet(this.sheet) + "!" + ret;
            }
            return ret;
        }
    });

    /* -----[ Cell reference ]----- */

    var CellRef = Ref.extend({
        ref: "cell",
        init: function CellRef(row, col, rel) {
            this.row = row;
            this.col = col;
            this.rel = rel || 0;
        },
        clone: function() {
            return new CellRef(this.row, this.col, this.rel)
                .setSheet(this.sheet, this.hasSheet());
        },
        intersect: function(ref) {
            if (ref instanceof CellRef) {
                if (this.eq(ref)) {
                    return this;
                } else {
                    return NULL;
                }
            }
            return ref.intersect(this);
        },
        print: function(trow, tcol, mod) {
            var col = this.col, row = this.row, rel = this.rel, abs;
            if (trow == null && rel) {
                var sheet = this.hasSheet() ? displaySheet(this.sheet) + "!" : "";
                if (isFinite(col)) {
                    col = rel & 1 ? ("C[" + col + "]") : ("C" + (col + 1));
                } else {
                    col = "";
                }
                if (isFinite(row)) {
                    row = rel & 2 ? ("R[" + row + "]") : ("R" + (row + 1));
                } else {
                    row = "";
                }
                return sheet + row + col;
            } else {
                abs = this.absolute(trow, tcol);
                if (mod) {
                    // Hacks: see the big comment below in `absolute()`
                    row = abs.row % 0x100000;
                    col = abs.col % 0x4000;
                    if (row < 0) {
                        row += 0x100000;
                    }
                    if (col < 0) {
                        col += 0x4000;
                    }
                    return displayRef(this._hasSheet && this.sheet, row, col, rel);
                }
                return abs.valid() ? displayRef(this._hasSheet && this.sheet, abs.row, abs.col, rel) : "#REF!";
            }
        },
        absolute: function(arow, acol) {
            var ret = this.clone();
            if (ret.rel & 3 === 0) {
                return ret;    // already absolute
            }

            // Hacks: we make coordinates modulo 0x4000 (max col) and 0x100000 (max row).  This
            // fixes importing relative references in definedName-s from Excel.  Example in
            // Excel: select cell E3, open the Name Manager (in Formula tab) and define name
            // TEST with value Sheet1!A1:C3.  The serialization of this name in XLSX is:
            //
            //     <definedName name="TEST">Sheet1!XFA1048575:XFC1</definedName>
            //
            // This is insane, of course, but oh well.  Excel.  If you type in E3 =SUM(TEST) it
            // works (it actually sums the cells), but if you type =SUM(Sheet1!XFA1048575:XFC1)
            // you get back zero.  Let's see why SUM(TEST) works:
            //
            //     XFA1048575:XFC1                   E3
            //     (zero-based indexes below)
            //
            //     R[1048574]C[16380]:R[0]C[16382] + R2C4 = R1048576C16384:R2C16386
            //                                            % (0x100000, 0x4000)
            //                                            = R0C0:R2C2 (== A1:C3)
            //
            // So XFA1048575:XFC1 is relocated to E3 at evaluation time, and because we take
            // rows modulo 0x100000 and cols modulo 0x4000, we get back the correct range.
            //
            // IMO Excel should disallow A1-style relative references in name definitions
            // (simply because the meaning of the A1:C3 you type in Name Manager depends on the
            // active cell) and only allow R1C1 notation  that's unambiguous.  But it doesn't.
            // Moreover, R1C1-style refs in XLSX are explicitly forbidden by the spec, and the
            // hacks above are not documented  how else could we have fun implementing a XLSX
            // reader?
            if (ret.rel & 1) {
                // relative col, add anchor
                ret.col = (ret.col + acol) % 0x4000;
            }
            if (ret.rel & 2) {
                // relative row, add anchor
                ret.row = (ret.row + arow) % 0x100000;
            }

            ret.rel = 0;
            return ret;
        },
        toRangeRef: function() {
            return new RangeRef(this, this);
        },
        relative: function(arow, acol, rel) {
            if (rel == null) {
                rel = this.rel;
            }
            var row = rel & 2 ? this.row - arow : this.row;
            var col = rel & 1 ? this.col - acol : this.col;
            return new CellRef(row, col, rel)
                .setSheet(this.sheet, this.hasSheet());
        },
        height: function() {
            return 1;
        },
        width: function() {
            return 1;
        },
        toString: function() {
            return displayRef(null, this.row, this.col, 3);
        },
        isCell: function() {
            return true;
        },
        leftColumn: function() {
            return this;
        },
        rightColumn: function() {
            return this;
        },
        topRow: function() {
            return this;
        },
        bottomRow: function() {
            return this;
        },
        forEachRow: function(callback) {
            callback(this.toRangeRef());
        },
        forEachColumn: function(callback) {
            callback(this.toRangeRef());
        },
        adjust: function(row, col, trow, tcol, forRow, start, delta) {
            var ref = this.absolute(row, col);
            if (forRow) {
                if (ref.row >= start) {
                    if (delta < 0 && ref.row < start - delta) {
                        return NULL;
                    }
                    ref.row += delta;
                }
            } else {
                if (ref.col >= start) {
                    if (delta < 0 && ref.col < start - delta) {
                        return NULL;
                    }
                    ref.col += delta;
                }
            }
            if (trow != null && tcol != null) {
                ref = ref.relative(trow, tcol, this.rel);
            }
            return ref;
        },
        valid: function() {
            if (this.rel) {
                throw new Error("valid() called on relative reference");
            }
            var col = this.col, row = this.row;
            return !((isFinite(col) && col < 0) || (isFinite(row) && row < 0));
        }
    });

    /* -----[ Range reference ]----- */

    var RangeRef = Ref.extend({
        ref: "range",
        init: function RangeRef(tl, br) {
            if (tl._hasSheet && br._hasSheet && tl.sheet.toLowerCase() != br.sheet.toLowerCase()) {
                // "3D" reference
                this.endSheet = br.sheet;
            }
            // we want to drop any sheet information from the cells here.
            this.topLeft = new CellRef(tl.row, tl.col, tl.rel);
            this.bottomRight = new CellRef(br.row, br.col, br.rel);
            this.normalize();
        },
        clone: function() {
            return new RangeRef(this.topLeft.clone(), this.bottomRight.clone()).setSheet(this.sheet, this.hasSheet());
        },
        _containsRange: function(range) {
            return this._containsCell(range.topLeft)
                && this._containsCell(range.bottomRight);
        },
        _containsCell: function(cell) {
            return cell.sheet == this.sheet
                && cell.row >= this.topLeft.row
                && cell.col >= this.topLeft.col
                && cell.row <= this.bottomRight.row
                && cell.col <= this.bottomRight.col;
        },
        contains: function(ref) {
            if (ref instanceof Array) {
                var that = this;

                return ref.some(function(_ref) { return that.contains(_ref); });
            }
            if (ref instanceof CellRef) {
                return this._containsCell(ref);
            }
            if (ref instanceof RangeRef) {
                return this._containsRange(ref);
            }
            return false;
        },
        _intersectRange: function(ref) {
            if (this.sheet != ref.sheet) {
                return NULL;
            }
            var a_left    = this.topLeft.col;
            var a_top     = this.topLeft.row;
            var a_right   = this.bottomRight.col;
            var a_bottom  = this.bottomRight.row;
            var b_left    = ref.topLeft.col;
            var b_top     = ref.topLeft.row;
            var b_right   = ref.bottomRight.col;
            var b_bottom  = ref.bottomRight.row;
            if (a_left <= b_right &&
                b_left <= a_right &&
                a_top <= b_bottom &&
                b_top <= a_bottom)
            {
                return new RangeRef(
                    // topLeft
                    new CellRef(Math.max(a_top, b_top),
                                Math.max(a_left, b_left)),
                    // bottomRight
                    new CellRef(Math.min(a_bottom, b_bottom),
                                Math.min(a_right, b_right))
                ).setSheet(this.sheet, this.hasSheet());
            } else {
                return NULL;
            }
        },
        intersect: function(ref) {
            if (ref instanceof CellRef) {
                return this._containsCell(ref) ? ref : NULL;
            }
            if (ref instanceof RangeRef) {
                return this._intersectRange(ref).simplify();
            }
            if (ref instanceof UnionRef) {
                return ref.intersect(this);
            }
            return NULL;        // can't handle NameRef-s here.
        },
        simplify: function() {
            if (this.isCell()) {
                return new CellRef(
                    this.topLeft.row,
                    this.topLeft.col,
                    this.topLeft.rel
                ).setSheet(this.sheet, this.hasSheet());
            }
            return this;
        },
        normalize: function() {
            var a = this.topLeft, b = this.bottomRight;
            var r1 = a.row, c1 = a.col, r2 = b.row, c2 = b.col;
            var rr1 = a.rel & 2, rc1 = a.rel & 1;
            var rr2 = b.rel & 2, rc2 = b.rel & 1;
            var tmp, changes = false;
            // do not attempt to normalize unless relativeness of rows and cols are the same.
            // https://github.com/telerik/kendo-ui-core/issues/4278
            if (rr1 === rr2 && rc1 === rc2) {
                if (r1 > r2) {
                    changes = true;
                    tmp = r1; r1 = r2; r2 = tmp;
                    tmp = rr1; rr1 = rr2; rr2 = tmp;
                }
                if (c1 > c2) {
                    changes = true;
                    tmp = c1; c1 = c2; c2 = tmp;
                    tmp = rc1; rc1 = rc2; rc2 = tmp;
                }
                if (changes) {
                    this.topLeft = new CellRef(r1, c1, rc1 | rr1);
                    this.bottomRight = new CellRef(r2, c2, rc2 | rr2);
                }
            }
            return this;
        },
        print: function(trow, tcol, mod) {
            if (mod || this.absolute(trow, tcol).valid()) {
                var ret = this.topLeft.print(trow, tcol, mod)
                    + ":"
                    + this.bottomRight.print(trow, tcol, mod);
                if (this.hasSheet()) {
                    ret = displaySheet(this.sheet)
                        + (this.endSheet ? ":" + displaySheet(this.endSheet) : "")
                        + "!" + ret;
                }
                return ret;
            }
            return "#REF!";
        },
        absolute: function(arow, acol) {
            return new RangeRef(
                this.topLeft.absolute(arow, acol),
                this.bottomRight.absolute(arow, acol)
            ).setSheet(this.sheet, this.hasSheet());
        },
        relative: function(arow, acol, relTL, relBR) {
            if (relBR == null) {
                relBR = relTL;
            }
            return new RangeRef(
                this.topLeft.relative(arow, acol, relTL),
                this.bottomRight.relative(arow, acol, relBR)
            ).setSheet(this.sheet, this.hasSheet());
        },
        height: function() {
            if (this.topLeft.rel != this.bottomRight.rel) {
                throw new Error("Mixed relative/absolute references");
            }
            return this.bottomRight.row - this.topLeft.row + 1;
        },
        width: function() {
            if (this.topLeft.rel != this.bottomRight.rel) {
                throw new Error("Mixed relative/absolute references");
            }
            return this.bottomRight.col - this.topLeft.col + 1;
        },
        collapse: function() {
            return this.topLeft.toRangeRef();
        },
        leftColumn: function() {
            return new RangeRef(this.topLeft, new CellRef(this.bottomRight.row, this.topLeft.col));
        },
        rightColumn: function() {
            return new RangeRef(new CellRef(this.topLeft.row, this.bottomRight.col), this.bottomRight);
        },
        topRow: function() {
            return new RangeRef(this.topLeft, new CellRef(this.topLeft.row, this.bottomRight.col));
        },
        bottomRow: function() {
            return new RangeRef(new CellRef(this.bottomRight.row, this.topLeft.col), this.bottomRight);
        },
        toRangeRef: function() {
            return this;
        },
        toRow: function(row) {
            row += Math.max(0, this.topLeft.row);
            return new RangeRef(
                new CellRef(row, this.topLeft.col),
                new CellRef(row, this.bottomRight.col)
            ).setSheet(this.sheet, this.hasSheet());
        },
        toColumn: function(col) {
            col += Math.max(0, this.topLeft.col);
            return new RangeRef(
                new CellRef(this.topLeft.row, col),
                new CellRef(this.bottomRight.row, col)
            ).setSheet(this.sheet, this.hasSheet());
        },
        toCell: function(row, col) {
            row += Math.max(0, this.topLeft.row);
            col += Math.max(0, this.topLeft.col);
            return new CellRef(row, col, 0)
                .setSheet(this.sheet, this.hasSheet());
        },
        forEachRow: function(callback) {
            var startRow = this.topLeft.row;
            var endRow = this.bottomRight.row;
            var startCol = this.topLeft.col;
            var endCol = this.bottomRight.col;

            for (var i = startRow; i <= endRow; i++) {
                callback(new RangeRef(
                    new CellRef(i, startCol),
                    new CellRef(i, endCol)
                ));
            }
        },
        forEachColumn: function(callback) {
            var startRow = this.topLeft.row;
            var endRow = this.bottomRight.row;
            var startCol = this.topLeft.col;
            var endCol = this.bottomRight.col;

            for (var i = startCol; i <= endCol; i++) {
                callback(new RangeRef(
                    new CellRef(startRow, i),
                    new CellRef(endRow, i)
                ));
            }
        },
        intersecting: function(refs) {
            return refs.filter(function(ref) {
                return ref.toRangeRef().intersects(this);
            }, this);
        },

        union: function(refs, callback) {
            var intersecting = this.intersecting(refs);

            var topLeftRow = this.topLeft.row;
            var topLeftCol = this.topLeft.col;
            var bottomRightRow = this.bottomRight.row;
            var bottomRightCol = this.bottomRight.col;

            var modified = false;

            intersecting.forEach(function(ref) {
                ref = ref.toRangeRef();
                if (ref.topLeft.row < topLeftRow) {
                    modified = true;
                    topLeftRow = ref.topLeft.row;
                }

                if (ref.topLeft.col < topLeftCol) {
                    modified = true;
                    topLeftCol = ref.topLeft.col;
                }

                if (ref.bottomRight.row > bottomRightRow) {
                    modified = true;
                    bottomRightRow = ref.bottomRight.row;
                }

                if (ref.bottomRight.col > bottomRightCol) {
                    modified = true;
                    bottomRightCol = ref.bottomRight.col;
                }

                if (callback) {
                    callback(ref);
                }
            });

            var result = new RangeRef(
                new CellRef(topLeftRow, topLeftCol),
                new CellRef(bottomRightRow, bottomRightCol)
            );

            if (modified) {
                return result.union(refs, callback);
            } else {
                return result;
            }
        },
        resize: function(options) {
            var limit = Math.max.bind(Math, 0);
            function num(value) { return value || 0; }

            var top = this.topLeft.row + num(options.top);
            var left = this.topLeft.col + num(options.left);
            var bottom = this.bottomRight.row + num(options.bottom);
            var right = this.bottomRight.col + num(options.right);

            if (left < 0 && right < 0 || top < 0 && bottom < 0) {
                return NULL;
            } else if (top <= bottom && left <= right) {
                return new RangeRef(new CellRef(limit(top), limit(left)),
                                    new CellRef(limit(bottom), limit(right)));
            } else {
                return NULL;
            }
        },
        move: function(rows, cols) {
            return new RangeRef(
                new CellRef(this.topLeft.row + rows,
                            this.topLeft.col + cols),
                new CellRef(this.bottomRight.row + rows,
                            this.bottomRight.col + cols)
            );
        },
        first: function() {
            return this.topLeft.clone().setSheet(this.sheet, this.hasSheet());
        },
        isCell: function() {
            return !this.endSheet && this.topLeft.eq(this.bottomRight);
        },
        toString: function() {
            return this.topLeft + ":" + this.bottomRight;
        },
        adjust: function(row, col, trow, tcol, forRow, start, delta) {
            var tl = this.topLeft.adjust(row, col, trow, tcol, forRow, start, delta);
            var tr = this.bottomRight.adjust(row, col, trow, tcol, forRow, start, delta);
            if (tl === NULL && tr === NULL) {
                return NULL;
            }
            if (tl === NULL) {
                tl = this.topLeft.absolute(row, col);
                if (forRow) {
                    tl.row = start;
                } else {
                    tl.col = start;
                }
                if (trow != null && tcol != null) {
                    tl = tl.relative(trow, tcol, this.topLeft.rel);
                }
            }
            else if (tr === NULL) {
                tr = this.bottomRight.absolute(row, col);
                if (forRow) {
                    tr.row = start - 1;
                } else {
                    tr.col = start - 1;
                }
                if (trow != null && tcol != null) {
                    tr = tr.relative(trow, tcol, this.bottomRight.rel);
                }
            }
            return new RangeRef(tl, tr)
                .setSheet(this.sheet, this.hasSheet())
                .simplify();
        },
        valid: function() {
            return this.topLeft.valid() && this.bottomRight.valid();
        }
    });

    /* -----[ Union reference ]----- */

    var UnionRef = Ref.extend({
        init: function UnionRef(refs){
            this.refs = refs;
            this.length = refs.length;
        },
        clone: function() {
            return new UnionRef(this.refs.slice());
        },
        intersect: function(ref) {
            var a = [];
            for (var i = 0; i < this.length; ++i) {
                var x = ref.intersect(this.refs[i]);
                if (x !== NULL) {
                    a.push(x);
                }
            }
            if (a.length > 0) {
                return new UnionRef(a).simplify();
            }
            return NULL;
        },
        simplify: function() {
            var u = new UnionRef(this.refs.reduce(function(a, ref){
                ref = ref.simplify();
                if (ref !== NULL) {
                    a.push(ref);
                }
                return a;
            }, []));
            if (u.empty()) {
                return NULL;
            }
            if (u.single()) {
                return u.refs[0];
            }
            return u;
        },
        absolute: function(arow, acol) {
            return new UnionRef(this.refs.map(function(ref){
                return ref.absolute(arow, acol);
            }));
        },
        forEach: function(callback, obj) {
            this.refs.forEach(function(ref){
                if (ref instanceof UnionRef) {
                    ref.forEach(callback, obj);
                } else {
                    callback.call(obj, ref);
                }
            }, obj);
        },
        toRangeRef: function() {
            return this.refs[0].toRangeRef();
        },
        contains: function(theRef) {
            return this.refs.some(function(ref) { return ref.contains(theRef); });
        },
        map: function(callback, obj) {
            var refs = [];
            this.forEach(function(ref){
                refs.push(callback.call(obj, ref));
            });
            return new UnionRef(refs);
        },
        first: function() {
            return this.refs[0].first();
        },
        lastRange: function() {
            return this.refs[this.length - 1];
        },
        size: function() {
            return this.length;
        },
        single: function() {
            return this.length == 1;
        },
        empty: function() {
            return this.length === 0;
        },
        isCell: function() {
            return this.single() && this.refs[0].isCell();
        },
        rangeAt: function(index) {
            return this.refs[index];
        },
        nextRangeIndex: function(index) {
            if (index === this.length - 1) {
                return 0;
            } else {
                return index + 1;
            }
        },
        previousRangeIndex: function(index) {
            if (index === 0) {
                return this.length - 1;
            } else {
                return index - 1;
            }
        },
        concat: function(ref) {
            return new UnionRef(this.refs.concat([ref]));
        },
        print: function(row, col, mod) {
            return this.refs.map(function(ref) { return ref.print(row, col, mod); }).join(",");
        },

        replaceAt: function(index, ref) {
            var newRefs = this.refs.slice();
            newRefs.splice(index, 1, ref);
            return new UnionRef(newRefs);
        },

        leftColumn: function() {
            return this.map(function(ref) {
                return ref.leftColumn();
            });
        },
        rightColumn: function() {
            return this.map(function(ref) {
                return ref.rightColumn();
            });
        },
        topRow: function() {
            return this.map(function(ref) {
                return ref.topRow();
            });
        },
        bottomRow: function() {
            return this.map(function(ref) {
                return ref.bottomRow();
            });
        },
        forEachRow: function(callback) {
            this.forEach(function(ref) {
                ref.forEachRow(callback);
            });
        },
        forEachColumn: function(callback) {
            this.forEach(function(ref) {
                ref.forEachColumn(callback);
            });
        },
        adjust: function(row, col, trow, tcol, forRow, start, delta) {
            return this.map(function(ref){
                return ref.adjust(row, col, trow, tcol, forRow, start, delta);
            }).simplify();
        },
        toString: function() {
            return this.refs.map(function(ref){
                return ref.toString();
            }).join(", ");
        },
        valid: function() {
            for (var i = this.refs.length; --i >= 0;) {
                if (this.refs[i].valid()) {
                    return false;
                }
            }
            return true;
        },
        renameSheet: function(oldSheetName, newSheetName) {
            this.refs.forEach(function(ref){
                ref.renameSheet(oldSheetName, newSheetName);
            });
        }
    });

    /* -----[ exports ]----- */

    spreadsheet.NULLREF = NULL;
    spreadsheet.SHEETREF = new RangeRef(new CellRef(0, 0), new CellRef(Infinity, Infinity));
    spreadsheet.FIRSTREF = new CellRef(0, 0);
    spreadsheet.Ref = Ref;
    spreadsheet.NameRef = NameRef;
    spreadsheet.CellRef = CellRef;
    spreadsheet.RangeRef = RangeRef;
    spreadsheet.UnionRef = UnionRef;

    spreadsheet.SHEETREF.print = function() {
        return "#SHEET";
    };

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/autofillcalculator',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var RangeRef = kendo.spreadsheet.RangeRef;
    var CellRef = kendo.spreadsheet.CellRef;

    var AutoFillCalculator = kendo.Class.extend({
        init: function(grid) {
            this._grid = grid;
        },

        rectIsVertical: function(start, end, x, y) {
            var startRect = this._grid.rectangle(start.toRangeRef());
            var endRect = this._grid.rectangle(end.toRangeRef());
            return Math.abs(endRect[y] - startRect[y]) > Math.abs(startRect[x] - endRect[x]);
        },

        autoFillDest: function(selection, cursor) {
            var topLeft = selection.topLeft;
            var bottomRight = selection.bottomRight;

            var quadrant;
            var lower = cursor.row >= topLeft.row;
            var further = cursor.col >= topLeft.col;

            if (lower) {
                quadrant = further ? 4 : 3;
            } else {
                quadrant = further ? 2 : 1;
            }

            var pivot, opposite, cornerResult, expanding;

            if (quadrant === 4) {
                pivot = topLeft;
                opposite = bottomRight;

                expanding = cursor.row > opposite.row || cursor.col > opposite.col;

                if (expanding) {
                    cursor = new CellRef(Math.max(cursor.row, opposite.row), Math.max(cursor.col, opposite.col));
                }

                if (this.rectIsVertical(opposite, cursor, 'right', 'bottom')) { // vertical
                    cornerResult = new CellRef(cursor.row, opposite.col);
                } else {
                    cornerResult = new CellRef(opposite.row, cursor.col);
                }
            } else if (quadrant === 3) {
                var bottomLeft = new CellRef(topLeft.col, bottomRight.row);

                if (cursor.row > bottomRight.row && this.rectIsVertical(bottomLeft, cursor, 'left', 'bottom')) { // vertical
                    pivot = topLeft;
                    cornerResult = new CellRef(cursor.row, bottomRight.col);
                } else {
                    pivot = bottomRight;
                    cornerResult = new CellRef(topLeft.row, cursor.col);
                }
            } else if (quadrant === 2){
                var topRight = new CellRef(topLeft.row, bottomRight.col);

                if (cursor.col > bottomRight.col && !this.rectIsVertical(topRight, cursor, 'right', 'top')) { // horizontal
                    pivot = topLeft;
                    cornerResult = new CellRef(bottomRight.row, cursor.col);
                } else {
                    pivot = bottomRight;
                    cornerResult = new CellRef(cursor.row, topLeft.col);
                }
            } else {
                pivot = bottomRight;
                if (this.rectIsVertical(topLeft, cursor, 'left', 'top')) { // horizontal
                    cornerResult = new CellRef(cursor.row, topLeft.col);
                } else {
                    cornerResult = new CellRef(topLeft.row, cursor.col);
                }
            }

            return this._grid.normalize(new RangeRef(pivot, cornerResult));
        }
    });

    kendo.spreadsheet.AutoFillCalculator = AutoFillCalculator;
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/navigator',[ "../kendo.core",  "./autofillcalculator" ], f);
})(function(){

(function(kendo) {

    var RangeRef = kendo.spreadsheet.RangeRef;
    var CellRef = kendo.spreadsheet.CellRef;

    var EdgeNavigator = kendo.Class.extend({
        init: function(field, axis, rangeGetter, union) {
            this.rangeGetter = rangeGetter;

            this.prevLeft = function(index) {
                var current = union(this.range(index));
                var range = this.range(axis.prevVisible(current.topLeft[field]));
                return union(range).topLeft[field];
            };

            this.nextRight = function(index) {
                var current = union(this.range(index));
                var range = this.range(axis.nextVisible(current.bottomRight[field]));
                return union(range).bottomRight[field];
            };

            // these two don't look like the other ones, as they "shrink"
            this.nextLeft = function(index) {
                var range = union(this.range(index));
                return axis.nextVisible(range.bottomRight[field]);
            };

            this.prevRight = function(index) {
                var range = union(this.range(index));
                return axis.prevVisible(range.topLeft[field]);
            };
        },

        boundary: function(top, bottom) {
            this.top = top;
            this.bottom = bottom;
        },

        range: function(index) {
            return this.rangeGetter(index, this.top, this.bottom);
        }
    });

    var SheetNavigator = kendo.Class.extend({
        init: function(sheet) {
            this._sheet = sheet;
            this.autoFillCalculator = new kendo.spreadsheet.AutoFillCalculator(sheet._grid);

            this.colEdge = new EdgeNavigator("col", this._sheet._grid._columns, this.columnRange.bind(this), this.union.bind(this));
            this.rowEdge = new EdgeNavigator("row", this._sheet._grid._rows, this.rowRange.bind(this), this.union.bind(this));
        },

        height: function(height) {
            this._viewPortHeight = height;
        },

        union: function(ref) {
            return this._sheet.unionWithMerged(ref);
        },

        columnRange: function(col, topRow, bottomRow) {
            return this._sheet._ref(topRow, col, bottomRow - topRow, 1);
        },

        rowRange: function(row, leftCol, rightCol) {
            return this._sheet._ref(row, leftCol, 1, rightCol - leftCol);
        },

        selectionIncludesMergedCells: function() {
            return this._sheet.select().contains(this._sheet._mergedCells);
        },

        setSelectionValue: function(value) {
            var selection = this._sheet.selection();

            setTimeout(function() {
                selection.value(value());
            });
        },

        selectAll: function() {
            this._sheet.select(this._sheet._sheetRef);
        },

        select: function(ref, mode, addToExisting) {
            ref = this.refForMode(ref, mode);

            if (addToExisting) {
                ref = this._sheet.select().concat(ref);
            }

            this._sheet.select(ref);
        },

        refForMode: function(ref, mode) {
            var grid = this._sheet._grid;

            switch(mode) {
                case "range":
                    ref = grid.normalize(ref);
                    break;
                case "row":
                    ref = grid.rowRef(ref.row);
                    break;
                case "column":
                    ref = grid.colRef(ref.col);
                    break;
                case "sheet":
                    ref = this._sheet._sheetRef;
                    break;
            }

            return ref;
        },

        startSelection: function(ref, mode, addToExisting, shiftKey, view) {
            if (mode == "autofill") {
                this._sheet.startAutoFill();
            } else if (shiftKey && mode == "range") {
                var range = new RangeRef(this._sheet.activeCell().first(), ref);
                this._sheet.select(range, false, false);
                this._sheet.startSelection(view);
            } else {
                this._sheet.startSelection(view);
                this.select(ref, mode, addToExisting);
            }
        },

        completeSelection: function() {
            this._sheet.completeSelection();
        },

        selectForContextMenu: function(ref, mode) {
            var sheet = this._sheet;
            sheet._activeDrawing = null;
            if (!sheet.select().contains(this.refForMode(ref, mode))) {
                this.select(ref, mode);
            }
        },

        selectDrawingForContextMenu: function(drawing) {
            var sheet = this._sheet;
            sheet._activeDrawing = drawing;
            sheet.triggerChange({ selection: true });
        },

        modifySelection: function(action) {
            var direction = this.determineDirection(action);

            var sheet = this._sheet;
            var viewPortHeight = this._viewPortHeight;
            var rows = sheet._grid._rows;
            var columns = sheet._grid._columns;

            var originalSelection = sheet.currentOriginalSelectionRange();
            var selection = sheet.select().toRangeRef();
            var activeCell = sheet.activeCell();

            var topLeft = originalSelection.topLeft.clone();
            var bottomRight = originalSelection.bottomRight.clone();
            var bottomLeft = new CellRef(bottomRight.row, topLeft.col);

            var scrollInto;

            this.colEdge.boundary(selection.topLeft.row, selection.bottomRight.row);
            this.rowEdge.boundary(selection.topLeft.col, selection.bottomRight.col);

            switch (direction) {
              case "expand-left": // <| |
                topLeft.col = this.colEdge.prevLeft(topLeft.col);
                scrollInto = topLeft;
                break;
              case "shrink-right": // |>|
                topLeft.col = this.colEdge.nextLeft(topLeft.col);
                scrollInto = topLeft;
                break;
              case "expand-right": // | |>
                bottomRight.col = this.colEdge.nextRight(bottomRight.col);
                scrollInto = bottomRight;
                break;
              case "shrink-left": // |<|
                bottomRight.col = this.colEdge.prevRight(bottomRight.col);
                scrollInto = bottomRight;
                break;

                // four actions below mirror the upper ones, on the vertical axis
              case "expand-up":
                topLeft.row = this.rowEdge.prevLeft(topLeft.row);
                scrollInto = topLeft;
                break;
              case "shrink-down":
                topLeft.row = this.rowEdge.nextLeft(topLeft.row);
                scrollInto = topLeft;
                break;
              case "expand-down":
                bottomRight.row = this.rowEdge.nextRight(bottomRight.row);
                scrollInto = bottomRight;
                break;
              case "shrink-up":
                bottomRight.row = this.rowEdge.prevRight(bottomRight.row);
                scrollInto = bottomRight;
                break;

                // pageup/down - may need improvement
              case "expand-page-up":
                topLeft.row = rows.prevPage(topLeft.row, viewPortHeight);
                break;
              case "shrink-page-up":
                bottomRight.row = rows.prevPage(bottomRight.row, viewPortHeight);
                break;
              case "expand-page-down":
                bottomRight.row = rows.nextPage(bottomRight.row, viewPortHeight);
                break;
              case "shrink-page-down":
                topLeft.row = rows.nextPage(topLeft.row, viewPortHeight);
                break;

              case "first-col":
                topLeft.col = columns.firstVisible();
                bottomRight.col = activeCell.bottomRight.col;
                scrollInto = topLeft;
                break;
              case "last-col":
                bottomRight.col = columns.lastVisible();
                topLeft.col = activeCell.topLeft.col;
                scrollInto = bottomRight;
                break;
              case "first-row":
                topLeft.row = rows.firstVisible();
                bottomRight.row = activeCell.bottomRight.row;
                scrollInto = topLeft;
                break;
              case "last-row":
                bottomRight.row = rows.lastVisible();
                topLeft.row = activeCell.topLeft.row;
                scrollInto = bottomRight;
                break;
              case "last":
                bottomRight.row = rows.lastVisible();
                bottomRight.col = columns.lastVisible();
                topLeft = activeCell.topLeft;
                scrollInto = bottomRight;
                break;
              case "first":
                topLeft.row = rows.firstVisible();
                topLeft.col = columns.firstVisible();
                bottomRight = activeCell.bottomRight;
                scrollInto = topLeft;
                break;

              case "expand-word-right":
                bottomRight.col = columns.nextUntil(bottomRight.col, makeWordMovement(sheet, bottomRight, true));
                scrollInto = bottomRight;
                break;
              case "shrink-word-right":
                topLeft.col = columns.nextUntil(bottomLeft.col, makeWordMovement(sheet, bottomLeft, true));
                scrollInto = topLeft;
                break;
              case "expand-word-left":
                topLeft.col = columns.prevUntil(bottomLeft.col, makeWordMovement(sheet, bottomLeft, true));
                scrollInto = topLeft;
                break;
              case "shrink-word-left":
                bottomRight.col = columns.prevUntil(bottomRight.col, makeWordMovement(sheet, bottomRight, true));
                scrollInto = bottomRight;
                break;
              case "expand-word-up":
                topLeft.row = rows.prevUntil(topLeft.row, makeWordMovement(sheet, topLeft, false));
                scrollInto = topLeft;
                break;
              case "shrink-word-up":
                bottomRight.row = rows.prevUntil(bottomRight.row, makeWordMovement(sheet, bottomRight, false));
                scrollInto = bottomRight;
                break;
              case "expand-word-down":
                bottomRight.row = rows.nextUntil(bottomRight.row, makeWordMovement(sheet, bottomRight, false));
                scrollInto = bottomRight;
                break;
              case "shrink-word-down":
                topLeft.row = rows.nextUntil(topLeft.row, makeWordMovement(sheet, topLeft, false));
                scrollInto = topLeft;
                break;
            }

            var newSelection = new RangeRef(topLeft, bottomRight);

            if (!this.union(newSelection).intersects(activeCell)) {
                // throw new Error(newSelection.print() + " does not contain " + activeCell.print());
                this.modifySelection(direction.replace("shrink", "expand"));
                return;
            }

            if (scrollInto) {
                sheet.focus(scrollInto);
            }

            this.updateCurrentSelectionRange(newSelection);
        },

        moveActiveCell: function(direction) {
            var sheet = this._sheet;
            var activeCell = sheet.activeCell();
            var topLeft = activeCell.topLeft;
            var bottomRight = activeCell.bottomRight;

            var cell = sheet.originalActiveCell();
            var rows = sheet._grid._rows;
            var columns = sheet._grid._columns;

            var row = cell.row;
            var column = cell.col;

            switch (direction) {
              case "left":
                column = columns.prevVisible(topLeft.col);
                break;
              case "up":
                row = rows.prevVisible(topLeft.row);
                break;
              case "right":
                column = columns.nextVisible(bottomRight.col);
                break;
              case "down":
                row = rows.nextVisible(bottomRight.row);
                break;
              case "first-col":
                column = columns.firstVisible();
                break;
              case "last-col":
                column = columns.lastVisible();
                break;
              case "first-row":
                row = rows.firstVisible();
                break;
              case "last-row":
                row = rows.lastVisible();
                break;
              case "last":
                row = rows.lastVisible();
                column = columns.lastVisible();
                break;
              case "first":
                row = rows.firstVisible();
                column = columns.firstVisible();
                break;
              case "next-page":
                row = rows.nextPage(bottomRight.row, this._viewPortHeight);
                break;
              case "prev-page":
                row = rows.prevPage(bottomRight.row, this._viewPortHeight);
                break;

              case "word-right":
                column = columns.nextUntil(column, makeWordMovement(sheet, bottomRight, true));
                break;
              case "word-left":
                column = columns.prevUntil(column, makeWordMovement(sheet, bottomRight, true));
                break;
              case "word-up":
                row = rows.prevUntil(row, makeWordMovement(sheet, bottomRight, false));
                break;
              case "word-down":
                row = rows.nextUntil(row, makeWordMovement(sheet, bottomRight, false));
                break;
            }

            sheet.select(new CellRef(row, column));
        },

        navigateInSelection: function(direction) {
            var sheet = this._sheet;
            var activeCell = sheet.activeCell();
            var topLeft = activeCell.topLeft;

            var cell = sheet.originalActiveCell();
            var rows = sheet._grid._rows;
            var columns = sheet._grid._columns;

            var row = cell.row;
            var column = cell.col;

            var isFirstCell = false;
            var isLastCell = false;

            var selTopLeft, selBottomRight;

            var topLeftCol = topLeft.col;
            var topLeftRow = topLeft.row;
            var tmp;

            function setSelection(sel) {
                selTopLeft = sel.topLeft;
                selBottomRight = sel.bottomRight;
            }

            setSelection(sheet.currentNavigationRange());

            var done = false;
            var navigatedAway = false;

            while (!done && !navigatedAway) {
                var current = new CellRef(row, column);
                var isSingleCellSelected = sheet.singleCellSelection();

                if(isSingleCellSelected) {
                    isFirstCell = selTopLeft.eq(current) && sheet._sheetRef.topLeft.eq(current);
                    isLastCell = selBottomRight.eq(current) && sheet._sheetRef.bottomRight.eq(current);

                    if(!isFirstCell) {
                        isFirstCell = columns.firstVisible() === column && rows.firstVisible() === row;
                    }

                    if(!isLastCell) {
                        isLastCell = columns.lastVisible() === column && rows.lastVisible() === row;
                    }
                }

                switch (direction) {
                    case "next":
                        if(isLastCell) {
                            navigatedAway = true;
                            kendo.focusNextElement();
                        } else if (selBottomRight.eq(current)) {
                            setSelection(sheet.nextNavigationRange());
                            row = selTopLeft.row;
                            column = selTopLeft.col;
                        } else {
                            column = columns.nextVisible(topLeftCol);
                            if (column == topLeftCol || column > selBottomRight.col) {
                                column = selTopLeft.col;
                                tmp = rows.nextVisible(row);
                                if (tmp == row || tmp > selBottomRight.row) {
                                    row = selTopLeft.row;
                                } else {
                                    row = tmp;
                                }
                            }
                        }
                        break;
                    case "previous":
                        if(isFirstCell) {
                            navigatedAway = true;
                            this._sheet._workbook._view.element.find('.k-spreadsheet-name-editor .k-input').trigger("focus");
                        } else if (selTopLeft.eq(current)) {
                            setSelection(sheet.previousNavigationRange());
                            row = selBottomRight.row;
                            column = selBottomRight.col;
                        } else {
                            column = columns.prevVisible(topLeftCol);
                            if (column == topLeftCol || column < selTopLeft.col) {
                                column = selBottomRight.col;
                                tmp = rows.prevVisible(row);
                                if (tmp == row || tmp < selTopLeft.row) {
                                    row = selBottomRight.row;
                                } else {
                                    row = tmp;
                                }
                            }
                        }
                        break;
                    case "lower":
                        if (selBottomRight.eq(current)) {
                            setSelection(sheet.nextNavigationRange());
                            row = selTopLeft.row;
                            column = selTopLeft.col;
                        } else {
                            row = rows.nextVisible(topLeftRow);
                            if (row == topLeftRow || row > selBottomRight.row) {
                                row = selTopLeft.row;
                                tmp = columns.nextVisible(column);
                                if (tmp == column || tmp > selBottomRight.col) {
                                    column = selTopLeft.col;
                                } else {
                                    column = tmp;
                                }
                            }
                        }
                        break;
                    case "upper":
                        if (selTopLeft.eq(current)) {
                            setSelection(sheet.previousNavigationRange());
                            row = selBottomRight.row;
                            column = selBottomRight.col;
                        } else {
                            row = rows.prevVisible(topLeftRow);
                            if (row == topLeftRow || row < selTopLeft.row) {
                                row = selBottomRight.row;
                                tmp = columns.prevVisible(column);
                                if (tmp == column || tmp < selTopLeft.col) {
                                    column = selBottomRight.col;
                                } else {
                                    column = tmp;
                                }
                            }
                        }
                        break;
                    default:
                        throw new Error("Unknown entry navigation: " + direction);
                }

                done = !this.shouldSkip(row, column);
                // if (!done) { console.log("skipping", row, column); }
                topLeftCol = column;
                topLeftRow = row;
            }

            if(done) {
                if (sheet.singleCellSelection()) {
                    sheet.select(new CellRef(row, column));
                } else {
                    sheet.activeCell(new CellRef(row, column));
                }
            }
        },

        extendSelection: function(ref, mode) {
            var sheet = this._sheet;
            var grid = sheet._grid;

            if (mode === "autofill") {
               this.resizeAutoFill(ref);
               return;
            }
            if (mode === "range") {
                ref = grid.normalize(ref);
            }
            else if (mode === "row") {
                ref = grid.rowRef(ref.row).bottomRight;
            } else if (mode === "column") {
                ref = grid.colRef(ref.col).bottomRight;
            }

            var activeCell = sheet.originalActiveCell().toRangeRef();

            this.updateCurrentSelectionRange(new RangeRef(activeCell.topLeft, ref));
        },

        shouldSkip: function(row, col) {
            if (this._sheet.isHiddenRow(row) || this._sheet.isHiddenColumn(col)) {
                return true;
            }
            var ref = new CellRef(row, col);
            var isMerged = false;
            this._sheet.forEachMergedCell(function(merged) {
                if (merged.intersects(ref) && !merged.collapse().eq(ref)) {
                    isMerged = true;
                }
            });

            return isMerged;
        },

        resizeAutoFill: function(ref) {
            var sheet = this._sheet;
            var selection = sheet.select();
            var origin = sheet._autoFillOrigin;
            var dest = this.autoFillCalculator.autoFillDest(selection, ref);

            var punch = this.punch(selection, dest);
            var hint, direction;

            if (!punch) {
                var preview = sheet.range(dest)._previewFillFrom(sheet.range(origin));
                if (preview) {
                    direction = preview.direction;
                    hint = preview.hint;
                }
            }

            sheet.updateAutoFill(dest, punch, hint, direction);
        },

        determineDirection: function(action) {
            var selection = this._sheet.currentSelectionRange();
            var activeCell = this._sheet.activeCell();

            // There may be a third, indeterminate state, caused by a merged cell.
            // In this state, all key movements are treated as shrinks.
            // The navigator will reverse them if it detects this it will cause the selection to exclude the active cell.
            var leftMode = activeCell.topLeft.col == selection.topLeft.col;
            var rightMode = activeCell.bottomRight.col == selection.bottomRight.col;
            var topMode = activeCell.topLeft.row == selection.topLeft.row;
            var bottomMode = activeCell.bottomRight.row == selection.bottomRight.row;

            switch (action) {
              case "left":
                action = rightMode ? "expand-left" : "shrink-left";
                break;
              case "right":
                action = leftMode ? "expand-right" : "shrink-right";
                break;
              case "up":
                action = bottomMode ? "expand-up" : "shrink-up";
                break;
              case "down":
                action = topMode ? "expand-down" : "shrink-down";
                break;
              case "prev-page":
                action = bottomMode ? "expand-page-up" : "shrink-page-up";
                break;
              case "next-page":
                action = topMode ? "expand-page-down" : "shrink-page-down";
                break;
              case "word-left":
                action = rightMode ? "expand-word-left" : "shrink-word-left";
                break;
              case "word-right":
                action = leftMode ? "expand-word-right" : "shrink-word-right";
                break;
              case "word-up":
                action = bottomMode ? "expand-word-up" : "shrink-word-up";
                break;
              case "word-down":
                action = topMode ? "expand-word-down" : "shrink-word-down";
                break;
            }

            return action;
        },

        updateCurrentSelectionRange: function(ref) {
            var sheet = this._sheet;
            sheet.select(sheet.originalSelect().replaceAt(sheet.selectionRangeIndex(), ref), false);
        },

        punch: function(selection, subset) {
            var punch;
            if (subset.topLeft.eq(selection.topLeft)) {
                if (subset.bottomRight.row < selection.bottomRight.row) {
                    var bottomRow = this.rowEdge.nextRight(subset.bottomRight.row);

                    punch = new RangeRef(
                        new CellRef(bottomRow, selection.topLeft.col),
                        selection.bottomRight
                    );
                } else if (subset.bottomRight.col < selection.bottomRight.col) {
                    var bottomCol = this.colEdge.nextRight(subset.bottomRight.col);

                    punch = new RangeRef(
                        new CellRef(selection.topLeft.row, bottomCol),
                        selection.bottomRight
                    );
                }
            }

            return punch;
        }
    });

    function makeWordMovement(sheet, pivot, isCol) {
        // the general idea is:
        //
        // - if we start on a non-empty cell, we should select the
        //   range of non-empty cells that follow it.  If, however,
        //   the second cell is empty, then we don't stop there; we
        //   should skip all the empty cells and stop at the first
        //   non-empty cell (and select it).
        //
        // - if we start on an empty cell, then skip all empty cells
        //   and select the first non-empty one.

        var firstVal = sheet.range(pivot).value();
        return function(pos, advanced, hidden) {
            if (hidden) { return true; }   // skip hidden cells
            var val = ( isCol ?
                        sheet.range(pivot.row, pos) :
                        sheet.range(pos, pivot.col) ).value();
            if (firstVal === null) {
                return val === null ? false : pos;
            } else if (!advanced && val === null) {
                firstVal = null; // switch to the other mode
                return false;
            } else {
                return val === null;
            }
        };
    }

    kendo.spreadsheet.SheetNavigator = SheetNavigator;
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });


(function(f, define){
    define('spreadsheet/axismanager',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var AxisManager = kendo.Class.extend({
        init: function(sheet) {
            this._sheet = sheet;
        },

        forEachSelectedColumn: function(callback) {
            var sheet = this._sheet;

            sheet.batch(function() {
                sheet.select().forEachColumnIndex(function(index, i) {
                    callback(sheet, index, i);
                });
            }, { layout: true, recalc: true });
        },

        forEachSelectedRow: function(callback) {
            var sheet = this._sheet;

            sheet.batch(function() {
                sheet.select().forEachRowIndex(function(index, i) {
                    callback(sheet, index, i);
                });
            }, { layout: true, recalc: true });
        },

        includesHiddenColumns: function(ref) {
            return this._sheet._grid._columns.includesHidden(ref.topLeft.col, ref.bottomRight.col);
        },

        includesHiddenRows: function(ref) {
            return this._sheet._grid._rows.includesHidden(ref.topLeft.row, ref.bottomRight.row);
        },

        selectionIncludesHiddenColumns: function() {
            return this.includesHiddenColumns(this._sheet.select());
        },

        selectionIncludesHiddenRows: function() {
            return this.includesHiddenRows(this._sheet.select());
        },

        deleteSelectedColumns: function() {
            var indexes = [], delta = 0;
            this.forEachSelectedColumn(function(sheet, index) {
                index -= delta;
                if (sheet.isHiddenColumn(index)) {
                    return;
                }
                delta++;
                var formulas = [];
                indexes.unshift({
                    index    : index,
                    formulas : formulas,
                    width    : sheet.columnWidth(index)
                });
                sheet._saveModifiedFormulas(formulas, function(){
                    sheet.deleteColumn(index);
                });
            });
            return indexes;
        },

        deleteSelectedRows: function() {
            var indexes = [], delta = 0;
            this.forEachSelectedRow(function(sheet, index) {
                index -= delta;
                if (sheet.isHiddenRow(index)) {
                    return;
                }
                delta++;
                var formulas = [];
                indexes.unshift({
                    index    : index,
                    formulas : formulas,
                    height   : sheet.rowHeight(index)
                });
                sheet._saveModifiedFormulas(formulas, function(){
                    sheet.deleteRow(index);
                });
            });
            return indexes;
        },

        hideSelectedColumns: function() {
            this.forEachSelectedColumn(function(sheet, index) {
                sheet.hideColumn(index);
            });
            var sheet = this._sheet;
            var ref = sheet.select().toRangeRef();
            var left = ref.topLeft.col;
            var right = ref.bottomRight.col;
            var sel = null;
            while (true) {
                var hasRight = right < sheet._columns._count;
                var hasLeft = left >= 0;
                if (!hasLeft && !hasRight) {
                    break;
                }
                if (hasRight && !sheet.isHiddenColumn(right)) {
                    sel = right;
                    break;
                }
                if (hasLeft && !sheet.isHiddenColumn(left)) {
                    sel = left;
                    break;
                }
                left--;
                right++;
            }
            if (sel !== null) {
                ref = new kendo.spreadsheet.RangeRef(
                    new kendo.spreadsheet.CellRef(0, sel),
                    new kendo.spreadsheet.CellRef(sheet._rows._count - 1, sel)
                );
                sheet.range(ref).select();
            }
        },

        hideSelectedRows: function() {
            this.forEachSelectedRow(function(sheet, index) {
                sheet.hideRow(index);
            });
            var sheet = this._sheet;
            var ref = sheet.select().toRangeRef();
            var top = ref.topLeft.row;
            var bottom = ref.bottomRight.row;
            var sel = null;
            while (true) {
                var hasBottom = bottom < sheet._rows._count;
                var hasTop = top >= 0;
                if (!hasTop && !hasBottom) {
                    break;
                }
                if (hasBottom && !sheet.isHiddenRow(bottom)) {
                    sel = bottom;
                    break;
                }
                if (hasTop && !sheet.isHiddenRow(top)) {
                    sel = top;
                    break;
                }
                top--;
                bottom++;
            }
            if (sel !== null) {
                ref = new kendo.spreadsheet.RangeRef(
                    new kendo.spreadsheet.CellRef(sel, 0),
                    new kendo.spreadsheet.CellRef(sel, sheet._columns._count - 1)
                );
                sheet.range(ref).select();
            }
        },

        unhideSelectedColumns: function() {
            this.forEachSelectedColumn(function(sheet, index) {
                sheet.unhideColumn(index);
            });
        },

        unhideSelectedRows: function() {
            this.forEachSelectedRow(function(sheet, index) {
                sheet.unhideRow(index);
            });
        },

        addColumnLeft: function() {
            var sheet = this._sheet;
            var base, count = 0;
            sheet.batch(function(){
                sheet.select().forEachColumnIndex(function(index) {
                    if (!base) {
                        base = index;
                    }
                    sheet.insertColumn(base);
                    ++count;
                });
            }, { recalc: true, layout: true });
            return { base: base, count: count };
        },

        addColumnRight: function() {
            var sheet = this._sheet;
            var base, count = 0;
            sheet.batch(function(){
                sheet.select().forEachColumnIndex(function(index) {
                    base = index + 1;
                    ++count;
                });
                for (var i = 0; i < count; ++i) {
                    sheet.insertColumn(base);
                }
            }, { recalc: true, layout: true });
            return { base: base, count: count };
        },

        addRowAbove: function() {
            var sheet = this._sheet;
            var base, count = 0;
            var selectedRows = sheet.select();

            sheet.batch(function(){
                selectedRows.forEachRowIndex(function(index) {
                    if (!base) {
                        base = index;
                    }
                    sheet.insertRow(base);
                    ++count;
                });
            }, { recalc: true, layout: true });

            return { base: base, count: count };
        },

        addRowBelow: function() {
            var sheet = this._sheet;
            var base, count = 0;

            sheet.batch(function(){
                sheet.select().forEachRowIndex(function(index) {
                    base = index + 1;
                    ++count;
                });
                for (var i = 0; i < count; ++i) {
                    sheet.insertRow(base);
                }
            }, { recalc: true, layout: true });

            return { base: base, count: count };
        }
    });

    kendo.spreadsheet.AxisManager = AxisManager;
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/clipboard',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var $ = kendo.jQuery;
    var CellRef = kendo.spreadsheet.CellRef;

    var Clipboard = kendo.Class.extend({
        init: function(workbook) {
            this._content = {};
            this._externalContent = {};
            this._internalContent = {};
            this.workbook = workbook;
            this.origin = kendo.spreadsheet.NULLREF;
            this.iframe = document.createElement("iframe");
            this.iframe.className = "k-spreadsheet-clipboard-paste";
            this.iframe.setAttribute("title", "Spreadsheet clipboard iframe");
            this.menuInvoked = false;
            this._uid = kendo.guid();
            document.body.appendChild(this.iframe);
        },

        destroy: function() {
            $(this.iframe).remove();
        },

        canCopy: function() {
            var status = {canCopy: true};
            var selection = this.workbook.activeSheet().select();
            if (selection === kendo.spreadsheet.NULLREF) {
                status.canCopy = false;
            }
            if (selection instanceof kendo.spreadsheet.UnionRef) {
                status.canCopy = false;
                status.multiSelection = true;
            }
            if (this.menuInvoked) {
                status.canCopy = false;
                status.menuInvoked = true;
            }
            return status;
        },

        canPaste: function() {
            var sheet = this.workbook.activeSheet();
            var ref = this.pasteRef();
            var range = sheet.range(ref);
            var status = { canPaste: true, pasteOnMerged: false, pasteOnDisabled: false };

            if (!range.enable()) {
                status.canPaste =  false;
                status.pasteOnDisabled = true;
            }
            if (!ref.eq(sheet.unionWithMerged(ref))) {
                status.canPaste = false;
                status.pasteOnMerged = true;
            }
            if (this.menuInvoked) {
                status.canPaste = false;
                status.menuInvoked = true;
            }
            return status;
        },

        intersectsMerged: function() {
            var sheet = this.workbook.activeSheet();
            this.parse();
            this.origin = this._content.origRef;
            var ref = this.pasteRef();
            return !ref.eq(sheet.unionWithMerged(ref));
        },

        copy: function() {
            var sheet = this.workbook.activeSheet();
            this.origin = sheet.select();
            this._internalContent = sheet.selection().getState();
            delete this._externalContent.html;
            delete this._externalContent.plain;
        },

        cut: function() {
            var sheet = this.workbook.activeSheet();
            this.copy();
            sheet.range(sheet.select()).clear();
        },

        pasteRef: function() {
            var sheet = this.workbook.activeSheet();

            // When pasting from an external source, origin will be
            // NULLREF.  Just return the destination range.
            // https://github.com/telerik/kendo-ui-core/issues/3486
            if (this.origin === kendo.spreadsheet.NULLREF) {
                return sheet.select();
            }

            var destination = sheet.activeCell().first();
            var originActiveCell = this.origin.first();
            var rowDelta = originActiveCell.row - destination.row;
            var colDelta = originActiveCell.col - destination.col;

            return this.origin.relative(rowDelta, colDelta, 3);
        },

        paste: function() {
            var sheet = this.workbook.activeSheet();
            var pasteRef = this.pasteRef();
            if (pasteRef.bottomRight.row >= sheet._rows._count || pasteRef.bottomRight.col >= sheet._columns._count) {
                sheet.resize(
                    Math.max(pasteRef.bottomRight.row + 1, sheet._rows._count),
                    Math.max(pasteRef.bottomRight.col + 1, sheet._columns._count)
                );
            }
            sheet.range(pasteRef).setState(this._content, this);
            sheet.triggerChange({ recalc: true, ref: pasteRef });
        },

        external: function(data) {
            if (data && (data.html || data.plain)) {
                this._externalContent = data;
            } else {
                return this._externalContent;
            }
        },

        isExternal: function() {
            return !this._isInternal();
        },

        parse: function() {
            var state = newState();

            if (this._isInternal()) {
                state = this._internalContent;
            } else {
                var data = this._externalContent;
                if (data.html) {
                    var doc = this.iframe.contentWindow.document;
                    doc.open();
                    doc.write(data.html);
                    doc.close();
                    var table = doc.querySelector("table");
                    if (table) {
                        state = parseHTML(table);
                    } else {
                        state = parseTSV(data.plain);
                    }
                } else {
                    state = parseTSV(data.plain);
                }
                this.origin = state.origRef;
            }

            this._content = state;
        },

        _isInternal: function() {
            if (this._externalContent.html === undefined) {
                return true;
            }
            var internalHTML = $("<div/>").html(this._externalContent.html).find("table.kendo-clipboard-"+ this._uid).length ? true : false;
            var internalPlain = $("<div/>").html(this._externalContent.plain).find("table.kendo-clipboard-"+ this._uid).length ? true : false;
            return (internalHTML || internalPlain);
        }
    });
    kendo.spreadsheet.Clipboard = Clipboard;

    function newState() {
        var ref = new CellRef(0, 0, 0);
        return {
            ref         : ref,
            mergedCells : [],
            data        : [],
            foreign     : true,
            origRef     : ref.toRangeRef()
        };
    }

    function setStateData(state, row, col, value) {
        var data = state.data || (state.data = []);
        if (!data[row]) {
            data[row] = [];
        }
        data[row][col] = value;
        var br = state.origRef.bottomRight;
        br.row = Math.max(br.row, row);
        br.col = Math.max(br.col, col);
    }

    function stripStyle(style) {
        return style.replace(/^-(?:ms|moz|webkit)-/, "");
    }

    function borderObject(styles) {
        var obj = {};
        [
            "borderBottom",
            "borderRight",
            "borderLeft",
            "borderTop"
        ].forEach(function(key) {
            obj[key] = styles[key + "Style"] == "none" ? null : {
                size: 1,
                color: styles[key + "Color"]
            };
        });
        return obj;
    }

    function cellState(row, col, element, hBorders, vBorders) {
        var styles = window.getComputedStyle(element);

        // note: Chrome 70 appends a \t to a cell's text, which is actually mandated by the standard
        // ([1] item 6).  We remove it below.  In [2] it's suggested they might switch back to
        // previous behavior, but removing an eventual last TAB won't hurt anyway.
        //
        // [1] https://www.w3.org/TR/html53/dom.html#dom-htmlelement-innertext
        // [2] https://bugs.chromium.org/p/chromium/issues/detail?id=897373
        var text = element.innerText.replace(/\t$/, "");

        var borders = borderObject(styles);
        var state = {
            value: text === "" ? null : text,

            borderTop    : borders.borderTop    || hBorders.get(row, col)     || null,
            borderBottom : borders.borderBottom || hBorders.get(row + 1, col) || null,
            borderLeft   : borders.borderLeft   || vBorders.get(row, col)     || null,
            borderRight  : borders.borderRight  || vBorders.get(row, col + 1) || null,

            fontSize : parseInt(styles["font-size"], 10)
        };

        hBorders.set(row, col, state.borderTop);
        hBorders.set(row + 1, col, state.borderBottom);
        vBorders.set(row, col, state.borderLeft);
        vBorders.set(row, col + 1, state.borderRight);

        if (styles["background-color"] !== "rgb(0, 0, 0)" && styles["background-color"] !== "rgba(0, 0, 0, 0)") {
            state.background = styles["background-color"];
        }
        if (styles.color !== "rgb(0, 0, 0)" && styles.color !== "rgba(0, 0, 0, 0)") {
            state.color = styles.color;
        }
        if (styles["text-decoration"] == "underline") {
            state.underline = true;
        }
        if (styles["font-style"] == "italic") {
            state.italic = true;
        }
        if (styles["font-weight"] == "bold") {
            state.bold = true;
        }
        if (stripStyle(styles["text-align"]) !== "right") {
            state.textAlign = stripStyle(styles["text-align"]);
        }
        if (styles["vertical-align"] !== "middle") {
            state.verticalAlign = styles["vertical-align"];
        }
        if (styles["word-wrap"] !== "normal" ) {
            state.wrap = true;
        }

        return state;
    }

    function parseHTML(table) {
        var state = newState();

        var done = [], row = 0, col = 0;
        for (var i = 0; i < table.rows.length; ++i) {
            done.push([]);
        }
        var hBorders = new kendo.spreadsheet.calc.runtime.Matrix();
        var vBorders = new kendo.spreadsheet.calc.runtime.Matrix();

        for (var ri = 0; ri < table.rows.length; ++ri, ++row) {
            var tr = table.rows[ri];
            col = 0;
            for (var ci = 0; ci < tr.cells.length; ++ci) {
                var td = tr.cells[ci];
                var rowSpan = td.rowSpan;
                var colSpan = td.colSpan;
                while (done[row][col]) {
                    col++;
                }

                // A cell containing a long text overflowing the next (empty) cell will weirdly be
                // reported as merged by Excel (has colspan=2).  Then, Excel informatively suggests
                // us to ignore the colSpan by passing mso-ignore:colspan in the style.  Much thanks!
                // https://github.com/telerik/kendo-ui-core/issues/3760
                var style = td.getAttribute("style");
                var ignoreColspan = /mso-ignore:colspan/.test(style);

                setStateData(state, row, col, cellState(row, col, td, hBorders, vBorders));
                if (rowSpan > 1 || (colSpan > 1 && !ignoreColspan)) {
                    state.mergedCells.push(
                        new kendo.spreadsheet.RangeRef(
                            new CellRef(row, col),
                            new CellRef(row + rowSpan - 1, col + colSpan - 1)
                        ).toString());
                }
                for (var dr = row + rowSpan; --dr >= row;) {
                    for (var dc = col + colSpan; --dc >= col;) {
                        if (dr < done.length) {
                            done[dr][dc] = true;
                            if (!(dr == row && dc == col)) {
                                setStateData(state, dr, dc, {});
                            }
                        }
                    }
                }
            }
        }

        return state;
    }

    function parseTSV(data) {
        var state = newState();
        if (data.indexOf("\t") === -1 && data.indexOf("\n") == -1) {
            setStateData(state, 0, 0, { value: data });
        } else {
            var rows = data.split("\n");
            for (var ri = 0; ri < rows.length; ri++) {
                var cols = rows[ri].split("\t");
                for (var ci = 0; ci < cols.length; ci++) {
                    setStateData(state, ri, ci, { value: cols[ci] });
                }
            }
        }
        return state;
    }

})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/range',[ "../kendo.core", "../util/text-metrics", "../util/main" ], f);
})(function(){

(function(kendo) {

    var $ = kendo.jQuery;

    var UnionRef = kendo.spreadsheet.UnionRef;
    var CellRef = kendo.spreadsheet.CellRef;
    var RangeRef = kendo.spreadsheet.RangeRef;

    var PROPERTIES = [
        "color", "fontFamily", "underline",
        "italic", "bold", "textAlign", "indent",
        "verticalAlign", "background", "format", "link", "editor",
        "borderTop", "borderRight", "borderBottom", "borderLeft",
        "comment", "html"
    ];

    var Range = kendo.Class.extend({
        init: function(ref, sheet) {
            this._sheet = sheet;
            this._ref = ref;
        },

        clone: function() {
            return new Range(this._ref.clone(), this._sheet);
        },

        skipHiddenCells: function() {
            var refs = [];
            var self = this, sheet = self._sheet;
            var skipHiddenRows = sheet.isHiddenRow.bind(sheet);
            var skipHiddenCols = sheet.isHiddenColumn.bind(sheet);
            self._ref.forEach(function(ref){
                ref = self._normalize(ref.toRangeRef());
                var tl = ref.topLeft, br = ref.bottomRight;
                var rows = partition(tl.row, br.row, skipHiddenRows);
                var cols = partition(tl.col, br.col, skipHiddenCols);
                for (var i = 0; i < rows.length; ++i) {
                    for (var j = 0; j < cols.length; ++j) {
                        refs.push(new RangeRef(
                            new CellRef(rows[i].begin, cols[j].begin),
                            new CellRef(rows[i].end, cols[j].end)
                        ));
                    }
                }
            });
            return sheet.range(refs.length > 1 ? new UnionRef(refs) : refs[0]);
        },

        _normalize: function(ref) {
            return this._sheet._grid.normalize(ref);
        },

        _set: function(name, value, noTrigger) {
            var self = this;
            var sheet = self._sheet;
            self._ref.forEach(function(ref) {
                var result = ref;
                var valueProp = name === "value" || name === "formula" || name === "link";

                // Set values/formulas/links only to the topLeft cell when merged
                if(valueProp && ref.topLeft) {
                    var topLeftRef = new CellRef(ref.topLeft.row, ref.topLeft.col);

                    sheet.forEachMergedCell(function(f){
                        if(f.intersects(topLeftRef)) {
                            result = topLeftRef;
                        }
                    });
                }

                sheet._set(result.toRangeRef(), name, value);
            });
            if (!noTrigger) {
                sheet.triggerChange({
                    recalc : name == "formula" || name == "value" || name == "validation",
                    value  : value,
                    range  : self,
                    ref    : self._ref
                });
            }
            return self;
        },

        _get: function(name) {
            return this._sheet._get(this._ref.toRangeRef(), name);
        },

        _property: function(name, value) {
            if (value === undefined) {
                return this._get(name);
            } else {
                return this._set(name, value);
            }
        },

        value: function(value) {
            if (value !== undefined) {
                // When value is set through the public API we must clear the
                // formula.  Don't trigger change (third parameter), it'll be
                // done when setting the value below
                this._set("formula", null, true);
            }
            return this._property("value", value);
        },

        html: function(value) {
            return this._property("html", value);
        },

        resize: function(direction) {
            var ref = this._resizedRef(direction);
            return new Range(ref, this._sheet);
        },

        _resizedRef: function(direction) {
            return this._ref.map(function(ref) {
                return ref.toRangeRef().resize(direction);
            });
        },

        input: function(value, options) {
            options = $.extend({
                arrayFormula: false
            }, options);
            var existingFormat = this._get("format"), x;
            if (value !== undefined) {
                var tl = this._ref.toRangeRef().topLeft;
                x = kendo.spreadsheet.calc.parse(this._sheet.name(), tl.row, tl.col, value, existingFormat);
                this._sheet.batch(function() {
                    var formula = null;
                    if (x.type == "exp") {
                        formula = kendo.spreadsheet.calc.compile(x);
                    } else if (existingFormat != "@") {
                        var existingFormatType = existingFormat &&
                            kendo.spreadsheet.formatting.type(x.value, existingFormat);
                        if (x.type == "date" && existingFormatType != "date") {
                            this.format(x.format || toExcelFormat(kendo.culture().calendar.patterns.d));
                        } else if (x.type == "percent" && existingFormatType != "percent") {
                            this.format(x.value*100 == (x.value*100|0) ? "0%" : "0.00%");
                        } else if (x.format) {
                            if (!existingFormat || x.currency ||
                                (existingFormatType == "number" && x.type == "number" &&
                                 x.format.length > existingFormat.length)) {
                                this.format(x.format);
                            }
                        }
                    } else if (x.type != "string") {
                        x.value = value;
                    }
                    this.formula(formula, options.arrayFormula);
                    if (!formula) {
                        // value() will clear the formula.  Lucky for us,
                        // x.value is undefined so it actually won't, but let's
                        // be explicit and only set value if formula is not
                        // present.
                        this.value(x.value);
                    }
                }.bind(this), { recalc: true, value: value, ref: this._ref, editorChange: this._sheet.isInEditMode() });

                return this;
            } else {
                value = this._get("value");
                var formula = this._get("formula");
                var type = existingFormat && !formula && kendo.spreadsheet.formatting.type(value, existingFormat);

                if (formula) {
                    // it's a Formula object which stringifies to the
                    // formula as text (without the starting `=`).
                    value = "=" + formula;
                } else OUT: { // jshint ignore:line
                    if (existingFormat && type == "date") {
                        // check if we could parse back the displayed value.
                        // https://github.com/telerik/kendo/issues/5335
                        var t1 = kendo.spreadsheet.formatting.text(value, existingFormat);
                        x = kendo.spreadsheet.calc.parse(null, null, null, t1, existingFormat); // it's not a formula so we don't need sheet/row/col
                        var t2 = kendo.spreadsheet.formatting.text(x.value, existingFormat);
                        if (t1 == t2) {
                            value = t1;
                            break OUT; // jshint ignore:line
                        }
                    }
                    if (type === "date") {
                        value = kendo.toString(kendo.spreadsheet.numberToDate(value), kendo.culture().calendar.patterns.d);
                    } else if (type === "percent") {
                        value = kendo.spreadsheet.calc.runtime.limitPrecision(value * 100) + "%";
                    } else if (typeof value == "string" &&
                               (/^[=']/.test(value) ||
                                (/^(?:true|false)$/i).test(value) ||
                                looksLikeANumber(value))) {
                        value = "'" + value;
                    } else if (this._sheet._useCultureDecimals() &&
                               typeof value == "number" &&
                               value != Math.floor(value)) {
                        value = String(value).replace(".", kendo.culture().numberFormat["."]);
                    }
                }

                return value;
            }
        },

        enable: function(value) {
            if (value === undefined) {
                return !kendo.util.withExit(function(exit){
                    this._sheet.forEach(this._ref, function(_, __, data) {
                        if (data.enable === false) {
                            exit(true);
                        }
                    });
                }, this);
            }

            return this._property("enable", value);
        },

        formula: function(value, arrayFormula) {
            var self = this;
            if (value === undefined) {
                var f = self._get("formula");
                return f ? "" + f : null; // stringify if present
            }
            if (arrayFormula) {
                // when setting an array formula, we want to set it on
                // the first cell only, as it will fill the whole
                // range.
                var ref = this._ref.toRangeRef();
                value = self._sheet.range(ref.topLeft)
                    ._set("formula", value)
                    ._get("formula"); // make sure we get the compiled Formula, not a string

                if (value) {    // could be null.
                    // this will be used in FormulaContext -- it's the
                    // range that the formula must populate.
                    value.setArrayFormulaRange(ref);
                }
            } else {
                self._set("formula", value);
            }
            return self;
        },

        intersectingArrayFormula: function() {
            var ref = this._ref.clone().simplify().setSheet(this._sheet.name());
            return kendo.util.withExit(function(exit){
                this._sheet._forFormulas(function(f){
                    var r = f.arrayFormulaRange;
                    if (r && (r = ref.intersect(r)) !== kendo.spreadsheet.NULLREF) {
                        exit({ formula: f, intersection: r });
                    }
                });
            }, this);
        },

        canEditArrayFormula: function() {
            var x = this.intersectingArrayFormula();
            if (x) {
                // we want to allow editing only when the new range is
                // at least as big as the original range (i.e. no
                // cells removed)
                return x.formula.arrayFormulaRange.eq(x.intersection);
            }
            return true;
        },

        validation: function(value) {
            //TODO: Accept objects only?

            if (value === undefined) {
                var f = this._get("validation");

                return f ? f.toJSON() : null; // stringify if present
            }
            return this._property("validation", value);
        },

        _getValidationState: function() {
            var ref = this._ref.toRangeRef();
            var topLeftRow = ref.topLeft.row;
            var topLeftCol = ref.topLeft.col;
            var bottomRightRow = ref.bottomRight.row;
            var bottomRightCol = ref.bottomRight.col;
            var ci, ri;

            for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {
                for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {
                    var validation = this._sheet._validation(ri, ci);

                    if (validation && validation.type === "reject" && validation.value === false) {
                        return validation;
                    }
                }
            }

            return false;
        },

        merge: function() {
            this._ref = this._sheet._merge(this._ref);
            return this;
        },

        unmerge: function() {
            var mergedCells = this._sheet._mergedCells;

            this._ref.forEach(function(ref) {
                ref.toRangeRef().intersecting(mergedCells).forEach(function(mergedRef) {
                    mergedCells.splice(mergedCells.indexOf(mergedRef), 1);
                });
            });

            this._sheet.triggerChange({});

            return this;
        },

        select: function() {
            this._sheet.select(this._ref);

            return this;
        },

        values: function(values) {
            if (this._ref instanceof UnionRef) {
                throw new Error("Unsupported for multiple ranges.");
            }

            if (this._ref === kendo.spreadsheet.NULLREF) {
                if (values !== undefined) {
                    throw new Error("Unsupported for NULLREF.");
                } else {
                    return [];
                }
            }

            var ref = this._ref.toRangeRef();
            var topLeftRow = ref.topLeft.row;
            var topLeftCol = ref.topLeft.col;
            var bottomRightRow = ref.bottomRight.row;
            var bottomRightCol = ref.bottomRight.col;
            var ci, ri;

            if (values === undefined) {
                values = new Array(ref.height());

                for (var vi = 0; vi < values.length; vi++) {
                    values[vi] = new Array(ref.width());
                }

                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {
                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {
                        values[ri - topLeftRow][ci - topLeftCol] = this._sheet._value(ri, ci);
                    }
                }

                return values;
            } else {
                this._sheet._set(ref, "formula", null);

                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {
                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {
                        var row = values[ri - topLeftRow];

                        if (row) {
                            var value = row[ci - topLeftCol];

                            if (value !== undefined) {
                                this._sheet._value(ri, ci, value);
                            }
                        }
                    }
                }

                this._sheet.triggerChange({ recalc: true, ref: ref });

                return this;
            }
        },

        _properties: function(props, isAutofill) {
            if (this._ref instanceof UnionRef) {
                throw new Error("Unsupported for multiple ranges.");
            }

            if (this._ref === kendo.spreadsheet.NULLREF) {
                if (props !== undefined) {
                    throw new Error("Unsupported for NULLREF.");
                } else {
                    return [];
                }
            }

            var ref = this._ref.toRangeRef();
            var topLeftRow = ref.topLeft.row;
            var topLeftCol = ref.topLeft.col;
            var bottomRightRow = ref.bottomRight.row;
            var bottomRightCol = ref.bottomRight.col;
            var ci, ri;
            var sheet = this._sheet;

            if (props === undefined) {
                props = new Array(ref.height());
                sheet.forEach(ref, function(row, col, data){
                    row -= topLeftRow;
                    col -= topLeftCol;
                    var line = props[row] || (props[row] = []);
                    line[col] = data;
                });
                return props;
            }
            else {
                var data;
                ref = ref.clone();
                var setProp = function(propName) {
                    var propValue = data[propName];
                    ref.topLeft.row = ref.bottomRight.row = ri;
                    ref.topLeft.col = ref.bottomRight.col = ci;

                    if (propName == "value") {
                        sheet._set(ref, "formula", null);
                    }

                    sheet._set(ref, propName, propValue);
                };

                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {
                    if (!isAutofill && sheet.isHiddenColumn(ci)) {
                        continue;
                    }
                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {
                        if (!isAutofill && sheet.isHiddenRow(ri)) {
                            continue;
                        }
                        if (isAutofill && sheet.isFilteredRow(ri)) {
                            continue;
                        }
                        var row = props[ri - topLeftRow];
                        if (row) {
                            data = row[ci - topLeftCol];
                            if (data) {
                                Object.keys(data).forEach(setProp);
                            }
                        }
                    }
                }
                sheet.triggerChange({ recalc: true, ref: this._ref });
                return this;
            }
        },

        clear: function(options) {
            options = options || {};
            var clearAll = options.clearAll || !Object.keys(options).length;

            var sheet = this._sheet;

            var reason = {
                recalc: clearAll || options.contentsOnly,
                ref: this._ref
            };

            sheet.batch(function() {

                if (reason.recalc) {
                    this.formula(null);
                }

                if (clearAll) {
                    this.validation(null);
                }

                if (clearAll || options.formatOnly) {
                    PROPERTIES.forEach(function(x) {
                        if (!(options.keepBorders && /^border/i.test(x))) {
                            this[x](null);
                        }
                    }.bind(this));
                    this.fontSize(null);
                    this.wrap(null);
                    this.unmerge();
                }

            }.bind(this), reason);

            return this;
        },

        clearContent: function() {
            return this.clear({ contentsOnly: true });
        },

        clearFormat: function() {
            return this.clear({ formatOnly: true });
        },

        isSortable: function() {
            return !this.cantSort();
        },

        cantSort: function() {
            if (this._ref instanceof UnionRef) {
                return { code: "cantSortMultipleSelection",
                         message: "Unsupported for multiple ranges." };
            }
            if (this._ref === kendo.spreadsheet.NULLREF) {
                return { code: "cantSortNullRef",
                         message: "Unsupported for NULLREF." };
            }
            var mc = this._sheet._getMergedCells(this._ref.toRangeRef());
            var primary = mc.primary;
            var secondary = mc.secondary;
            var width = null, height = null;
            var cant = {};
            try {
                this._sheet.forEach(this, function(row, col){
                    var id = new CellRef(row, col).print();
                    var merged = primary[id];
                    if (merged) {
                        if (width === null) {
                            width = merged.width();
                            height = merged.height();
                        } else if (!(width == merged.width() && height == merged.height())) {
                            throw cant;
                        }
                    }
                    else if (!secondary[id] && mc.hasMerged) {
                        throw cant;
                    }
                });
            } catch(ex) {
                if (ex !== cant) {
                    throw ex;
                }
                return {
                    code: "cantSortMixedCells",
                    message: "Unsupported for range containing cells of different shapes."
                };
            }
            return false;
        },

        sort: function(spec) {
            var reason = this.cantSort();
            if (reason) {
                throw new Error(reason.message);
            }

            if (spec === undefined) {
                spec = { column: 0 };
            }

            spec = spec instanceof Array ? spec : [spec];

            this._sheet._sortBy(this._ref.toRangeRef(), spec.map(function(spec, index) {
                if (typeof spec === "number") {
                    spec = { column: spec };
                }

                return {
                    index: spec.column === undefined ? index : spec.column,
                    ascending: spec.ascending === undefined ? true : spec.ascending
                };
            }));

            return this;
        },

        isFilterable: function() {
            return !(this._ref instanceof UnionRef);
        },

        filter: function(spec) {
            if (this._ref instanceof UnionRef) {
                throw new Error("Unsupported for multiple ranges.");
            }

            if (spec === false) {
                this.clearFilters();
            } else {
                spec = spec === true ? [] : spec instanceof Array ? spec : [spec];

                this._sheet._filterBy(this._ref.toRangeRef(), spec.map(function(spec, index) {
                    return {
                        index: spec.column === undefined ? index : spec.column,
                        filter: spec.filter
                    };
                }));
            }

            return this;
        },

        clearFilter: function(spec) {
            this._sheet.clearFilter(spec);
        },

        clearFilters: function() {
            var filter = this._sheet.filter();
            var spec = [];

            if (filter) {
                for (var i = 0; i < filter.columns.length; i++) {
                    spec.push(filter.columns[i].index);
                }

                this._sheet.batch(function() {
                    this.clearFilter(spec);
                    this._filter = null;
                }, { layout: true, filter: true });
            }
        },

        hasFilter: function() {
            var filter = this._sheet.filter();
            return !!filter;
        },

        leftColumn: function() {
            return new Range(this._ref.leftColumn(), this._sheet);
        },

        rightColumn: function() {
            return new Range(this._ref.rightColumn(), this._sheet);
        },

        topRow: function() {
            return new Range(this._ref.topRow(), this._sheet);
        },

        bottomRow: function() {
            return new Range(this._ref.bottomRow(), this._sheet);
        },

        column: function(column) {
            return new Range(this._ref.toColumn(column), this._sheet);
        },

        row: function(row) {
            return new Range(this._ref.toRow(row), this._sheet);
        },

        forEachRow: function(callback) {
            this._ref.forEachRow(function(ref) {
                callback(new Range(ref, this._sheet));
            }.bind(this));
        },

        forEachColumn: function(callback) {
            this._ref.forEachColumn(function(ref) {
                callback(new Range(ref, this._sheet));
            }.bind(this));
        },

        sheet: function() {
            return this._sheet;
        },

        topLeft: function() {
            return this._ref.toRangeRef().topLeft;
        },

        intersectingMerged: function() {
            var sheet = this._sheet;
            var mergedCells = [];

            sheet._mergedCells.forEach(function(ref) {
                if (ref.intersects(this._ref)) {
                    mergedCells.push(ref.toString());
                }
            }.bind(this));

            return mergedCells;
        },

        getState: function(propertyName) {
            var topLeft = this._ref.first();
            var state = {
                ref     : topLeft,
                data    : [],
                origRef : this._ref,

                // save row heights
                rows    : this._sheet._rows.getState()
            };
            var properties;
            if (!propertyName) {
                properties = kendo.spreadsheet.ALL_PROPERTIES;
                state.mergedCells = this.intersectingMerged();
            } else if (propertyName === "input") {
                properties = ["value", "formula"];
            } else if (propertyName === "border") {
                properties = ["borderLeft", "borderTop", "borderRight", "borderBottom"];
            } else {
                properties = [propertyName];
            }

            var data = state.data;
            this.forEachCell(function(row, col, cell) {
                var cellState = {};
                var dr = row - topLeft.row;
                var dc = col - topLeft.col;
                if (!data[dr]) {
                    data[dr] = [];
                }
                data[dr][dc] = cellState;

                properties.forEach(function(property) {
                    var value = typeof cell[property] == "undefined" ? null : cell[property];
                    if (value instanceof kendo.spreadsheet.calc.runtime.Formula ||
                        value instanceof kendo.spreadsheet.validation.Validation)
                    {
                        value = value.deepClone();
                    }
                    cellState[property] = value;
                });
            });

            return state;
        },

        setState: function(state, clipboard) {
            var sheet = this._sheet;
            var origin = this._ref.first();
            var rowDelta = state.ref.row - origin.row;
            var colDelta = state.ref.col - origin.col;
            var internalClipboard = clipboard && !clipboard.isExternal();
            var externalClipboard = clipboard && !internalClipboard;

            sheet.batch(function() {
                if (state.mergedCells) {
                    this.unmerge();
                }

                if (!clipboard) {
                    // restore row heights.  they won't be available
                    // when this function is called from the clipboard
                    // code.
                    this._sheet._rows.setState(state.rows);
                }

                var row = origin.row;
                var hasFilter = this.hasFilter();
                state.data.forEach(function(data, dr){
                    if (hasFilter && internalClipboard && sheet.isHiddenRow(state.ref.row + dr)) {
                        return;
                    }
                    var col = origin.col;
                    data.forEach(function(cellState, dc){
                        if (hasFilter && internalClipboard && sheet.isHiddenColumn(state.ref.col + dc)) {
                            return;
                        }
                        var range = clipboard ? sheet.range(row, col)
                            : sheet.range(origin.row + dr, origin.col + dc);
                        if (range.enable()) {
                            for (var property in cellState) {
                                if (property != "value") {
                                    // make sure value comes last (after the loop),
                                    // because if we set value here and get get to
                                    // formula later and cellState.formula is null,
                                    // it'll clear the value.

                                    // when pasting, do not copy "disabled" state
                                    if (!(clipboard && property == "enable")) {
                                        range._set(property, cellState[property]);
                                    }
                                }
                            }
                            if (!cellState.formula) {
                                // only need to set the value if we don't have a
                                // formula.  Go through the lower level setter rather
                                // than range.value(...), because range.value will clear
                                // the formula!  chicken and egg issues.
                                if (externalClipboard) {
                                    // https://github.com/telerik/kendo-ui-core/issues/1688
                                    // if we have a paste from external source, we should parse the
                                    // value as if it were inputted.  This allows to treat numbers
                                    // as numbers, or `=sum(a1:b2)` as formula (Google Sheets does
                                    // the same).  A difference though is that we can't store an
                                    // invalid Formula and display #ERROR, like G.S. does, so in
                                    // case of a parse error we'll just set the value as string.
                                    try {
                                        if (cellState.value == null) { // jshint ignore:line
                                            range._set("value", null);
                                        } else {
                                            range.input(cellState.value);
                                        }
                                    } catch(ex) {
                                        range._set("value", cellState.value);
                                    }
                                } else {
                                    range._set("value", cellState.value);
                                }
                            }
                        }
                        col++;
                    });
                    row++;
                });

                if (state.mergedCells) {
                    state.mergedCells.forEach(function(merged) {
                        merged = sheet._ref(merged).relative(rowDelta, colDelta, 3);
                        sheet.range(merged).merge();
                    }, this);
                }
            }.bind(this), { recalc: true, ref: this._ref });
        },

        _adjustRowHeight: function() {
            var that = this;
            var sheet = that._sheet;
            var mc = sheet._getMergedCells(that._ref.toRangeRef());
            var primary = mc.primary;
            var secondary = mc.secondary;

            sheet.batch(function() {
                that.forEachRow(function(rowRange){
                    var row = rowRange._ref.topLeft.row;
                    var height = sheet.rowHeight(row);
                    if (!height) {
                        // do not adjust if hidden.
                        // https://github.com/telerik/kendo-ui-core/issues/6272
                        // (case 2)
                        return;
                    }
                    rowRange.forEachCell(function(row, col, cell){
                        var id = new CellRef(row, col).print();
                        if (secondary[id]) {
                            return;
                        }
                        var merged = primary[id];
                        var width;
                        if (merged) {
                            width = sheet._columns.sum(merged.topLeft.col,
                                                       merged.bottomRight.col);
                        } else {
                            width = sheet.columnWidth(col);
                        }
                        var data = cell.value;
                        if (cell.format && data != null) { // jshint ignore:line
                            data = kendo.spreadsheet.formatting.format(data, cell.format);
                        }
                        var textHeight = kendo.spreadsheet.util.getTextHeight(
                            data, width, cell.fontFamily, cell.fontSize, cell.wrap);
                        height = Math.max(height, textHeight);
                    });
                    sheet.rowHeight(row, height);
                });
            }, { layout: true });
        },

        forEachCell: function(callback) {
            this._ref.forEach(function(ref) {
                this._sheet.forEach(ref.toRangeRef(), callback.bind(this));
            }.bind(this));
        },

        hasValue: function() {
            var defStyle = this._sheet._defaultCellStyle;
            return kendo.util.withExit(function(exit){
                this.forEachCell(function(row, col, cell) {
                    // we must not consider cells that only have same values
                    // as defaultCellStyle, or otherwise we will forbid
                    // inserting rows/cols in an empty sheet.
                    for (var key in cell) {
                        var val = cell[key];
                        if (val !== undefined && val !== null && val !== defStyle[key]) {
                            exit(true);
                        }
                    }
                });
            }, this);
        },

        wrap: function(flag) {
            if (flag === undefined) {
                return !!this._property("wrap");
            }
            this._property("wrap", flag);
            if (flag !== null) {
                this._adjustRowHeight();
            }
            return this;
        },

        fontSize: function(size) {
            if (size === undefined) {
                return this._property("fontSize");
            }
            this._property("fontSize", size);
            if (size !== null) {
                this._adjustRowHeight();
            }
            return this;
        },

        draw: function(options, callback) {
            this._sheet.draw(this, options, callback);
        },

        insideBorders: function(value) {
            return this.insideVerticalBorders(value).insideHorizontalBorders(value);
        },

        insideVerticalBorders: function(value) {
            this._ref.forEach(function(ref){
                if (ref instanceof RangeRef && ref.width() > 1) {
                    ref = ref.clone();
                    ref.topLeft.col++;
                    this._sheet.range(ref)._set("vBorders", value);
                }
            }, this);
            return this;
        },

        insideHorizontalBorders: function(value) {
            this._ref.forEach(function(ref){
                if (ref instanceof RangeRef && ref.height() > 1) {
                    ref = ref.clone();
                    ref.topLeft.row++;
                    this._sheet.range(ref)._set("hBorders", value);
                }
            }, this);
            return this;
        }
    });

    function partition(begin, end, predicate) {
        while (begin <= end && predicate(begin)) {
            begin++;
        }
        if (begin > end) {
            return [];
        }
        for (var i = begin + 1; i <= end; ++i) {
            if (predicate(i)) {
                return [
                    { begin: begin, end: i - 1 }
                ].concat(partition(i + 1, end, predicate));
            }
        }
        return [{ begin: begin, end: end }];
    }

    // use $.each instead of forEach to work in oldIE
    $.each(PROPERTIES, function(i, property) {
        Range.prototype[property] = function(value) {
            return this._property(property, value);
        };
    });

    function toExcelFormat(format) {
        return format.replace(/M/g, "m").replace(/'/g, '"').replace(/tt/, "am/pm");
    }

    function looksLikeANumber(str) {
        // XXX: could do with just a regexp instead of calling parse.
        return !(/^=/.test(str)) && (/number|percent/).test(kendo.spreadsheet.calc.parse(null, 0, 0, str).type);
    }

    var measureBox = $('<div style="position: absolute !important; top: -4000px !important; height: auto !important;' +
                        'padding: 1px 3px !important; box-sizing: border-box; margin: 0 !important; border: 1px solid black !important;' +
                        'line-height: normal !important; visibility: hidden !important;' +
                        'white-space: pre-wrap;"></div>'
                      )[0];

    function getTextHeight(text, width, fontFamily, fontSize, wrap) {
        var styles = {
            "baselineMarkerSize" : 0,
            "width" : (wrap === true) ? width + "px" : "auto",
            "font-size" : (fontSize || 12) + "px",
            "font-family" : fontFamily || "Arial",
            "white-space" : (wrap === true) ? "pre-wrap" : "pre",
            "overflow-wrap" : (wrap === true) ? "break-word" : "normal",
            "word-wrap" : (wrap === true) ? "break-word" : "normal"
        };

        return kendo.util.measureText(text, styles, { box: measureBox, normalizeText: false }).height;
    }

    kendo.spreadsheet.util = { getTextHeight: getTextHeight };
    kendo.spreadsheet.Range = Range;
})(window.kendo);

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

// -*- fill-column: 100 -*-

(function(f, define){
    define('spreadsheet/runtime',[ "./references" ], f);
})(function(){
    "use strict";

    // WARNING: removing the following jshint declaration and turning
    // == into === to make JSHint happy will break functionality.
    /* jshint eqnull:true, newcap:false, laxbreak:true, shadow:true, validthis:true, -W054, loopfunc: true */
    /* global console */
    /* jshint latedef: nofunc */

    var calc = {};
    var spreadsheet = kendo.spreadsheet;
    spreadsheet.calc = calc;
    var exports = calc.runtime = {};
    var Class = kendo.Class;

    var Ref = spreadsheet.Ref;
    var CellRef = spreadsheet.CellRef;
    var RangeRef = spreadsheet.RangeRef;
    var UnionRef = spreadsheet.UnionRef;
    var NULL = spreadsheet.NULLREF;

    /* -----[ Errors ]----- */

    function CalcError(code) {
        if (code instanceof CalcError) {
            return code;
        }
        this.code = code;
    }

    CalcError.prototype.toString = function() {
        return "#" + this.code + (this.code == "NAME" ? "?" : "!");
    };

    /* -----[ Context ]----- */

    var Context = Class.extend({
        init: function Context(callback, formula, ss, parent) {
            this.callback = callback;
            this.formula = formula;
            this.ss = ss;
            this.parent = parent;
        },

        resolve: function(val) {
            var self = this;
            if (val instanceof Ref) {
                self.resolveCells([ val ], function(){
                    self._resolve(val);
                });
            } else {
                self._resolve(val);
            }
        },

        error: function(val) {
            return new CalcError(val);
        },

        _resolve: function(val) {
            if (val === undefined) {
                val = null;
            } else if (Array.isArray(val)) {
                val = this.asMatrix(val);
            } else {
                val = maybeRoundFloatErrors(val);
            }
            var f = this.formula;
            if (f.arrayFormulaRange) {
                // when this is an array formula, make sure we return a Matrix.  The value already
                // *should* be a Matrix, so this won't incur speed penalty in normal cases.
                val = this.asMatrix(val) || this.asMatrix([[ val ]]);
            } else if (val instanceof RangeRef) {
                val = this._arrayArg(val);
            }
            f.value = val;
            if (this.ss.onFormula(f) && this.callback) {
                this.callback.call(f, val);
            }
        },

        resolveCells: function(a, f) {
            var context = this, formulas = [];

            (function loop(a){
                for (var i = 0; i < a.length; ++i) {
                    var x = a[i];
                    if (x instanceof Ref) {
                        add(context.getRefCells(x));
                    }
                    if (Array.isArray(x)) {
                        // make sure we resolve cells in literal matrices
                        loop(x);
                    }
                }
            })(a);

            if (!formulas.length) {
                return f.call(context);
            }

            for (var pending = formulas.length, i = 0; i < formulas.length; ++i) {
                fetch(formulas[i]);
            }
            function fetch(formula) { // jshint ignore:line, because you are stupid.
                formula.exec(context.ss, function(){
                    if (!--pending) {
                        f.call(context);
                    }
                }, context);
            }
            function add(a) {
                for (var i = 0; i < a.length; ++i) {
                    var cell = a[i];
                    if (cell.formula) {
                        formulas.push(cell.formula);
                    }
                }
                return true;
            }
        },

        cellValues: function(a, wantNulls) {
            var ret = [];
            for (var i = 0; i < a.length; ++i) {
                var val = a[i];
                if (val instanceof Ref) {
                    val = this.getRefData(val, wantNulls);
                    ret = ret.concat(val);
                } else if (Array.isArray(val)) {
                    ret = ret.concat(this.cellValues(val, wantNulls));
                } else if (val instanceof Matrix) {
                    ret = ret.concat(this.cellValues(val.data, wantNulls));
                } else {
                    ret.push(val);
                }
            }
            return ret;
        },

        fetchName: function(ref, callback) {
            var f = this.formula;
            var val = this.ss.nameValue(ref, f.sheet, f.row, f.col);
            if (val instanceof Formula) {
                // clone and relocate to calling formula, so that relative references in a named
                // formula would work as expected.
                val = val.clone(f.sheet, f.row, f.col, true);

                // XXX: I don't like this dependency here; basically we only need ss.onFormula to
                // return true and do nothing else.
                var ss = new spreadsheet.ValidationFormulaContext(this.ss.workbook);

                val.exec(ss, callback, this);
            } else {
                if (val instanceof Ref) {
                    // relocate for relative refs
                    val = val.absolute(f.row, f.col);
                    if (val instanceof RangeRef && this.ss.isMerged(val)) {
                        val = val.topLeft;
                    }
                    if (!val.sheet) {
                        val.sheet = f.sheet;
                    }
                }
                callback(val == null ? new CalcError("NAME") : val);
            }
        },

        force: function(val) {
            if (val instanceof Ref) {
                return this.getRefData(val);
            }
            return val;
        },

        func: function(fname, callback, args) {
            fname = fname.toLowerCase();
            var f = FUNCS[fname];
            if (f) {
                return f.call(this, callback, args);
            }
            callback(new CalcError("NAME"));
        },

        bool: function(val) {
            if (val instanceof Ref) {
                val = this.getRefData(val);
            }
            if (typeof val == "string") {
                return val.toLowerCase() == "true";
            }
            if (typeof val == "number") {
                return val !== 0;
            }
            if (typeof val == "boolean") {
                return val;
            }
            return val != null;
        },

        _arrayArg: function(ref) { // not necessarily a reference though
            var f = this.formula;
            if (!f.arrayFormulaRange && ref instanceof RangeRef) {
                // if formula wasn't saved with Ctrl-Shift-Enter but a range is passed, Excel does
                // something special:
                //
                // - if range is Wx1 (horizontal array) and current formula resides within the
                //   horizontal bounds of the range, the appropriate cell is selected.  Example:
                //   A1..D1 contain 1, 2, 3, 4 and we have in B2: =A1:D1, then B2 will get 2 (the
                //   value in A2).  If the same formula is typed outside the horizontal span of the
                //   range, say in E2: =A1:D1, then #VALUE! is returned.
                //
                // - similarly, if the range is 1xH (vertical array), the formula must reside within
                //   the vertical bounds of the range and it gets the corresponding cell; otherwise,
                //   #VALUE!.
                if (ref.height() == 1 && f.col >= ref.topLeft.col && f.col <= ref.bottomRight.col) {
                    return this.getRefData(new CellRef(ref.topLeft.row, f.col).setSheet(ref.sheet));
                }
                if (ref.width() == 1 && f.row >= ref.topLeft.row && f.row <= ref.bottomRight.row) {
                    return this.getRefData(new CellRef(f.row, ref.topLeft.col).setSheet(ref.sheet));
                }
                return new CalcError("VALUE");
            } else {
                return this.asMatrix(ref);
            }
        },

        asMatrix: function(range) {
            if (range instanceof Matrix) {
                return range;
            }
            var self = this;
            if (range instanceof RangeRef) {
                var tl = range.topLeft;
                var top = tl.row, left = tl.col;
                var cells = self.getRefCells(range);
                var m = new Matrix(self);
                if (isFinite(range.width())) {
                    m.width = range.width();
                }
                if (isFinite(range.height())) {
                    m.height = range.height();
                }
                if (!isFinite(top)) {
                    top = 0;
                }
                if (!isFinite(left)) {
                    left = 0;
                }
                cells.forEach(function(cell){
                    m.set(cell.row - top,
                          cell.col - left,
                          cell.value);
                });
                return m;
            }
            if (Array.isArray(range) && range.length > 0) {
                var m = new Matrix(self), row = 0;
                range.forEach(function(line){
                    var col = 0;
                    var h = 1;
                    line.forEach(function(el){
                        var isRange = el instanceof RangeRef;
                        if (el instanceof Ref && !isRange) {
                            el = self.getRefData(el);
                        }
                        if (isRange || Array.isArray(el)) {
                            el = self.asMatrix(el);
                        }
                        if (el instanceof Matrix) {
                            el.each(function(el, r, c){
                                m.set(row + r, col + c, el);
                            });
                            h = Math.max(h, el.height);
                            col += el.width;
                        } else {
                            if(typeof el === "string" && el.length && !isNaN(el)) {
                                el = Number(el);
                            }

                            m.set(row, col++, el);
                        }
                    });
                    row += h;
                });
                return m;
            }
        },

        getRefCells: function(refs, hiddenInfo, wantNulls) {
            var f = this.formula;
            return this.ss.getRefCells(refs, hiddenInfo, f.sheet, f.row, f.col, wantNulls);
        },

        getRefData: function(ref, wantNulls) {
            var f = this.formula;
            return this.ss.getData(ref, f.sheet, f.row, f.col, wantNulls);
        },

        workbook: function() {
            return this.ss.workbook;
        }
    });

    var Matrix = Class.extend({
        init: function Matrix(context) {
            this.context = context;
            this.height = 0;
            this.width = 0;
            this.data = [];
        },
        clone: function() {
            var m = new Matrix(this.context);
            m.height = this.height;
            m.width = this.width;
            m.data = this.data.map(function(row){ return row.slice(); });
            return m;
        },
        get: function(row, col) {
            var line = this.data[row];
            var val = line ? line[col] : null;
            return val instanceof Ref ? this.context.getRefData(val) : val;
        },
        getNA: function(row, col) {
            if (row < this.height && col < this.width) {
                return this.get(row, col);
            }
            return new CalcError("N/A");
        },
        set: function(row, col, data) {
            var line = this.data[row];
            if (line == null) {
                line = this.data[row] = [];
            }
            line[col] = data;
            if (row >= this.height) {
                this.height = row + 1;
            }
            if (col >= this.width) {
                this.width = col + 1;
            }
        },
        each: function(f, includeEmpty) {
            for (var row = 0; row < this.height; ++row) {
                for (var col = 0; col < this.width; ++col) {
                    var val = this.get(row, col);
                    if (includeEmpty || val != null) {
                        val = f.call(this.context, val, row, col);
                        if (val !== undefined) {
                            return val;
                        }
                    }
                }
            }
        },
        map: function(f, includeEmpty) {
            var m = new Matrix(this.context);
            this.each(function(el, row, col){
                // here `this` is actually the context
                m.set(row, col, f.call(this, el, row, col));
            }, includeEmpty);
            return m;
        },
        eachRow: function(f) {
            for (var row = 0; row < this.height; ++row) {
                var val = f.call(this.context, row);
                if (val !== undefined) {
                    return val;
                }
            }
        },
        eachCol: function(f) {
            for (var col = 0; col < this.width; ++col) {
                var val = f.call(this.context, col);
                if (val !== undefined) {
                    return val;
                }
            }
        },
        mapRow: function(f) {
            var m = new Matrix(this.context);
            this.eachRow(function(row){
                m.set(row, 0, f.call(this.context, row));
            });
            return m;
        },
        mapCol: function(f) {
            var m = new Matrix(this.context);
            this.eachCol(function(col){
                m.set(0, col, f.call(this.context, col));
            });
            return m;
        },
        toString: function() {
            return JSON.stringify(this.data);
        },
        transpose: function() {
            var m = new Matrix(this.context);
            this.each(function(el, row, col){
                m.set(col, row, el);
            });
            return m;
        },
        unit: function(n) {
            this.width = this.height = n;
            var a = this.data = new Array(n);
            for (var i = n; --i >= 0;) {
                var row = a[i] = new Array(n);
                for (var j = n; --j >= 0;) {
                    row[j] = i == j ? 1 : 0;
                }
            }
            return this;
        },
        multiply: function(b) {
            var a = this, m = new Matrix(a.context);
            for (var row = 0; row < a.height; ++row) {
                for (var col = 0; col < b.width; ++col) {
                    var s = 0;
                    for (var i = 0; i < a.width; ++i) {
                        var va = a.get(row, i);
                        var vb = b.get(i, col);
                        if (typeof va != "number" || typeof vb != "number") {
                            throw new CalcError("VALUE");
                        }
                        s += va * vb;
                    }
                    m.set(row, col, s);
                }
            }
            return m;
        },
        adds: function(b, s) {
            var a = this, m = new Matrix(a.context);
            var sign = s ? -1 : 1;
            for (var row = 0; row < a.height; ++row) {
                for (var col = 0; col < a.width; ++col) {
                    var x = a.get(row, col),
                        y = b.get(row, col);
                    m.set(row, col, x + sign * y);
                }
            }
            return m;
        },
        determinant: function() {
            var a = this.clone().data;
            var n = a.length;
            var d = 1, C, L, i, k;
            for (C = 0; C < n; C++) {
                for (L = C; (L < n) && (!a[L][C]); L++) {}
                if (L == n) {
                    return 0;
                }
                if (L != C) {
                    d = -d;
                    for (k = C; k < n; k++) {
                        var t = a[C][k];
                        a[C][k] = a[L][k];
                        a[L][k] = t;
                    }
                }
                for (i = C+1; i < n; i++) {
                    for (k = C+1; k < n; k++) {
                        a[i][k] -= a[C][k] * a[i][C] / a[C][C];
                    }
                }
                d *= a[C][C];
            }
            return d;
        },
        inverse: function() {
            var n = this.width;
            var m = this.augment(new Matrix(this.context).unit(n));
            var a = m.data;
            var tmp;

            // Gaussian elimination
            // https://en.wikipedia.org/wiki/Gaussian_elimination#Finding_the_inverse_of_a_matrix

            // 1. Get zeros below main diagonal
            for (var k = 0; k < n; ++k) {
                var imax = argmax(k, n, function(i){ return a[i][k]; });
                if (!a[imax][k]) {
                    return null; // singular matrix
                }
                if (k != imax) {
                    tmp = a[k];
                    a[k] = a[imax];
                    a[imax] = tmp;
                }
                for (var i = k+1; i < n; ++i) {
                    for (var j = k+1; j < 2*n; ++j) {
                        a[i][j] -= a[k][j] * a[i][k] / a[k][k];
                    }
                    a[i][k] = 0;
                }
            }

            // 2. Get 1-s on main diagonal, dividing by pivot
            for (var i = 0; i < n; ++i) {
                for (var f = a[i][i], j = 0; j < 2*n; ++j) {
                    a[i][j] /= f;
                }
            }

            // 3. Get zeros above main diagonal.  Actually, we only care to compute the right side
            // here (that will be the inverse), so in the inner loop below we go while j >= n,
            // instead of j >= k.
            for (var k = n; --k >= 0;) {
                for (var i = k; --i >= 0;) {
                    if (a[i][k]) {
                        for (var j = 2*n; --j >= n;) {
                            a[i][j] -= a[k][j] * a[i][k];
                        }
                    }
                }
            }

            return m.slice(0, n, n, n);
        },
        augment: function(m) {
            var ret = this.clone(), n = ret.width;
            m.each(function(val, row, col){
                ret.set(row, col + n, val);
            });
            return ret;
        },
        slice: function(row, col, height, width) {
            var m = new Matrix(this.context);
            for (var i = 0; i < height; ++i) {
                for (var j = 0; j < width; ++j) {
                    m.set(i, j, this.get(row + i, col + j));
                }
            }
            return m;
        }

        // XXX: debug
        // dump: function() {
        //     this.data.forEach(function(row){
        //         console.log(row.map(function(val){
        //             var str = val.toFixed(3).replace(/\.?0*$/, function(s){
        //                 return [ "", " ", "  ", "   ", "    " ][s.length];
        //             });
        //             if (val >= 0) { str = " " + str; }
        //             return str;
        //         }).join("  "));
        //     });
        // }
    });

    function argmax(i, end, f) {
        var max = f(i), pos = i;
        while (++i < end) {
            var v = f(i);
            if (v > max) {
                max = v;
                pos = i;
            }
        }
        return pos;
    }

    /* -----[ Formula ]----- */

    var Formula = Class.extend({
        init: function Formula(refs, handler, printer, sheet, row, col, arrayFormulaRange){
            this.refs = refs;
            this.handler = handler;
            this.print = printer;
            this.absrefs = null;
            this.sheet = sheet;
            this.row = row;
            this.col = col;
            this.onReady = [];
            this.pending = false;
            this.arrayFormulaRange = arrayFormulaRange;
        },
        setArrayFormulaRange: function(ref) {
            this.arrayFormulaRange = ref.clone().setSheet(this.sheet);
        },
        clone: function(sheet, row, col, forceRefs) {
            var lcsheet = sheet.toLowerCase();
            var refs = this.refs;
            var range = this.arrayFormulaRange;
            if (forceRefs || lcsheet != this.sheet.toLowerCase()) {
                refs = refs.map(function(ref){
                    if (!ref.hasSheet() && (!ref.sheet || ref.sheet.toLowerCase() != lcsheet)) {
                        ref = ref.clone().setSheet(sheet);
                    }
                    return ref;
                });
                if (range) {
                    range = range.clone().setSheet(sheet);
                }
            }
            return new Formula(refs, this.handler, this.print, sheet, row, col, range);
        },
        deepClone: function() {
            var refs = this.refs.map(function(ref){ return ref.clone(); });
            return new Formula(refs, this.handler, this.print, this.sheet, this.row, this.col, this.arrayFormulaRange);
        },
        resolve: function(val) {
            this.pending = false;
            this.onReady.forEach(function(callback){
                callback(val);
            });
        },
        exec: function(ss, callback, parentContext) {
            if ("value" in this) {
                if (callback) {
                    callback(this.value);
                }
            } else {
                if (callback) {
                    this.onReady.push(callback);
                }

                var ctx = new Context(this.resolve, this, ss, parentContext);
                var level = 0;
                // if the call chain leads back to this same formula, we have a circular dependency.
                while (parentContext) {
                    if (parentContext.formula === this) {
                        this.pending = false;
                        ctx.resolve(new CalcError("CIRCULAR"));
                        return;
                    }
                    parentContext = parentContext.parent;
                    ++level;
                }

                // pending is still useful for ASYNC formulas
                if (this.pending) {
                    return;
                }
                this.pending = true;

                var next = function() {
                    // compute and cache the absolute references
                    if (!this.absrefs) {
                        this.absrefs = this.refs.map(function(ref){
                            return ref.absolute(this.row, this.col);
                        }, this);
                    }

                    // finally invoke the handler given to us by the compiler in calc.js
                    this.handler.call(ctx);
                }.bind(this);

                if (level < 20) {
                    next();
                } else {
                    setTimeout(next, 0);
                }
            }
        },
        reset: function() {
            this.onReady = [];
            this.pending = false;
            delete this.value;
        },
        renameSheet: function(oldSheetName, newSheetName) {
            oldSheetName = oldSheetName.toLowerCase();
            this.absrefs = null;
            if (this.sheet.toLowerCase() == oldSheetName) {
                this.sheet = newSheetName;
            }
            this.refs.forEach(function(ref){
                ref.renameSheet(oldSheetName, newSheetName);
            });
        },
        adjust: function(affectedSheet, operation, start, delta) {
            affectedSheet = affectedSheet.toLowerCase();
            var formulaRow = this.row;
            var formulaCol = this.col;
            var formulaSheet = this.sheet.toLowerCase();
            var formulaMoves = false;
            if (formulaSheet == affectedSheet) {
                // move formula if it's after the change point
                if (operation == "row" && formulaRow >= start) {
                    this.row += delta;
                    formulaMoves = true;
                }
                if (operation == "col" && formulaCol >= start) {
                    this.col += delta;
                    formulaMoves = true;
                }
            }
            var newFormulaRow = this.row;
            var newFormulaCol = this.col;
            this.absrefs = null;
            var prevRefs = this.refs;
            var modified = formulaMoves;
            this.refs = prevRefs.map(function(ref){
                var newRef = adjust(ref);
                if (!modified && !sameRef(newRef, ref)) {
                    modified = true;
                }
                return newRef;
            });

            var prevRange = this.arrayFormulaRange;
            if (prevRange) {
                this.arrayFormulaRange = adjust(prevRange);
                if (!modified && !sameRef(prevRange, this.arrayFormulaRange)) {
                    modified = true;
                }
            }

            if (modified) {
                // return a clone of the original formula.  needed to undo operations like
                // deleteRow, which can transform a reference into NULL.
                return new Formula(prevRefs, this.handler, this.print, this.sheet, formulaRow, formulaCol, prevRange);
            }

            function adjust(ref){
                if (ref === NULL) {
                    return ref;
                }
                if (ref.sheet.toLowerCase() != affectedSheet) {
                    if (formulaMoves) {
                        // a reference to another sheet should still point to the same location
                        // after adjustment; thus if row/col was removed before formula, relative
                        // references must be adjusted by delta.
                        if (operation == "row" && formulaRow >= start) {
                            ref = ref.relative(delta, 0);
                        }
                        if (operation == "col" && formulaCol >= start) {
                            ref = ref.relative(0, delta);
                        }
                    }
                    return ref;
                }
                return ref.adjust(
                    formulaRow, formulaCol,
                    newFormulaRow, newFormulaCol,
                    operation == "row",
                    start, delta
                );
            }
        },
        toString: function() {
            return this.print(this.row, this.col);
        }
    });

    function sameRef(r1, r2) {
        // note: r1.eq(r2) will not do, because it returns true for A1 and A1:A1 (CellRef
        // vs. RangeRef).  To properly undo we need to assert that the references are exactly the
        // same (including type).
        if (r1.constructor !== r2.constructor) {
            return false;
        }
        if (r1 instanceof CellRef) {
            return r1.sheet == r2.sheet
                && r1.row == r2.row
                && r1.col == r2.col
                && r1.rel == r2.rel;
        }
        if (r1 instanceof RangeRef) {
            return sameRef(r1.topLeft     , r2.topLeft)
                && sameRef(r1.bottomRight , r2.bottomRight)
                && r1.endSheet == r2.endSheet;
        }
        if (r1 instanceof UnionRef) {
            var i = r1.refs.length;
            if (i != r2.refs.length) {
                return false;
            }
            while (--i >= 0) {
                if (!sameRef(r1.refs[i], r2.refs[i])) {
                    return false;
                }
            }
        }
        return true;
    }

    // spreadsheet functions --------
    var FUNCS = Object.create(null);

    FUNCS["if"] = function(callback, args) {
        var self = this;
        var co = args[0], th = args[1], el = args[2];
        // XXX: I don't like this resolveCells here.  We should try to declare IF with
        // defineFunction.
        this.resolveCells([ co ], function(){
            var comatrix = self.asMatrix(co);
            if (comatrix) {
                // XXX: calling both branches in this case, since we'll typically need values from
                // both.  We could optimize and call them only when first needed, but oh well.
                th(function(th){
                    el(function(el){
                        var thmatrix = self.asMatrix(th);
                        var elmatrix = self.asMatrix(el);
                        callback(comatrix.map(function(val, row, col){
                            if (val instanceof CalcError) {
                                return val;
                            } else if (self.bool(val)) {
                                return thmatrix ? thmatrix.get(row, col) : th;
                            } else {
                                return elmatrix ? elmatrix.get(row, col) : el;
                            }
                        }));
                    });
                });
            } else {
                co = this.force(co);
                if (co instanceof CalcError) {
                    callback(co);
                } else if (self.bool(co)) {
                    th(callback);
                } else {
                    el(callback);
                }
            }
        });
    };

    FUNCS[""] = function(callback) {
        callback((1+Math.sqrt(5))/2);
    };

    // Lasciate ogni speranza, voi ch'entrate.
    //
    // XXX: document this function.
    function compileArgumentChecks(functionName, args) {
        var arrayArgs = "function arrayArgs(args) { var xargs = [], width = 0, height = 0, arrays = [], i = 0; ";
        var resolve = "function resolve(args, callback) { var toResolve = [], i = 0; ";
        var name, forced, main = "'use strict'; function check(args) { var stack = [], tmp, xargs = [], i = 0, m, err = 'VALUE'; ", haveForced = false;
        var canBeArrayArg = false, hasArrayArgs = false;
        main += args.map(comp).join("");
        main += "if (i < args.length) return new CalcError('N/A'); ";
        main += "return xargs; } ";
        arrayArgs += "return { args: xargs, width: width, height: height, arrays: arrays }; } ";

        var f;
        if (haveForced) {
            resolve += "this.resolveCells(toResolve, callback); } ";
            f = new Function("CalcError", "round", main + resolve + arrayArgs + " return { resolve: resolve, check: check, arrayArgs: arrayArgs };");
        } else {
            f = new Function("CalcError", "round", main + " return { check: check };");
        }
        f = f(CalcError, limitPrecision);
        if (!hasArrayArgs) {
            delete f.arrayArgs;
        }
        return f;

        function comp(x) {
            name = x[0];
            var code = "{ ";
            if (Array.isArray(name)) {
                arrayArgs += "while (i < args.length) { ";
                resolve += "while (i < args.length) { ";
                code += "xargs.push(tmp = []); stack.push(xargs); xargs = tmp; ";
                code += "while (i < args.length) { ";
                code += x.map(comp).join("");
                code += "} ";
                code += "xargs = stack.pop(); ";
                resolve += "} ";
                arrayArgs += "} ";
            } else if (name == "+") {
                arrayArgs += "while (i < args.length) { ";
                resolve += "while (i < args.length) { ";
                code += "if (i >= args.length) return new CalcError('N/A'); ";
                code += "xargs.push(tmp = []); stack.push(xargs); xargs = tmp; ";
                code += "do { ";
                code += x.slice(1).map(comp).join("");
                code += "} while (i < args.length); ";
                code += "xargs = stack.pop(); ";
                resolve += "} ";
                arrayArgs += "} ";
            } else if (name == "?") {
                // standalone assertion without a new argument
                code += "if (!(" + cond(x[1]) + ")) return new CalcError(err); ";
            } else {
                var type = x[1];
                if (Array.isArray(type) && /^#?collect/.test(type[0])) {
                    var wantNulls = /!$/.test(type[0]);
                    var n = type[2];
                    force();
                    code += "try {"
                        + "var $" + name + " = this.cellValues(args.slice(i";
                    if (n) {
                        code += ", i + " + n;
                    }
                    code += ")" + (wantNulls ? ",true" : "") + ").reduce(function(ret, $"+name+"){ ";
                    if (type[0].charAt(0) != "#") {
                        code += "if ($"+name+" instanceof CalcError) throw $"+name+"; ";
                    }
                    code += "if (" + cond(type[1]) + ") ret.push($"+name+"); ";
                    code += "return ret; ";
                    code += "}.bind(this), []); ";
                    if (n) {
                        code += "i += " + n + "; ";
                    } else {
                        code += "i = args.length; ";
                    }
                    code += "xargs.push($"+name+")"
                        + "} catch(ex) { if (ex instanceof CalcError) return ex; throw ex; } ";
                    resolve += "toResolve.push(args.slice(i)); ";
                } else if (type == "rest") {
                    code += "xargs.push(args.slice(i)); i = args.length; ";
                } else {
                    if ((canBeArrayArg = /^\*/.test(name))) {
                        hasArrayArgs = true;
                        name = name.substr(1);
                    }
                    code += "var $" + name + " = args[i++]; ";
                    var allowError = false;
                    if (/!$/.test(type)) {
                        type = type.substr(0, type.length - 1);
                        allowError = true;
                    } else {
                        code += "if ($"+name+" instanceof CalcError) return $"+name+"; ";
                    }
                    code += typeCheck(type, allowError) + "xargs.push($"+name+"); ";
                }
            }
            code += "} ";
            return code;
        }

        function force() {
            if (forced) {
                return "$"+name+"";
            }
            haveForced = true;
            forced = true;
            resolve += "toResolve.push(args[i++]); ";
            return "($"+name+" = this.force($"+name+"))";
        }

        function forceNum(round) {
            return "("
                +     (round
                       ? ("(typeof " + force() + " == 'number' ? ($"+name+" = round($"+name+"), true) : false) || ")
                       : ("(typeof " + force() + " == 'number') || "))
                +     "(typeof $"+name+" == 'boolean' ? ($"+name+" = +$" + name + ", true) : false) || "
                +     "(typeof $"+name+" == 'string' && !/^(?:=|true|false)/i.test($"+name+") ? ("
                +       "tmp = kendo.spreadsheet.calc.parse(0, 0, 0, $"+name+"), "
                +       "/^date|number|percent$/.test(tmp.type) ? ($"+name+" = +tmp.value, true) : false"
                +     ") : false)"
                +  ")";
        }

        function typeCheck(type, allowError) {
            forced = false;
            var ret = "if (!(" + cond(type) + ")) { ";
            if (forced && !allowError) {
                ret += " if ($" + name + " instanceof CalcError) return $" + name + "; ";
            }
            ret += "return new CalcError(err); } ";
            if (!forced) {
                resolve += "i++; ";
            }
            if (canBeArrayArg) {
                arrayArgs += "var $" + name + " = this._arrayArg(args[i]); "
                    + "if ($" + name + ") { "
                    + "xargs.push($" + name + "); "
                    + "width = Math.max(width, $" + name + ".width); "
                    + "height = Math.max(height, $" + name + ".height); "
                    + "arrays.push(true) } else { "
                    + "xargs.push(args[i]); "
                    + "arrays.push(false); } i++; ";
            } else {
                arrayArgs += "xargs.push(args[i++]); arrays.push(false); ";
            }
            return ret;
        }

        function cond(type) {
            if (Array.isArray(type)) {
                if (type[0] == "or") {
                    return "(" + type.slice(1).map(cond).join(") || (") + ")";
                }
                if (type[0] == "and") {
                    return "(" + type.slice(1).map(cond).join(") && (") + ")";
                }
                if (type[0] == "values") {
                    return "(" + type.slice(1).map(function(val){
                        return force() + " === " + val;
                    }).join(") || (") + ")";
                }
                if (type[0] == "null") {
                    return "(" + cond("null") + " ? (($"+name+" = " + type[1] + "), true) : false)";
                }
                if (type[0] == "between" || type[0] == "[between]") {
                    return "(" + force() + " >= " + type[1] + " && " + "$"+name+" <= " + type[2] + " ? true : ((err = 'NUM'), false))";
                }
                if (type[0] == "(between)") {
                    return "(" + force() + " > " + type[1] + " && " + "$"+name+" < " + type[2] + " ? true : ((err = 'NUM'), false))";
                }
                if (type[0] == "(between]") {
                    return "(" + force() + " > " + type[1] + " && " + "$"+name+" <= " + type[2] + " ? true : ((err = 'NUM'), false))";
                }
                if (type[0] == "[between)") {
                    return "(" + force() + " >= " + type[1] + " && " + "$"+name+" < " + type[2] + " ? true : ((err = 'NUM'), false))";
                }
                if (type[0] == "assert") {
                    var err = type[2] || "N/A";
                    return "((" + type[1] + ") ? true : (err = " + JSON.stringify(err) + ", false))";
                }
                if (type[0] == "not") {
                    return "!(" + cond(type[1]) + ")";
                }
                throw new Error("Unknown array type condition: " + type[0]);
            }
            if (type == "number" || type == "datetime") {
                return forceNum(true);
            }
            if (type == "number!") {
                return "(typeof " + force() + " == 'number' ? ($"+name+" = round($"+name+"), true) : false)";
            }
            if (type == "integer" || type == "date") {
                return "(" + forceNum() + " && (($"+name+" |= 0), true))";
            }
            if (type == "divisor") {
                return "(" + forceNum(true) + " && ($"+name+" == 0 ? ((err = 'DIV/0'), false) : true))";
            }
            if (type == "number+") {
                return "(" + forceNum(true) + " && ($"+name+" >= 0 ? true : ((err = 'NUM'), false)))";
            }
            if (type == "integer+") {
                return "(" + forceNum() + " && (($"+name+" |= 0) >= 0 ? true : ((err = 'NUM'), false)))";
            }
            if (type == "number++") {
                return "(" + forceNum(true) + " && ($"+name+" > 0 ? true : ((err = 'NUM'), false)))";
            }
            if (type == "integer++") {
                return "(" + forceNum() + " && (($"+name+" |= 0) > 0 ? true : ((err = 'NUM'), false)))";
            }
            if (type == "string") {
                return "((typeof " + force() + " == 'string' || typeof $"+name+" == 'boolean' || typeof $"+name+" == 'number') ? ($"+name+" += '', true) : ($"+name+" === undefined ? (($"+name+" = ''), true) : false))";
            }
            if (type == "boolean") {
                return "(typeof " + force() + " == 'boolean')";
            }
            if (type == "logical") {
                return "(typeof " + force() + " == 'boolean' || (typeof $"+name+" == 'number' ? ($"+name+" = !!$"+name+", true) : false))";
            }
            if (type == "matrix") {
                force();
                return "((m = this.asMatrix($"+name+")) ? ($"+name+" = m) : false)";
            }
            if (type == "#matrix") {
                return "((m = this.asMatrix($"+name+")) ? ($"+name+" = m) : false)";
            }
            if (type == "ref") {
                return "($"+name+" instanceof kendo.spreadsheet.Ref)";
            }
            if (type == "area") {
                return "($"+name+" instanceof kendo.spreadsheet.CellRef || $"+name+" instanceof kendo.spreadsheet.RangeRef)";
            }
            if (type == "cell") {
                return "($"+name+" instanceof kendo.spreadsheet.CellRef)";
            }
            if (type == "null") {
                return "(" + force() + " == null)";
            }
            if (type == "anyvalue") {
                return "(" + force() + " != null && i <= args.length)";
            }
            if (type == "forced") {
                return "(" + force() + ", i <= args.length)";
            }
            if (type == "anything") {
                return "(i <= args.length)";
            }
            if (type == "blank") {
                return "(" + force() + " == null || $"+name+" === '')";
            }
            throw new Error("Can't check for type: " + type);
        }
    }

    function limitPrecision(num) {
        return num === parseInt(num, 10) ? num : +num.toPrecision(14);
    }

    function maybeRoundFloatErrors(num) {
        if (typeof num == "number") {
            return limitPrecision(num);
        } else {
            return num;
        }
    }

    function withErrorHandling(obj, f, args) {
        if (args instanceof CalcError) {
            return args;
        }
        try {
            return f.apply(obj, args);
        } catch(ex) {
            if (ex instanceof CalcError) {
                return ex;
            } else {
                throw ex;
            }
        }
    }

    function makeSyncFunction(handler, resolve, check, arrayArgs) {
        return function(callback, args) {
            function doit() {
                if (arrayArgs) {
                    var x = arrayArgs.call(this, args);
                    args = x.args;
                    if (x.width > 0 && x.height > 0) {
                        var result = new Matrix(this);
                        for (var row = 0; row < x.height; ++row) {
                            for (var col = 0; col < x.width; ++col) {
                                var xargs = [];
                                for (var i = 0; i < args.length; ++i) {
                                    if (x.arrays[i]) {
                                        xargs[i] = args[i].getNA(row, col);
                                    } else {
                                        xargs[i] = args[i];
                                    }
                                }
                                xargs = check.call(this, xargs);
                                result.set(row, col, withErrorHandling(this, handler, xargs));
                            }
                        }
                        return callback(result);
                    }
                }
                var xargs = check.call(this, args);
                callback(withErrorHandling(this, handler, xargs));
            }
            if (resolve) {
                resolve.call(this, args, doit);
            } else {
                doit.call(this);
            }
        };
    }

    function makeAsyncFunction(handler, resolve, check, arrayArgs) {
        return function(callback, args) {
            function doit() {
                if (arrayArgs) {
                    var x = arrayArgs.call(this, args);
                    args = x.args;
                    if (x.width > 0 && x.height > 0) {
                        var result = new Matrix(this);
                        var count = x.width * x.height;
                        var makeCallback = function(row, col) {
                            return function(value) {
                                result.set(row, col, value);
                                --count;
                                if (count === 0) {
                                    return callback(result);
                                }
                            };
                        };
                        for (var row = 0; row < x.height && count > 0; ++row) {
                            for (var col = 0; col < x.width && count > 0; ++col) {
                                var xargs = [];
                                for (var i = 0; i < args.length; ++i) {
                                    if (x.arrays[i]) {
                                        xargs[i] = args[i].getNA(row, col);
                                    } else {
                                        xargs[i] = args[i];
                                    }
                                }
                                xargs = check.call(this, xargs);
                                if (xargs instanceof CalcError) {
                                    result.set(row, col, xargs);
                                    --count;
                                    if (count === 0) {
                                        return callback(result);
                                    }
                                } else {
                                    xargs.unshift(makeCallback(row, col));
                                    handler.apply(this, xargs);
                                }
                            }
                        }
                        return;
                    }
                }
                var x = check.call(this, args);
                if (x instanceof CalcError) {
                    callback(x);
                } else {
                    x.unshift(callback);
                    handler.apply(this, x);
                }
            }
            if (resolve) {
                resolve.call(this, args, doit);
            } else {
                doit.call(this);
            }
        };
    }

    function defineFunction(name, func) {
        name = name.toLowerCase();
        FUNCS[name] = func;
        return {
            args: function(args, log) {
                var code = compileArgumentChecks(name, args);
                // XXX: DEBUG
                if (log) {
                    if (code.arrayArgs) {console.log(code.arrayArgs.toString());}
                    if (code.resolve) {console.log(code.resolve.toString());}
                    if (code.check) {console.log(code.check.toString());}
                }
                var f = FUNCS[name] = makeSyncFunction(func, code.resolve, code.check, code.arrayArgs);
                f.kendoSpreadsheetArgs = args;
                return this;
            },
            argsAsync: function(args, log) {
                var code = compileArgumentChecks(name, args);
                // XXX: DEBUG
                if (log) {
                    if (code.arrayArgs) {console.log(code.arrayArgs.toString());}
                    if (code.resolve) {console.log(code.resolve.toString());}
                    if (code.check) {console.log(code.check.toString());}
                }
                var f = FUNCS[name] = makeAsyncFunction(func, code.resolve, code.check, code.arrayArgs);
                f.kendoSpreadsheetArgs = args;
                return this;
            }
        };
    }

    /* -----[ date calculations ]----- */

    // Julian days algorithms from http://www.hermetic.ch/cal_stud/jdn.htm#comp

    function dateToJulianDays(y, m, d) {
        m++;
        return ((1461 * (y + 4800 + ((m - 14) / 12 | 0))) / 4 | 0) +
            ((367 * (m - 2 - 12 * ((m - 14) / 12 | 0))) / 12 | 0) -
            ((3 * (((y + 4900 + ((m - 14) / 12 | 0)) / 100 | 0))) / 4 | 0) +
            d - 32075;
    }

    function julianDaysToDate(jd) {
        var l, n, j, i, m, d, y;
        l = jd + 68569;
        n = (4 * l) / 146097 | 0;
        l = l - ((146097 * n + 3) / 4 | 0);
        i = (4000 * (l + 1) / 1461001) | 0;
        l = l - ((1461 * i) / 4 | 0) + 31;
        j = (80 * l) / 2447 | 0;
        d = l - ((2447 * j) / 80 | 0);
        l = j / 11 | 0;
        m = j + 2 - (12 * l);
        y = 100 * (n - 49) + i + l;
        m--;
        return {
            year  : y,
            month : m,
            date  : d,
            day   : (jd + 1) % 7,
            ord   : ORDINAL_ADD_DAYS[isLeapYear(y)][m] + d
        };
    }

    // This uses the Google Spreadsheet approach: treat 1899-12-31 as day 1, allowing to avoid
    // implementing the "Leap Year Bug" yet still be Excel compatible for dates starting 1900-03-01.
    var BASE_DATE = dateToJulianDays(1900, 0, -1);

    var DAYS_IN_MONTH = [ 31, 28, 31,
                          30, 31, 30,
                          31, 31, 30,
                          31, 30, 31 ];

    var ORDINAL_ADD_DAYS = [
        [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], // non-leap year
        [ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 ]  // leap year
    ];

    function isLeapYear(yr) {
        if (yr % 4) {
            return 0;
        }
        if (yr % 100) {
            return 1;
        }
        if (yr % 400) {
            return 0;
        }
        return 1;
    }

    function daysInYear(yr) {
        return isLeapYear(yr) ? 366 : 365;
    }

    function daysInMonth(yr, mo) {
        return (isLeapYear(yr) && mo == 1) ? 29 : DAYS_IN_MONTH[mo];
    }

    function validDate(yr, mo, da) {
        return mo >= 1 && mo <= 12 && da >= 1 && da <= daysInMonth(yr, mo - 1);
    }

    function unpackDate(serial) {
        return julianDaysToDate((serial | 0) + BASE_DATE);
    }

    function packDate(year, month, date) {
        return dateToJulianDays(year, month, date) - BASE_DATE;
    }

    var MS_IN_MIN = 60 * 1000;
    var MS_IN_HOUR = 60 * MS_IN_MIN;
    var MS_IN_DAY = 24 * MS_IN_HOUR;

    function unpackTime(serial) {
        var frac = serial - (serial|0);
        if (frac < 0) {
            frac++;
        }
        var ms = Math.round(MS_IN_DAY * frac);
        var hours = Math.floor(ms / MS_IN_HOUR);
        ms -= hours * MS_IN_HOUR;
        var minutes = Math.floor(ms / MS_IN_MIN);
        ms -= minutes * MS_IN_MIN;
        var seconds = Math.floor(ms / 1000);
        ms -= seconds * 1000;
        return {
            hours: hours,
            minutes: minutes,
            seconds: seconds,
            milliseconds: ms
        };
    }

    function serialToDate(serial) {
        var d = unpackDate(serial), t = unpackTime(serial);
        return new Date(d.year, d.month, d.date,
                        t.hours, t.minutes, t.seconds, t.milliseconds);
    }

    function packTime(hh, mm, ss, ms) {
        return (hh+(mm+(ss+ms/1000)/60)/60)/24;
    }

    function dateToSerial(date) {
        var time = packTime(date.getHours(),
                            date.getMinutes(),
                            date.getSeconds(),
                            date.getMilliseconds());
        date = packDate(date.getFullYear(),
                        date.getMonth(),
                        date.getDate());
        if (date < 0) {
            return date - 1 + time;
        } else {
            return date + time;
        }
    }

    function parseDate(str, format) {
        if (format) {
            format = kendo.spreadsheet.formatting.makeDateFormat(format);
        }
        return kendo.parseExactDate(str, format)
            || kendo.parseExactDate(str)
            || kendo.parseExactDate(str, [
                "MMMM dd yyyy",
                "MMMM dd yy",
                "MMM dd yyyy",
                "MMM dd yy",
                "dd MMMM yyyy",
                "dd MMMM yy",
                "dd MMM yyyy",
                "dd MMM yy",
                "MMMM dd, yyyy",
                "MMMM dd, yy",
                "MMM dd, yyyy",
                "MMM dd, yy",
                "MMMM dd",
                "MMM dd",
                "MMMM yyyy",
                "MMM yyyy",
                "dd MMMM",
                "dd MMM"
            ]);
    }

    /* -----[ exports ]----- */

    exports.CalcError = CalcError;
    exports.Formula = Formula;
    exports.Matrix = Matrix;

    exports.packDate = packDate;
    exports.unpackDate = unpackDate;
    exports.packTime = packTime;
    exports.unpackTime = unpackTime;
    exports.serialToDate = serialToDate;
    exports.dateToSerial = dateToSerial;
    exports.daysInMonth = daysInMonth;
    exports.validDate = validDate;
    exports.isLeapYear = isLeapYear;
    exports.daysInYear = daysInYear;
    exports.parseDate = parseDate;
    exports.limitPrecision = limitPrecision;

    spreadsheet.dateToNumber = dateToSerial;
    spreadsheet.numberToDate = serialToDate;
    spreadsheet.defineFunction = defineFunction;
    spreadsheet.CalcError = CalcError;

    exports.defineFunction = defineFunction;
    exports.defineAlias = function(alias, name) {
        var orig = FUNCS[name];
        if (!orig) {
            throw new Error("Function " + name + " is not yet defined");
        }
        if (!orig.kendoSpreadsheetAliases) {
            orig.kendoSpreadsheetAliases = [ name ];
        }
        orig.kendoSpreadsheetAliases.push(alias);
        FUNCS[alias] = orig;
    };
    exports.FUNCS = FUNCS;

    /* -----[ Excel operators ]----- */

    var NUMBER_OR_ZERO = [ "or", "number", [ "null", 0 ] ];

    var ARGS_NUMERIC = [
        [ "*a", NUMBER_OR_ZERO ],
        [ "*b", NUMBER_OR_ZERO ]
    ];

    var ARGS_ANYVALUE = [
        [ "*a", "forced" ],
        [ "*b", "forced" ]
    ];

    defineFunction("binary+", function(a, b){
        return a + b;
    }).args(ARGS_NUMERIC);

    defineFunction("binary-", function(a, b){
        return a - b;
    }).args(ARGS_NUMERIC);

    defineFunction("binary*", function(a, b){
        return a * b;
    }).args(ARGS_NUMERIC);

    defineFunction("binary/", function(a, b){
        return a / b;
    }).args([
        [ "*a", NUMBER_OR_ZERO ],
        [ "*b", "divisor" ]
    ]);

    defineFunction("binary^", function(a, b){
        return Math.pow(a, b);
    }).args(ARGS_NUMERIC);

    defineFunction("binary&", function(a, b){
        if (a == null) { a = ""; }
        if (b == null) { b = ""; }
        return "" + a + b;
    }).args([
        [ "*a", [ "or", "number", "string", "boolean", "null" ] ],
        [ "*b", [ "or", "number", "string", "boolean", "null" ] ]
    ]);

    function equals(a, b){
        a = typeof(a) === "string" ? a.toLowerCase() : a;
        b = typeof(b) === "string" ? b.toLowerCase() : b;

        // special cases
        if (a === false && b == null) { return true; }
        if (b === false && a == null) { return true; }
        if (a === 0     && b == null) { return true; }
        if (b === 0     && a == null) { return true; }
        if (a === ""    && b == null) { return true; }
        if (b === ""    && a == null) { return true; }

        return a === b;
    }

    defineFunction("binary=", equals).args(ARGS_ANYVALUE);

    defineFunction("binary<>", function(a, b){
        return !equals(a, b);
    }).args(ARGS_ANYVALUE);

    defineFunction("binary<", binaryCompare(function(a, b){
        return a < b;
    })).args(ARGS_ANYVALUE);

    defineFunction("binary<=", binaryCompare(function(a, b){
        return a <= b;
    })).args(ARGS_ANYVALUE);

    defineFunction("binary>", binaryCompare(function(a, b){
        return a > b;
    })).args(ARGS_ANYVALUE);

    defineFunction("binary>=", binaryCompare(function(a, b){
        return a >= b;
    })).args(ARGS_ANYVALUE);

    defineFunction("unary+", function(a){
        return a;
    }).args([
        [ "*a", NUMBER_OR_ZERO ]
    ]);

    defineFunction("unary-", function(a){
        return -a;
    }).args([
        [ "*a", NUMBER_OR_ZERO ]
    ]);

    defineFunction("unary%", function(a){
        return a / 100;
    }).args([
        [ "*a", NUMBER_OR_ZERO ]
    ]);

    // range operator
    defineFunction("binary:", function(a, b){
        return new RangeRef(a, b)
            .setSheet(a.sheet || this.formula.sheet, a.hasSheet());
    }).args([
        [ "a", "cell" ],
        [ "b", "cell" ]
    ]);

    // union operator
    defineFunction("binary,", function(a, b){
        return new UnionRef([ a, b ]);
    }).args([
        [ "a", "ref" ],
        [ "b", "ref" ]
    ]);

    // intersection operator
    defineFunction("binary ", function(a, b){
        return a.intersect(b);
    }).args([
        [ "a", "ref" ],
        [ "b", "ref" ]
    ]);

    /* -----[ conditionals ]----- */

    defineFunction("not", function(a){
        return !this.bool(a);
    }).args([
        [ "*a", [ "or", "anyvalue", [ "null", 0 ] ] ]
    ]);

    /* -----[ the IS* functions ]----- */

    defineFunction("isblank", function(val){
        if (val instanceof CellRef) {
            val = this.getRefData(val);
            return val == null;
        }
        return false;
    }).args([
        [ "*value", "anything!" ]
    ]);

    defineFunction("iserror", function(val){
        return val instanceof CalcError;
    }).args([
        [ "*value", "forced!" ]
    ]);

    defineFunction("iserr", function(val){
        return val instanceof CalcError && val.code != "N/A";
    }).args([
        [ "*value", "forced!" ]
    ]);

    defineFunction("isna", function(val){
        return val instanceof CalcError && val.code == "N/A";
    }).args([
        [ "*value", "forced!" ]
    ]);

    defineFunction("islogical", function(val){
        return typeof val == "boolean";
    }).args([
        [ "*value", "forced!" ]
    ]);

    defineFunction("isnontext", function(val){
        return typeof val != "string";
    }).args([
        [ "*value", "forced!" ]
    ]);

    defineFunction("istext", function(val){
        return typeof val == "string";
    }).args([
        [ "*value", "forced!" ]
    ]);

    defineFunction("isnumber", function(val){
        return typeof val == "number";
    }).args([
        [ "*value", "forced!" ]
    ]);

    defineFunction("isref", function(val){
        // apparently should return true only for cell and range
        return val instanceof CellRef || val instanceof RangeRef;
    }).args([
        [ "*value", "anything!" ]
    ]);

    /* -----[ resolve NameRef-s ]----- */

    FUNCS[",getname"] = function(callback, args) {
        this.fetchName(args[0], callback);
    };

    /// utils

    function binaryCompare(func) {
        return function(left, right){
            if (typeof left == "string" && typeof right != "string") {
                right = right == null ? "" : right + "";
            }
            if (typeof left != "string" && typeof right == "string") {
                left = left == null ? "" : left + "";
            }
            if (typeof left == "number" && right == null) {
                right = 0;
            }
            if (typeof right == "number" && left == null) {
                left = 0;
            }
            if (typeof left == "string" && typeof right == "string") {
                // string comparison is case insensitive
                left = left.toLowerCase();
                right = right.toLowerCase();
            }
            if (typeof right == typeof left) {
                return func(left, right);
            } else {
                return new CalcError("VALUE");
            }
        };
    }

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/validation',[ "./runtime" ], f);
})(function(){
    "use strict";

    var $ = kendo.jQuery;

    var spreadsheet = kendo.spreadsheet;

    var exports = {};
    spreadsheet.validation = exports;
    var calc = spreadsheet.calc;
    var Class = kendo.Class;
    var TRANSPOSE_FORMAT = "_matrix({0})";
    var DATE_FORMAT = 'DATEVALUE("{0}")';

    calc.runtime.defineFunction("_matrix", function(m){
        if (typeof m == "string") {
            // for constant list validation, Excel includes a string
            // with comma-separated values  make a Matrix from it.
            m = this.asMatrix([ m.split(/\s*,\s*/) ]);
        }
        return m;
    }).args([
        [ "m", [ "or", "matrix", "string" ] ]
    ]);

    function compileValidation(sheet, row, col, validation) {
        var validationHandler;
        var comparer;
        var parsedFromDate;
        var parsedToDate;

        if (typeof validation === "string") {
            validation = JSON.parse(validation);
        }

        if (validation.from) {
            if (validation.dataType === "list" && !validation.fromIsListValue) {
                // We need to convert the {...} validation.from value to a string, so that it would work when exported to XLSX
                if(validation.from.indexOf("{") > -1) {
                    validation.from = validation.from.replace(/\"/g,"").replace("{","\"").replace("}", "\"");
                }
                validation.from = kendo.format(TRANSPOSE_FORMAT, validation.from);
                validation.fromIsListValue = true;
            }

            if (validation.dataType === "date") {
                parsedFromDate = calc.runtime.parseDate(validation.from);
                if (parsedFromDate) {
                    validation.from = kendo.format(DATE_FORMAT, validation.from);
                    validation.fromIsDateValue = true;
                }
            }

            validation.from = calc.compile(calc.parseFormula(sheet, row, col, validation.from));
        }

        if (validation.to) {
            if (validation.dataType === "date") {
                parsedToDate = calc.runtime.parseDate(validation.to);
                if (parsedToDate) {
                    validation.to = kendo.format(DATE_FORMAT, validation.to);
                    validation.toIsDateValue = true;
                }
            }

            validation.to = calc.compile(calc.parseFormula(sheet, row, col, validation.to));
        }

        if (validation.dataType == "custom") {
            comparer = exports.validationComparers.custom;
        } else if (validation.dataType == "list") {
            comparer = exports.validationComparers.list;
        } else {
            comparer = exports.validationComparers[validation.comparerType];
        }

        if (!comparer) {
            throw kendo.format("'{0}' comparer is not implemented.", validation.comparerType);
        }

        validationHandler = function (valueToCompare) { //add 'valueFormat' arg when add isDate comparer
            var toValue = this.to && (this.to_value || this.to_value === 0) ? this.to_value : undefined;

            if (valueToCompare === null || valueToCompare === "") {
                if (this.allowNulls) {
                    this.value = true;
                } else {
                    this.value = false;
                }
            } else if (this.dataType == "custom") {
                this.value = comparer(valueToCompare, this.from_value,  toValue);
            } else if (this.dataType == "list") {
                var data = this._getListData();

                this.value = comparer(valueToCompare, data, toValue);
            } else {
                //TODO: TYPE CHECK IS REQUIRED ONLY FOR DATE TYPE WHEN SPECIAL COMPARER (ISDATE) IS USED
                this.value = comparer(valueToCompare, this.from_value,  toValue);
            }

            return this.value;
        };

        return new kendo.spreadsheet.validation.Validation($.extend(validation, {
            handler: validationHandler,
            sheet: sheet,
            row: row,
            col: col
        }));
    }

    var Validation = Class.extend({
        init: function Validation(options){
            this.handler = options.handler;
            this.from = options.from;
            this.to = options.to;
            this.dataType = options.dataType; //date, time etc
            this.comparerType =  options.comparerType; //greaterThan, EqaulTo etc
            this.type = options.type ? options.type : "warning"; //info, warning, reject
            this.allowNulls = options.allowNulls ? true : false;
            this.fromIsDateValue = options.fromIsDateValue ? true : false;
            this.toIsDateValue = options.toIsDateValue ? true : false;
            this.showButton = options.showButton;
            this.fromIsListValue = options.fromIsListValue ? true : false;

            //TODO: address to be range / cell ref, and adjust it based on it
            this.sheet = options.sheet;
            this.row = options.row;
            this.col = options.col;

            if (options.tooltipMessageTemplate) {
                this.tooltipMessageTemplate = options.tooltipMessageTemplate;
            }

            if (options.tooltipTitleTemplate) {
                this.tooltipTitleTemplate = options.tooltipTitleTemplate;
            }

            if (options.messageTemplate) {
                this.messageTemplate = options.messageTemplate;
            }

            if (options.titleTemplate) {
                this.titleTemplate = options.titleTemplate;
            }
        },

        _formatMessages: function(format) {
            var from = this.from ? this.from_value : "";
            var to = this.to ? this.to_value : "";

            var fromFormula = this.from ? this.from.toString() : "";
            var toFormula = this.to ? this.to.toString() : "";
            var dataType = this.dataType;
            var type = this.type;
            var comparerType = this.comparerType;

            return kendo.format(format, from, to, fromFormula, toFormula, dataType, type, comparerType);
        },

        _setMessages: function() {
            this.title = "";
            this.message = "";

            if (this.tooltipTitleTemplate) {
                this.tooltipTitle = this._formatMessages(this.tooltipTitleTemplate);
            }

            if (this.tooltipMessageTemplate) {
                this.tooltipMessage = this._formatMessages(this.tooltipMessageTemplate);
            }

            if (this.titleTemplate) {
                this.title = this._formatMessages(this.titleTemplate);
            }

            if (this.messageTemplate) {
                this.message = this._formatMessages(this.messageTemplate);
            }
        },

        _getListData: function() {
            if (!this.from_value || !this.from_value.data) {
                return [];
            }

            var cube = this.from_value.data;
            var i;
            var y;
            var data = [];

            for (i = 0; i < cube.length; i++ ) {
                var array = cube[i];

                if (array) {
                    for (y = 0; y < array.length; y++ ) {
                        data.push(array[y]);
                    }
                }
            }

            return data;
        },

        clone: function(sheet, row, col) {
            var options = this._getOptions();

            if (options.from) {
                options.from = options.from.clone(sheet, row, col);
            }

            if (options.to) {
                options.to = options.to.clone(sheet, row, col);
            }

            return new Validation($.extend(options,
                { handler: this.handler },
                { sheet: sheet, row: row, col: col }
            ));
        },

        deepClone: function() {
            var v = new Validation(this);
            v.from = v.from.deepClone();
            if (v.to) {
                v.to = v.to.deepClone();
            }
            return v;
        },

        exec: function(ss, compareValue, compareFormat, callback) {
            var self = this;

            function getValue(val) {
                if (val instanceof kendo.spreadsheet.Ref) {
                    val = ss.getData(val);
                    if (Array.isArray(val)) {
                        val = val[0];
                    }
                }
                return val;
            }

            var calculateFromCallBack = function(val) {
                self.from_value = getValue(val);
                self.value = self.handler.call(self, compareValue, compareFormat);
                self._setMessages();
                if (callback) {
                    callback(self.value);
                }
            };

            if (self.to) {
                self.to.exec(ss, function(val) {
                    self.to_value = getValue(val);
                    self.from.exec(ss, calculateFromCallBack);
                });
            } else {
                self.from.exec(ss, calculateFromCallBack);
            }
        },

        reset: function() {
            if (this.from) {
                this.from.reset();
            }
            if (this.to) {
                this.to.reset();
            }
            delete this.value;
        },

        adjust: function(affectedSheet, operation, start, delta) {
            var prevFrom, prevTo, modified;
            var formulaRow = this.row;
            var formulaCol = this.col;
            if (this.from) {
                prevFrom = this.from.adjust(affectedSheet, operation, start, delta);
            }
            if (this.to) {
                prevTo = this.to.adjust(affectedSheet, operation, start, delta);
            }
            if (this.sheet.toLowerCase() == affectedSheet.toLowerCase()) {
                switch (operation) {
                  case "row":
                    if (formulaRow >= start) {
                        modified = true;
                        this.row += delta;
                    }
                    break;
                  case "col":
                    if (formulaCol >= start) {
                        modified = true;
                        this.col += delta;
                    }
                    break;
                }
            }
            if (modified || prevFrom || prevTo) {
                var v = new Validation(this);
                v.from = prevFrom;
                v.to = prevTo;
                v.row = formulaRow;
                v.col = formulaCol;
                return v;
            }
        },

        toJSON: function() {
            var options = this._getOptions();

            if (options.from) {
                options.from = options.from.toString();

                if (options.dataType === "list") {
                    options.from = options.from.replace(/^_matrix\((.*)\)$/i, "$1");
                    delete options.fromIsListValue;
                }

                if (options.dataType === "date") {
                    if (this.fromIsDateValue) {
                        options.from = options.from.replace(/^DATEVALUE\("(.*)"\)$/i, "$1");
                        delete options.fromIsDateValue;
                    }
                }
            }

            if (options.to) {
                options.to = options.to.toString();

                if (options.dataType === "date") {
                    if (this.toIsDateValue) {
                        options.to = options.to.replace(/^DATEVALUE\("(.*)"\)$/i, "$1");
                        delete options.toIsDateValue;
                    }
                }
            }

            return options;
        },

        _getOptions: function () {
            return {
                from: this.from,
                to: this.to,
                dataType: this.dataType,
                type: this.type,
                comparerType: this.comparerType,
                row: this.row,
                col: this.col,
                sheet: this.sheet,
                allowNulls: this.allowNulls,
                fromIsListValue: this.fromIsListValue,
                fromIsDateValue: this.fromIsDateValue,
                toIsDateValue: this.toIsDateValue,
                tooltipMessageTemplate: this.tooltipMessageTemplate,
                tooltipTitleTemplate: this.tooltipTitleTemplate,
                //TODO: export generated messages instead?
                messageTemplate: this.messageTemplate,
                titleTemplate: this.titleTemplate,
                showButton: this.showButton
            };
        }
    });
    exports.compile = compileValidation;
    exports.validationComparers = {
        greaterThan: function (valueToCompare, from) {
            return valueToCompare > from;
        },

        lessThan: function (valueToCompare, from) {
            return valueToCompare < from;
        },

        between: function (valueToCompare, from, to) {
            return valueToCompare >= from && valueToCompare <= to;
        },

        equalTo: function (valueToCompare, from) {
            return valueToCompare == from;
        },

        notEqualTo: function (valueToCompare, from) {
            return valueToCompare != from;
        },

        greaterThanOrEqualTo: function (valueToCompare, from) {
            return valueToCompare >= from;
        },

        lessThanOrEqualTo: function (valueToCompare, from) {
            return valueToCompare <= from;
        },

        notBetween: function (valueToCompare, from, to) {
            return valueToCompare < from || valueToCompare > to;
        },

        custom: function (valueToCompare, from) {
            return from;
        },

        list: function (valueToCompare, data) {
            return data.indexOf(valueToCompare) > -1;
        }
    };

    exports.Validation = Validation;


}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/sheet',[ "../kendo.core", "../kendo.color", "./runtime", "./validation", "./references" ], f);
})(function(){

(function(kendo) {

    /* jshint laxbreak:true, eqnull:true */

    var RangeRef = kendo.spreadsheet.RangeRef;
    var UnionRef = kendo.spreadsheet.UnionRef;
    var CellRef = kendo.spreadsheet.CellRef;
    var Range = kendo.spreadsheet.Range;

    // This is a dynamic variable (see Greenspun's 10th rule).  It's
    // bound to an array via sheet._saveModifiedFormulas (which see)
    // while the callback runs.  The goal is to enable external code
    // to get a list of formulas or validations that have been
    // adjusted as an effect of an insert/delete row/column operation,
    // to be able to undo it.
    //
    // The reason why simply saving the state via sheet.getState() or
    // range.getState() won't suffice is that an insert or delete
    // operation can have far-reaching effects, like adjusting
    // formulas from another sheet.
    var MODIFIED_FORMULAS;

    var Selection = kendo.Class.extend({
        init: function(sheet) {
            this._sheet = sheet;
            this.selection = kendo.spreadsheet.FIRSTREF.toRangeRef();
            this.originalSelection = kendo.spreadsheet.FIRSTREF.toRangeRef();
            this._activeCell = kendo.spreadsheet.FIRSTREF.toRangeRef();
            this.originalActiveCell = kendo.spreadsheet.FIRSTREF;
        },

        currentSelectionRange: function() {
            return this.selection.rangeAt(this.selectionRangeIndex).toRangeRef();
        },

        currentOriginalNavigationRange: function() {
            return this.originalSelection.rangeAt(this.selectionRangeIndex).toRangeRef();
        },

        currentNavigationRange: function() {
            if (this.singleCellSelection()) {
                return this._sheet._sheetRef;
            } else {
                return this.selection.rangeAt(this.selectionRangeIndex).toRangeRef();
            }
        },

        nextNavigationRange: function() {
            if (!this.singleCellSelection()) {
                this.selectionRangeIndex = this.selection.nextRangeIndex(this.selectionRangeIndex);
            }

            return this.currentNavigationRange();
        },

        previousNavigationRange: function() {
            if (!this.singleCellSelection()) {
                this.selectionRangeIndex = this.selection.previousRangeIndex(this.selectionRangeIndex);
            }

            return this.currentNavigationRange();
        },

        activeCell: function(ref) {
            if (ref) {
                this.originalActiveCell = ref.first();
                this._activeCell = this._sheet.unionWithMerged(ref.toRangeRef());
                this._sheet.focus(ref);
                this._sheet.triggerChange({ activeCell: true, selection: true });
            }

            return this._activeCell;
        },

        select: function(ref, expanded, changeActiveCell, view) {
            if (ref) {
                if (ref.eq(this.originalSelection)) {
                    return;
                }

                this._sheet.triggerSelect(new Range(ref, this._sheet));

                this.originalSelection = ref;

                this.selection = expanded;

                if (changeActiveCell !== false) {
                    if (ref.isCell()) {
                        // when selecting part of a merged cell, i.e. A1:B2 is merged and select(B2)
                        // is requested, mark A1 as the actually active cell.
                        // https://github.com/telerik/kendo/issues/7698
                        this._sheet.forEachMergedCell(ref, function(merged){
                            ref = merged.topLeft;
                        });
                        this.activeCell(ref);
                    } else {
                        ref = this.selection.lastRange();
                        if (view && view._sheet === this._sheet && view.panes[0]) {
                            // we should intersect this ref with the range that's currently on
                            // screen, so that the view doesn't scroll (that is, keep the activeCell
                            // visible) - https://github.com/telerik/kendo-ui-core/issues/5182 
                            // XXX: fiddling with View internals here is probably bad practice, but
                            // this whole thing is a mess already, so it can be forgiven. :-/
                            var panes = view.panes;
                            var i, pane, rows, cols, visible, newRef;

                            for (i = 0; i < panes.length; i++) {
                                pane = panes[i];
                                if (!pane._currentView) {
                                    continue;
                                }
                                rows = pane._currentView.rows.values;
                                cols = pane._currentView.columns.values;

                                visible = new RangeRef(
                                    new CellRef(rows.start, cols.start),
                                    new CellRef(rows.end, cols.end)
                                );

                                newRef = ref.intersect(visible);

                                if (newRef !== kendo.spreadsheet.NULLREF) {
                                    break;
                                }
                            }

                            if (newRef && newRef !== kendo.spreadsheet.NULLREF) {
                                ref = newRef;
                            }
                        }
                        this.activeCell(ref.first());
                    }

                    this.selectionRangeIndex = this.selection.size() - 1;
                } else {
                    this._sheet.triggerChange({ selection: true });
                }
            }

            return this.selection;
        },

        singleCellSelection: function() {
            return this._activeCell.eq(this.selection);
        }
    });

    var Sheet = kendo.Observable.extend({
        init: function() {
            kendo.Observable.prototype.init.call(this);
            this._reinit.apply(this, arguments);
        },


        events: [
            "changing",
            "commandRequest",
            "afterInsertRow",
            "afterDeleteRow",
            "insertRow",
            "insertColumn",
            "deleteRow",
            "deleteColumn",
            "hideRow",
            "hideColumn",
            "unhideRow",
            "unhideColumn",
            "select",
            "dataBinding",
            "dataBound",
            "progress"
        ],

        _reinit: function(rowCount, columnCount, rowHeight, columnWidth, headerHeight, headerWidth, defaultCellStyle) {
            defaultCellStyle = defaultCellStyle || {};

            this._defaultCellStyle = {
                background: defaultCellStyle.background,
                color: defaultCellStyle.color,
                fontFamily: defaultCellStyle.fontFamily,
                fontSize: defaultCellStyle.fontSize,
                italic: defaultCellStyle.italic,
                bold: defaultCellStyle.bold,
                underline: defaultCellStyle.underline,
                wrap: defaultCellStyle.wrap,
                verticalAlign: defaultCellStyle.verticalAlign,
                textAlign: defaultCellStyle.textAlign
            };

            this._rows = new kendo.spreadsheet.Axis(rowCount, rowHeight);
            this._columns = new kendo.spreadsheet.Axis(columnCount, columnWidth);
            this._filteredRows = new kendo.spreadsheet.RangeList(0, rowCount - 1, false);
            this._mergedCells = [];
            this._frozenRows = 0;
            this._frozenColumns = 0;
            this._suspendChanges = false;
            this._filter = null;
            this._showGridLines = true;
            this._gridLinesColor = null;
            this._grid = new kendo.spreadsheet.Grid(this._rows, this._columns, rowCount, columnCount, headerHeight, headerWidth);
            this._sheetRef = this._grid.normalize(kendo.spreadsheet.SHEETREF);
            this._properties = new kendo.spreadsheet.PropertyBag(rowCount, columnCount, this._defaultCellStyle);
            this._sorter = new kendo.spreadsheet.Sorter(this._grid, this._properties.sortable());

            this._viewSelection = new Selection(this);

            this._editSelection = new Selection(this);

            this._formulaSelections = [];
            this._drawings = [];
        },

        resize: function(newRows, newCols) {
            newRows = Math.max(newRows, 1);
            newCols = Math.max(newCols, 1);
            var oldRows = this._rows._count;
            var oldCols = this._columns._count;
            if (newRows < oldRows) {
                this.range(newRows, 0, oldRows - newRows, oldCols).clear();
            }
            if (newCols < oldCols) {
                this.range(0, newCols, oldRows, oldCols - newCols).clear();
            }
            this._rows._resize(newRows);
            this._columns._resize(newCols);
            this._grid._resize(newRows, newCols);
            this._properties._resize(newRows, newCols);
            this._sheetRef = this._grid.normalize(kendo.spreadsheet.SHEETREF);
            if (newRows > oldRows) {
                this.range(oldRows, 0, newRows - oldRows, newCols).clear();
                this._filteredRows.value(oldRows, newRows - 1, false);
            }
            if (newCols > oldCols) {
                this.range(0, oldCols, newRows, newCols - oldCols).clear();
            }
            this.triggerChange({ layout: true });
        },

        _resizeAddRow: function(count) {
            this.resize(this._rows._count + (count || 1), this._columns._count);
        },

        _resizeAddColumn: function(count) {
            this.resize(this._rows._count, this._columns._count + (count || 1));
        },

        _resizeDeleteRow: function(count) {
            this._resizeAddRow(-(count || 1));
        },

        _resizeDeleteColumn: function(count) {
            this._resizeAddColumn(-(count || 1));
        },

        _selectionState: function() {
            return this._inEdit ? this._editSelection : this._viewSelection;
        },

        navigator: function() {
            if(!this._navigator) {
                 this._navigator = new kendo.spreadsheet.SheetNavigator(this);
            }
            return this._navigator;
        },

        axisManager: function() {
            if(!this._axisManager) {
                 this._axisManager = new kendo.spreadsheet.AxisManager(this);
            }

            return this._axisManager;
        },

        _name: function(value) {
            if (!value) {
                return this._sheetName;
            }

            this._sheetName = value;

            return this;
        },

        name: function() {
            return this._name();
        },

        _property: function(accessor, value, reason) {
            if (value === undefined) {
                return accessor();
            } else {
                accessor(value);

                return this.triggerChange(reason);
            }
        },

        _field: function(name, value, reason) {
            if (value === undefined) {
                return this[name];
            } else {
                this[name] = value;

                return this.triggerChange(reason);
            }
        },

        suspendChanges: function(value) {
            if (value === undefined) {
                return this._suspendChanges;
            }

            this._suspendChanges = value;

            return this;
        },

        triggerChange: function(reason) {
            if (!this._suspendChanges) {
                this.trigger("change", reason);
            }
            return this;
        },

        triggerSelect: function(range) {
            this.trigger("select", { range: range });
        },

        setDataSource: function(dataSource, columns) {
            if (this.dataSourceBinder) {
                this.dataSourceBinder.destroy();
            }

            this.dataSourceBinder = new kendo.spreadsheet.SheetDataSourceBinder({
                dataSource: dataSource,
                sheet: this,
                columns: columns
            });

            this.dataSource = this.dataSourceBinder.dataSource;
        },

        hideColumn: function(columnIndex) {
            if (this.trigger("hideColumn", { index: columnIndex })) {
                return;
            }

            return this._property(this._columns.hide.bind(this._columns), columnIndex, { layout: true });
        },

        unhideColumn: function(columnIndex) {
            if (this.trigger("unhideColumn", { index: columnIndex })) {
                return;
            }

            return this._property(this._columns.unhide.bind(this._columns), columnIndex, { layout: true });
        },

        isHiddenColumn: function(columnIndex) {
            return this._grid._columns.hidden(columnIndex);
        },

        _copyRange: function(sourceRangeRef, targetRef) {
            var grid = this._grid;
            var rowCount = grid.rowCount;

            var nextRefTopLeft = grid.normalize(sourceRangeRef.topLeft);
            var nextRefBottomRight = grid.normalize(sourceRangeRef.bottomRight);

            var nextIndex = nextRefTopLeft.col * rowCount + nextRefTopLeft.row;
            var nextBottomIndex = nextRefBottomRight.col * rowCount + nextRefBottomRight.row;

            var targetIndex = targetRef.col * rowCount + targetRef.row;

            this._properties.copy(nextIndex, nextBottomIndex, targetIndex);
        },

        _saveModifiedFormulas: function(array, callback) {
            var save = MODIFIED_FORMULAS;
            MODIFIED_FORMULAS = array;
            var ret = callback();
            MODIFIED_FORMULAS = save;
            return ret;
        },

        _restoreModifiedFormulas: function(array) {
            var wb = this._workbook;
            array.forEach(function(f){
                var sheet = wb.sheetByName(f.sheet), index;
                if (f instanceof kendo.spreadsheet.calc.runtime.Formula) {
                    index = sheet._grid.cellRefIndex(f); // f has row, col
                    sheet._properties.set("formula", index, index, f);
                }
                if (f instanceof kendo.spreadsheet.validation.Validation) {
                    index = sheet._grid.cellRefIndex(f); // f has row, col
                    sheet._properties.set("validation", index, index, f);
                }
            });
        },

        _adjustReferences: function(operation, start, delta, mergedCells) {
            this._mergedCells = mergedCells.reduce(function(a, ref){
                ref = ref.adjust(null, null, null, null, operation == "row", start, delta);
                if (ref instanceof RangeRef) {
                    a.push(ref);
                }
                return a;
            }, []);
            if (this._workbook) {
                var affectedSheet = this._name();
                this._workbook._sheets.forEach(function(sheet){
                    sheet._forFormulas(function(formula){
                        var prev = formula.adjust(affectedSheet, operation, start, delta);
                        if (prev && MODIFIED_FORMULAS) {
                            // if formula.adjust returns non-null,
                            // that means the formula was indeed
                            // modified and the returned value is a
                            // copy of the previous Formula, which we
                            // can use for undoing the operation.
                            MODIFIED_FORMULAS.push(prev);
                        }
                    });

                    sheet._forValidations(function(validation){
                        var prev = validation.adjust(affectedSheet, operation, start, delta);
                        if (prev && MODIFIED_FORMULAS) {
                            MODIFIED_FORMULAS.push(prev);
                        }
                    });
                });
                this._workbook.adjustNames(affectedSheet, operation == "row", start, delta);
            }
            var selection = this.select();
            selection = selection.adjust(null, null, null, null, operation == "row", start, delta);
            if (selection !== kendo.spreadsheet.NULLREF) {
                this.select(selection);
            }
            // adjust column widths or row heights and hidden attribute
            var axis = operation == "col" ? this._columns : this._rows;
            axis.adjust(start, delta);

            if (operation == "row") {
                if (delta < 0) {
                    this._filteredRows.copy(start - delta, this._rows._count - 1, start);
                } else {
                    this._filteredRows.copy(start, this._rows._count, start + delta);
                    this._filteredRows.value(start, start + delta - 1, false);
                }
            }

            // adjust drawing anchor cells
            this._drawings.forEach(function(drawing){
                if (drawing.topLeftCell) {
                    drawing.topLeftCell = drawing.topLeftCell.adjust(null, null, null, null,
                                                                     operation == "row", start, delta);
                }
            });
        },

        _forFormulas: function(callback) {
            var props = this._properties;
            var formulas = props.get("formula").values();
            var n = formulas.length;
            formulas.forEach(function(f, i){
                callback.call(this, f.value, i, n);
            }, this);
        },

        _forValidations: function(callback) {
            var props = this._properties;
            props.get("validation").values().forEach(function(v){
                callback.call(this, v.value);
            }, this);
        },

        insertRow: function(rowIndex, skipDataSourceInsert) {
            if (this.trigger("insertRow", { index: rowIndex })) {
                return;
            }

            this.batch(function() {
                this._resizeAddRow();

                var grid = this._grid;
                var columnCount = grid.columnCount;
                var rowCount = grid.rowCount;

                if (rowIndex + 1 == rowCount) {
                    // we just inserted after the last one, no need to shift data
                    return;
                }

                var frozenRows = this.frozenRows();

                if (rowIndex < frozenRows) {
                    this.frozenRows(frozenRows + 1);
                }

                var mergedCells = this._mergedCells.slice();

                for (var ci = 0; ci < columnCount; ci++) {
                    var ref = new RangeRef(new CellRef(rowIndex, ci), new CellRef(rowIndex, ci));

                    var topLeft = grid.normalize(ref.topLeft);
                    var bottomRight = grid.normalize(ref.bottomRight);

                    var nextRef = new RangeRef(
                        new CellRef(topLeft.row, topLeft.col),
                        new CellRef(rowCount - 2, bottomRight.col)
                    );

                    this._copyRange(nextRef, new CellRef(topLeft.row + 1, topLeft.col));

                    new Range(ref, this).clear({ clearAll: true, keepBorders: true });
                }

                this._adjustReferences("row", rowIndex, 1, mergedCells);
            }, {
                recalc: true,
                layout: true,
                insertRow: { index: rowIndex },
                ref: new RangeRef(new CellRef(rowIndex, 0), new CellRef(Infinity, Infinity))
            });

            if (!skipDataSourceInsert) {
                this.trigger("afterInsertRow", { index: rowIndex });
            }

            return this;
        },

        isEnabledRow: function(rowIndex) {
            var ref = new RangeRef(new CellRef(rowIndex, 0), new CellRef(rowIndex, this._grid.columnCount));
            return new Range(ref, this).enable();
        },

        deleteRow: function(rowIndex, skipDataSourceDelete) {
            if (!this.isEnabledRow(rowIndex)) {
                return this;
            }

            if (this.trigger("deleteRow", { index: rowIndex })) {
                return;
            }

            this.batch(function() {
                var grid = this._grid;
                var columnCount = grid.columnCount;

                var frozenRows = this.frozenRows();
                if (rowIndex < frozenRows) {
                    this.frozenRows(frozenRows - 1);
                }

                var mergedCells = this._mergedCells.slice();

                for (var ci = 0; ci < columnCount; ci++) {
                    var ref = new RangeRef(new CellRef(rowIndex, ci), new CellRef(rowIndex, ci));

                    new Range(ref, this).clear({ clearAll: true, keepBorders: true });

                    var topLeft = grid.normalize(ref.topLeft);
                    var bottomRight = grid.normalize(ref.bottomRight);

                    var nextRef = new RangeRef(
                        new CellRef(topLeft.row + 1, topLeft.col),
                        new CellRef(Infinity, bottomRight.col)
                    );

                    this._copyRange(nextRef, topLeft);

                    var nextRefBottomRight = grid.normalize(nextRef.bottomRight);

                    new Range(new RangeRef(nextRefBottomRight, nextRefBottomRight), this).clear();
                }

                this._adjustReferences("row", rowIndex, -1, mergedCells);

                this._resizeDeleteRow();
            }, {
                recalc: true,
                layout: true,
                deleteRow: { index: rowIndex },
                ref: new RangeRef(new CellRef(rowIndex, 0), new CellRef(Infinity, Infinity))
            });

            if (!skipDataSourceDelete) {
                this.trigger("afterDeleteRow", { index: rowIndex });
            }

            return this;
        },

        insertColumn: function(columnIndex) {
            if (this.trigger("insertColumn", { index: columnIndex })) {
                return;
            }

            this.batch(function() {
                this._resizeAddColumn();

                var grid = this._grid;
                var columnCount = grid.columnCount;

                if (columnIndex + 1 == columnCount) {
                    // we just inserted after the last one, no need to shift data
                    return;
                }

                var frozenColumns = this.frozenColumns();

                if (columnIndex < frozenColumns) {
                    this.frozenColumns(frozenColumns + 1);
                }

                var mergedCells = this._mergedCells.slice();

                for (var ci = columnCount; ci >= columnIndex; ci--) {
                    var ref = new RangeRef(new CellRef(0, ci), new CellRef(Infinity, ci));

                    new Range(ref, this).clear({ clearAll: true, keepBorders: true });

                    if (ci == columnIndex) {
                        break;
                    }

                    var topLeft = grid.normalize(ref.topLeft);
                    var bottomRight = grid.normalize(ref.bottomRight);

                    var nextRef = new RangeRef(
                        new CellRef(topLeft.row, topLeft.col - 1),
                        new CellRef(bottomRight.row, bottomRight.col - 1)
                    );

                    this._copyRange(nextRef, topLeft);
                }

                this._adjustReferences("col", columnIndex, 1, mergedCells);
            }, {
                recalc: true,
                layout: true,
                insertColumn: { index: columnIndex },
                ref: new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, Infinity))
            });

            return this;
        },

        isEnabledColumn: function(columnIndex) {
            var ref = new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, columnIndex));
            return new Range(ref, this).enable();
        },

        deleteColumn: function(columnIndex) {
            if (!this.isEnabledColumn(columnIndex)) {
                return this;
            }

            if (this.trigger("deleteColumn", { index: columnIndex })) {
                return;
            }

            this.batch(function() {
                var grid = this._grid;
                var columnCount = grid.columnCount;

                var frozenColumns = this.frozenColumns();

                if (columnIndex < frozenColumns) {
                    this.frozenColumns(frozenColumns - 1);
                }

                var mergedCells = this._mergedCells.slice();

                for (var ci = columnIndex; ci < columnCount; ci++) {
                    var ref = new RangeRef(new CellRef(0, ci), new CellRef(Infinity, ci));

                    new Range(ref, this).clear({ clearAll: true, keepBorders: true });

                    if (ci == columnCount - 1) {
                        break;
                    }

                    var topLeft = grid.normalize(ref.topLeft);
                    var bottomRight = grid.normalize(ref.bottomRight);

                    var nextRef = new RangeRef(
                        new CellRef(topLeft.row, topLeft.col + 1),
                        new CellRef(bottomRight.row, bottomRight.col + 1)
                    );

                    this._copyRange(nextRef, topLeft);
                }

                this._adjustReferences("col", columnIndex, -1, mergedCells);

                this._resizeDeleteColumn();
            }, {
                recalc: true,
                layout: true,
                deleteColumn: { index: columnIndex },
                ref: new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, Infinity))
            });

            return this;
        },

        _filterRow: function(rowIndex) {
            this._rows.hide(rowIndex);
            this._filteredRows.value(rowIndex, rowIndex, true);
            this.triggerChange({ layout: true });
        },

        hideRow: function(rowIndex) {
            if (this.trigger("hideRow", { index: rowIndex })) {
                return;
            }
            return this._property(this._rows.hide.bind(this._rows), rowIndex, { layout: true });
        },

        unhideRow: function(rowIndex) {
            if (this.trigger("unhideRow", { index: rowIndex })) {
                return;
            }
            return this._property(this._rows.unhide.bind(this._rows), rowIndex, { layout: true });
        },

        isHiddenRow: function(rowIndex) {
            return this._grid._rows.hidden(rowIndex);
        },

        isFilteredRow: function(rowIndex) {
            return this._filteredRows.value(rowIndex);
        },

        columnWidth: function(columnIndex, width) {
            return this._property(this._columns.value.bind(this._columns, columnIndex, columnIndex), width, { layout: true });
        },

        rowHeight: function(rowIndex, height) {
            return this._property(this._rows.value.bind(this._rows, rowIndex, rowIndex), height, { layout: true });
        },

        frozenRows: function(value) {
            return this._field("_frozenRows", value, { layout: true });
        },

        frozenColumns: function(value) {
            return this._field("_frozenColumns", value, { layout: true });
        },

        showGridLines: function(value) {
            return this._field("_showGridLines", value, { layout: true });
        },

        gridLinesColor: function(value) {
            return this._field("_gridLinesColor", value, { layout: true });
        },

        _ref: function(row, column, numRows, numColumns) {
            var ref = null;

            if (row instanceof kendo.spreadsheet.Ref) {
                return row;
            }

            if (row instanceof kendo.spreadsheet.Range) {
                return row._ref.toRangeRef();
            }

            if (typeof row === "string") {
                ref = kendo.spreadsheet.calc.parseReference(row);
            } else {
                if (!numRows) {
                    numRows = 1;
                }

                if (!numColumns) {
                    numColumns = 1;
                }
                ref = new RangeRef(new CellRef(row, column), new CellRef(row + numRows - 1, column + numColumns - 1));
            }

            return ref;
        },

        range: function(row, column, numRows, numColumns) {
            return new Range(this._ref(row, column, numRows, numColumns), this);
        },

        _getMergedCells: function(range) {
            var grid = this._grid;
            var primary = {};
            var secondary = {};
            var hasMerged = false;

            this.forEachMergedCell(range, function(ref) {
                var topLeft = ref.topLeft;
                grid.forEach(ref, function(cellRef) {
                    if (topLeft.eq(cellRef)) {
                        primary[cellRef.print()] = ref;
                        hasMerged = true;
                    } else if (range.contains(cellRef)) {
                        secondary[cellRef.print()] = topLeft;
                        hasMerged = true;
                    }
                });
            });

            return { primary: primary, secondary: secondary, hasMerged: hasMerged };
        },

        forEachMergedCell: function(ref, callback) {
            var selectAll = false;

            if (typeof callback === "undefined") {
                callback = ref;
                selectAll = true;
            }

            this._mergedCells.forEach(function(merged) {
                if (selectAll || merged.intersects(ref)) {
                    callback(merged);
                }
            });
        },

        forEachFilterHeader: function(ref, callback) {
            var selectAll = false;

            if (typeof callback === "undefined") {
                callback = ref;
                selectAll = true;
            }

            if (this._filter) {
                var refs = [];

                // get refs of all columns
                this._filter.ref.forEachColumn(function(columnRef) {
                    if (selectAll || columnRef.intersects(ref)) {
                        refs.push(columnRef.topLeft);
                    }
                });

                // filter out merged references
                this._mergedCells.forEach(function(merged) {
                    refs = refs.map(function(ref) {
                        if (merged.intersects(ref)) {
                            return merged;
                        }

                        return ref;
                    });
                });

                // use only unique refs
                refs.reduce(function unique(result, element) {
                    if (result.indexOf(element) < 0) {
                        result.push(element);
                    }

                    return result;
                }, []).forEach(callback);
            }
        },

        forEach: function(ref, callback) {
            var self = this;
            function forEachRange(ref) {
                if (!(ref instanceof RangeRef)) {
                    ref = ref.toRangeRef();
                }
                var topLeft = self._grid.normalize(ref.topLeft);
                var bottomRight = self._grid.normalize(ref.bottomRight);
                var ci, ri;

                function doIt(value) {
                    callback(ri++, ci, value);
                }

                for (ci = topLeft.col; ci <= bottomRight.col; ci++) {
                    ri = topLeft.row;
                    var startCellIndex = self._grid.index(ri, ci);
                    var endCellIndex = self._grid.index(bottomRight.row, ci);
                    self._properties.forEach(startCellIndex, endCellIndex, doIt);
                }
            }

            if (!(ref instanceof RangeRef)) {
                ref = self._ref(ref);
            }

            if (ref instanceof UnionRef) {
                // _ref() might still return a UnionRef, for instance, if
                // `ref` happens to be one.  Probably an oversight, but it
                // turns out to be useful.
                ref.forEach(forEachRange);
            } else {
                forEachRange(ref);
            }
        },

        startResizing: function(initialPosition) {
            this._initialPosition = initialPosition;
            this._resizeInProgress = true;
        },

        startAutoFill: function() {
            this._autoFillInProgress = true;
            var selection = this.select();
            this._autoFillOrigin = selection;
            this._autoFillDest = selection;
            this.triggerChange({ selection: true });
        },

        updateAutoFill: function(dest, punch, hint, direction) {
            this._autoFillDest = dest;
            this._autoFillPunch = punch;
            this._autoFillHint = hint;
            this._autoFillDirection = direction;
            this.triggerChange({ selection: true });
        },

        autoFillRef: function() {
            return this._autoFillDest;
        },

        autoFillPunch: function() {
            return this._autoFillPunch;
        },

        autoFillInProgress: function() {
            return this._autoFillInProgress;
        },

        resizingInProgress: function() {
            return this._resizeInProgress;
        },

        draggingInProgress: function() {
            return this._draggingInProgress;
        },

        completeResizing: function() {
            if (this._resizeInProgress) {
                this._resizeInProgress = false;
                var hintPosition = this.resizeHintPosition();

                if (this._initialPosition && hintPosition) {
                    var handlePosition = this.resizeHandlePosition();
                    if (handlePosition.col !== -Infinity) {
                        this.trigger("commandRequest", {
                            command: "ColumnWidthCommand",
                            options: {
                                target: handlePosition.col,
                                value: this.columnWidth(handlePosition.col) - (this._initialPosition.x - hintPosition.x)
                            }
                        });
                    } else {
                        this.trigger("commandRequest", {
                            command: "RowHeightCommand",
                            options: {
                                target: handlePosition.row,
                                value: this.rowHeight(handlePosition.row) - (this._initialPosition.y - hintPosition.y)
                            }
                        });
                    }
                } else {
                    this.trigger("change", { resize: true });
                }
            }
        },

        _visualRange: function(ref) {
            var merged = this._mergedCells;
            for (var i = merged.length; --i >= 0;) {
                if (merged[i].intersects(ref)) {
                    return this.range(merged[i]);
                }
            }
            return this.range(ref);
        },

        _renderComment: function(ref) {
            var comment = null;
            if (ref) {
                var range = this._visualRange(ref);
                comment = range.comment();
                ref = range._ref.toRangeRef().topLeft;
            }
            if (comment) {
                if (!this._commentRef || !ref.eq(this._commentRef)) {
                    this._commentRef = ref;
                    this.trigger("change", { comment: true });
                }
            } else {
                if (this._commentRef) {
                    this._commentRef = null;
                    this.trigger("change", { comment: true });
                }
            }
        },

        resizeHandlePosition: function() {
            return this._resizeHandlePosition;
        },

        resizeHintPosition: function(location) {
            if (location !== undefined) {
                this._resizeHintPosition = location;
                this.trigger("change", { resize: true });
            }
            return this._resizeHintPosition;
        },

        removeResizeHandle: function() {
            if (this._resizeHandlePosition) {
                this._resizeHintPosition = undefined;
                this._resizeHandlePosition = undefined;
                this._initialPosition = undefined;
                this.trigger("change", { resize: true });
            }
        },

        positionResizeHandle: function(ref) {
            this._resizeHandlePosition = ref;
            this.trigger("change", { resize: true });
        },

        startDragging: function(data) {
            this._draggingInProgress = data;
        },

        completeDragging: function() {
            var drag = this._draggingInProgress;
            if (drag) {
                this._draggingInProgress = null;
                var drawing = drag.drawing;
                if (drawing.eq(drag.copy)) {
                    return;
                }
                if (drawing.topLeftCell) {
                    // adjust reference - in case the top-left corner
                    // was moving, select the cell beneath it.
                    var box = this.drawingBoundingBox(drawing);
                    var row = this._rows.indexVisible(box.top);
                    var col = this._columns.indexVisible(box.left);
                    var ref = new CellRef(row, col);
                    var refBox = this.refBoundingBox(ref);
                    drawing.offsetX = box.left - refBox.left;
                    drawing.offsetY = box.top - refBox.top;
                    drawing.topLeftCell = ref;
                    this.triggerChange({ dragging: true });
                }
                this.trigger("commandRequest", {
                    command: "DrawingUpdateCommand",
                    options: {
                        sheet    : this,
                        drawing  : drawing,
                        previous : drag.copy
                    }
                });
            }
        },

        startSelection: function(view) {
            if (this.frozenRows() || this.frozenColumns()) {
                this._currentView = null;
            } else if (view && view._sheet === this) {
                this._currentView = view;
            }
            this._selectionInProgress = true;
        },

        completeSelection: function() {
            if (this._selectionInProgress) {
                this._selectionInProgress = false;
                this._resizeHintPosition = undefined;
                this.trigger("change", { selection: true });
            }
            if (this._autoFillInProgress) {
                this._autoFillInProgress = false;
                var dest = this._autoFillDest;
                var origin = this._autoFillOrigin;

                if (this._autoFillPunch) { // we just clear data here
                    this.trigger("commandRequest", {
                        command: "ClearContentCommand", options: { operatingRange: this.range(this._autoFillPunch) }
                    });
                } else {
                    if (!dest.eq(origin)) {
                        this.trigger("commandRequest", {
                            command: "AutoFillCommand", options: { operatingRange: this.range(dest), origin: this.range(origin) }
                        });
                    } else {
                        this.triggerChange({ selection: true });
                    }
                }

                this._autoFillDest = null;
                this._autoFillPunch = null;
                this._autoFillOrigin = null;

                this.select(dest);
            }
        },

        selectionInProgress: function() {
            return this._selectionInProgress;
        },

        select: function(ref, changeActiveCell) {
            var selectionState = this._selectionState();

            var expandedRef;

            if (ref) {
                ref = this._ref(ref);
                ref = this._grid.normalize(ref);
                expandedRef = this._grid.isAxis(ref) ? ref : this.unionWithMerged(ref);
            }

            return selectionState.select(ref, expandedRef, changeActiveCell, this._currentView);
        },

        originalSelect: function() {
            return this._selectionState().originalSelection;
        },

        currentSelectionRange: function() {
            return this._selectionState().currentSelectionRange();
        },

        currentOriginalSelectionRange: function() {
            return this._selectionState().currentOriginalNavigationRange();
        },

        currentNavigationRange: function() {
            return this._selectionState().currentNavigationRange();
        },

        nextNavigationRange: function() {
            return this._selectionState().nextNavigationRange();
        },

        previousNavigationRange: function() {
            return this._selectionState().previousNavigationRange();
        },

        selectionRangeIndex: function() {
            return this._selectionState().selectionRangeIndex;
        },

        activeCell: function(ref) {
            return this._selectionState().activeCell(ref);
        },

        originalActiveCell: function() {
            return this._selectionState().originalActiveCell;
        },

        singleCellSelection: function() {
            return this._selectionState().singleCellSelection();
        },

        unionWithMerged: function(ref) {
            var mergedCells = this._mergedCells;

            return ref.map(function(ref) {
                return ref.toRangeRef().union(mergedCells);
            });
        },

        trim: function(ref) {
            var trims = [];
            var grid = this._grid;
            this._properties.forEachProperty(function(property) {
                trims.push(grid.trim(ref, property.list));
            });
            return this.unionWithMerged(ref.topLeft.toRangeRef().union(trims));
        },

        focus: function(ref) {
            if (ref) {
                this._focus = ref.toRangeRef();
            } else {
                var focus = this._focus;
                this._focus = null;
                return focus;
            }
        },

        activeCellSelection: function() {
            return new Range(this._grid.normalize(this.activeCell()), this);
        },

        selection: function() {
            return new Range(this._grid.normalize(this._selectionState().selection), this);
        },

        selectedHeaders: function() {
            var selection = this.select();

            var rows = {};
            var cols = {};
            var allCols = false;
            var allRows = false;
            var maxRow = this._grid.rowCount - 1;
            var maxCol = this._grid.columnCount - 1;

            selection.forEach(function(ref) {
                var i;
                var rowState = "partial";
                var colState = "partial";
                ref = ref.toRangeRef();

                var bottomRight = ref.bottomRight;
                var topLeft = ref.topLeft;

                var rowSelection = topLeft.col <= 0 && bottomRight.col >= maxCol;
                var colSelection = topLeft.row <= 0 && bottomRight.row >= maxRow;

                if (colSelection) { //column selection
                    allRows = true;
                    colState = "full";
                }

                if (rowSelection) { //row selection
                    allCols = true;
                    rowState = "full";
                }

                if (!colSelection) { //column selection
                    for (i = topLeft.row; i <= bottomRight.row; i++) {
                        if (rows[i] !== "full") {
                            rows[i] = rowState;
                        }
                    }
                }

                if (!rowSelection) {
                    for (i = topLeft.col; i <= bottomRight.col; i++) {
                        if (cols[i] !== "full") {
                            cols[i] = colState;
                        }
                    }
                }
            });

            return {
                rows: rows,
                cols: cols,
                allRows: allRows,
                allCols: allCols,
                all: allRows && allCols
            };
        },

        isInEditMode: function(isInEdit) {
            if (isInEdit === undefined) {
                return this._inEdit;
            }

            this._inEdit = isInEdit;

            if (isInEdit) {
                this._editSelection.selection = this._viewSelection.selection.clone();
                this._editSelection.originalSelection = this._viewSelection.originalSelection.clone();
                this._editSelection._activeCell = this._viewSelection._activeCell.clone();
                this._editSelection.originalActiveCell = this._viewSelection.originalActiveCell.clone();
            }
        },

        _setFormulaSelections: function(selection) {
            this._formulaSelections = (selection || []).slice();
            this.triggerChange({ selection: true });
        },

        _viewActiveCell: function() {
            return this._viewSelection._activeCell.toRangeRef();
        },

        toJSON: function() {
            var positions = {};

            var rows = this._rows.toJSON("height", positions);
            var columns = this._columns.toJSON("width", {});
            var viewSelection = this._viewSelection;
            var hyperlinks = [];
            var defaultCellStyle = this._defaultCellStyle || {};

            function clearDefaultStyle(cell) {
                Object.keys(defaultCellStyle).forEach(function(key){
                    if (cell[key] === defaultCellStyle[key]) {
                        delete cell[key];
                    }
                });
            }

            this.forEach(kendo.spreadsheet.SHEETREF, function(row, col, cell) {
                clearDefaultStyle(cell);

                if (Object.keys(cell).length === 0) {
                    return;
                }

                if (cell.link) {
                    hyperlinks.push({
                        ref    : kendo.spreadsheet.Ref.display(null, row, col),
                        target : cell.link
                    });
                }

                var position = positions[row];

                if (position === undefined) {
                    position = rows.length;
                    rows.push({ index: row });
                    positions[row] = position;
                }

                row = rows[position];

                cell.index = col;

                if (row.cells === undefined) {
                    row.cells = [];
                }

                if (cell.formula) {
                    // stringify Formula object.
                    if (cell.formula.arrayFormulaRange) {
                        cell.formula = {
                            src: cell.formula.toString(),
                            ref: cell.formula.arrayFormulaRange.toString()
                        };
                    } else {
                        cell.formula = cell.formula.toString();
                    }
                }

                if (cell.validation) {
                    cell.validation = cell.validation.toJSON();
                }

                if (cell.color) {
                    cell.color = kendo.parseColor(cell.color).toCss();
                }

                if (cell.background) {
                    cell.background = kendo.parseColor(cell.background).toCss();
                }

                if (cell.borderTop && cell.borderTop.color) {
                    cell.borderTop.color = kendo.parseColor(cell.borderTop.color).toCss();
                }

                if (cell.borderBottom && cell.borderBottom.color) {
                    cell.borderBottom.color = kendo.parseColor(cell.borderBottom.color).toCss();
                }

                if (cell.borderRight && cell.borderRight.color) {
                    cell.borderRight.color = kendo.parseColor(cell.borderRight.color).toCss();
                }

                if (cell.borderLeft && cell.borderLeft.color) {
                    cell.borderLeft.color = kendo.parseColor(cell.borderLeft.color).toCss();
                }

                row.cells.push(cell);
            });

            var json = {
                name: this._name(),
                rows: rows,
                columns: columns,
                selection: viewSelection.selection.toString(),
                activeCell: viewSelection.activeCell().toString(),
                frozenRows: this.frozenRows(),
                frozenColumns: this.frozenColumns(),
                showGridLines: this.showGridLines(),
                gridLinesColor: this.gridLinesColor(),
                mergedCells: this._mergedCells.map(function(ref) {
                    return ref.toString();
                }),
                hyperlinks: hyperlinks,
                defaultCellStyle: defaultCellStyle,
                drawings: this._drawings.map(function(dr){
                    return dr.toJSON();
                })
            };

            if (this._sort) {
               json.sort = {
                   ref: this._sort.ref.toString(),
                   columns: this._sort.columns.map(function(column) {
                       return {
                           index: column.index,
                           ascending: column.ascending
                       };
                   })
               };
            }

            if (this._filter) {
               json.filter = {
                   ref: this._filter.ref.toString(),
                   columns: this._filter.columns.map(function(column) {
                        var filter = column.filter.toJSON();
                        filter.index = column.index;
                        return filter;
                   })
               };
            }

            return json;
        },

        fromJSON: function(json) {
            this.batch(function() {
                if (json.name !== undefined) {
                    this._name(json.name);
                }

                if (json.frozenColumns !== undefined) {
                    this.frozenColumns(json.frozenColumns);
                }

                if (json.frozenRows !== undefined) {
                    this.frozenRows(json.frozenRows);
                }

                if (json.columns !== undefined) {
                    this._columns.fromJSON("width", json.columns);
                }

                if (json.rows !== undefined) {
                    this._rows.fromJSON("height", json.rows);

                    for (var ri = 0; ri < json.rows.length; ri++) {
                        var row = json.rows[ri];
                        var rowIndex = row.index;

                        if (rowIndex === undefined) {
                            rowIndex = ri;
                        }

                        if (row.cells) {
                            for (var ci = 0; ci < row.cells.length; ci++) {
                                var cell = row.cells[ci];
                                var columnIndex = cell.index;

                                if (columnIndex === undefined) {
                                    columnIndex = ci;
                                }

                                if (cell.formula) {
                                    var isArray = typeof cell.formula != "string";
                                    var src = isArray ? cell.formula.src : cell.formula;
                                    var formula = this._compileFormula(rowIndex, columnIndex, src);
                                    if (isArray) {
                                        formula.setArrayFormulaRange(
                                            kendo.spreadsheet.calc.parseReference(cell.formula.ref));
                                    }
                                    cell.formula = formula;
                                }

                                if (cell.validation) {
                                    cell.validation = this._compileValidation(rowIndex, columnIndex, cell.validation);
                                }

                                this._properties.fromJSON(this._grid.index(rowIndex, columnIndex), cell);
                            }
                        }
                    }
                }

                if (json.drawings) {
                    this._drawings = json.drawings.map(Drawing.fromJSON);
                }

                if (json.selection) {
                    this._viewSelection.selection =
                        this._viewSelection.originalSelection = this._ref(json.selection);
                }

                if (json.activeCell) {
                    var activeCellRef = this._ref(json.activeCell);

                    this._viewSelection._activeCell = activeCellRef.toRangeRef();
                    this._viewSelection.originalActiveCell = activeCellRef.first();
                }


                if (json.mergedCells) {
                    json.mergedCells.forEach(function(ref) {
                       this.range(ref).merge();
                    }, this);
                }

                if (json.sort) {
                    this._sort = {
                        ref: this._ref(json.sort.ref),
                        columns: json.sort.columns.slice(0)
                    };
                }

                if (json.filter) {
                    var ref = json.filter.ref;
                    var columns = json.filter.columns  === undefined ? [] : json.filter.columns;

                    if (!ref) {
                        kendo.logToConsole("Dropping filter for sheet '" + json.name + "' due to missing ref");
                    } else {
                        this._filter = {
                            ref: this._ref(ref),
                            columns: columns.map(function(column) {
                                return {
                                    index: column.index,
                                    filter: kendo.spreadsheet.Filter.create(column)
                                };
                            })
                        };

                        this._refreshFilter();
                    }
                }

                if (json.showGridLines !== undefined) {
                    this._showGridLines = json.showGridLines;
                }

                this._gridLinesColor = json.gridLinesColor;
            });

            this._rows._refresh();
            this._columns._refresh();
        },

        formula: function(ref) {
            return this._properties.get("formula", this._grid.cellRefIndex(ref));
        },

        validation: function(ref) {
            return this._properties.get("validation", this._grid.cellRefIndex(ref));
        },

        // NOTE: resetFormulas should be called first.  We don't do it in this
        // function because it should be done from the Workbook object for all
        // sheets.
        resetFormulas: function() {
            this._forFormulas(function(formula){
                formula.reset();
            });
        },

        resetValidations: function() {
            this._forValidations(function(validation){
                validation.reset();
            });
        },

        recalc: function(context, callback) {
            var formulas = this._properties.get("formula").values();
            var count = formulas.length, pending = 0, i = 0;
            if (!count && callback) {
                return callback();
            }
            function next() {
                pending--;
                if (i == count && !pending) {
                    callback();
                }
            }
            while (i < count) {
                pending++;
                formulas[i++].value.exec(context, callback ? next : null);
            }
        },

        revalidate: function(context) {
            var self = this;
            this._forValidations(function(validation){
                var cellRef = new CellRef(validation.row, validation.col);
                var ref =  new RangeRef(cellRef, cellRef);
                validation.exec(context, self._get(ref, "value"), self._get(ref, "format"));
            });
        },

        _value: function(row, col, value) {
            var index = this._grid.index(row, col);

            if (value !== undefined) {
                this._properties.set("value", index, index, value);
            } else {
                return this._properties.get("value", index);
            }
        },

        _validation: function(row, col) {
            var index = this._grid.index(row, col);

            return this._properties.get("validation", index);
        },

        _compileValidation: function(row, col, validation) {
            if (validation instanceof kendo.spreadsheet.validation.Validation) {
                // do not alter an existing object.
                return validation.clone(this._name(), row, col);
            }

            if (validation.from != null) { // jshint ignore: line
                validation.from = (validation.from + "").replace(/^=/, "");
            }

            if (validation.to != null) { // jshint ignore: line
                validation.to = (validation.to + "").replace(/^=/, "");
            }

            return kendo.spreadsheet.validation.compile(this._name(), row, col, validation);
        },

        _compileFormula: function(row, col, f) {
            f = f.replace(/^=/, "");
            f = kendo.spreadsheet.calc.parseFormula(this._name(), row, col, f);
            return kendo.spreadsheet.calc.compile(f);
        },

        _copyValuesInRange: function (topLeft, bottomRight, value, property) {
            var ci, start, end;

            for (ci = topLeft.col; ci <= bottomRight.col; ci++) {
                start = this._grid.index(topLeft.row, ci);
                end = this._grid.index(bottomRight.row, ci);
                for (var index = start, row = topLeft.row; index <= end; ++index, ++row) {
                    // Even if it's the same formula in multiple cells, we
                    // need to have different Formula objects, hence cloning
                    // it.  Don't worry, clone() is fast.
                    value = value.clone(this._name(), row, ci);
                    this._properties.set(property, index, index, value);
                }
            }
            return value;
        },

        _set: function(ref, name, value) {
            var topLeft = this._grid.normalize(ref.topLeft);
            var bottomRight = this._grid.normalize(ref.bottomRight);
            var ci, start, end;

            if (typeof value == "number") {
                // Apparently, Excel (and LibreOffice and Google
                // Sheets) will limit precision to 14 digits; type:
                // -4.2524999999999995 and you get -4.2525.  The
                // formula engine already does something similar for
                // intermediate formula results, but we must do it
                // here as well for original input values.
                value = kendo.spreadsheet.calc.runtime.limitPrecision(value);
            }

            if (value && name == "formula") {
                if (typeof value == "string") {
                    // get Formula object.  we don't care about handling errors
                    // here since it won't be called interactively.
                    value = this._compileFormula(topLeft.row, topLeft.col, value);
                }

                value = this._copyValuesInRange(topLeft, bottomRight, value, "formula");

            } else if (value && name == "validation") {
                value = this._compileValidation(topLeft.row, topLeft.col, value);
                value = this._copyValuesInRange(topLeft, bottomRight, value, "validation");

            } else {
                for (ci = topLeft.col; ci <= bottomRight.col; ci++) {
                    start = this._grid.index(topLeft.row, ci);
                    end = this._grid.index(bottomRight.row, ci);
                    this._properties.set(name, start, end, value);
                    if (name == "formula") {
                        // removing a formula, must clear value.
                        this._properties.set("value", start, end, null);
                    }
                }
            }
        },

        _get: function(ref, name) {
            var topLeft = this._grid.normalize(ref.topLeft);

            var index = this._grid.index(topLeft.row, topLeft.col);

            return this._properties.get(name, index);
        },

        batch: function(callback, reason) {
            var suspended = this.suspendChanges();

            this.suspendChanges(true);

            callback.call(this);

            return this.suspendChanges(suspended).triggerChange(reason || { recalc: true });
        },

        _sortBy: function(ref, columns) {
            var indices = null;

            columns.forEach(function(column) {
                indices = this._sorter.sortBy(ref, column.index, this._properties.get("value"), column.ascending, indices);
            }, this);

            this._sort = {
                ref: ref,
                columns: columns
            };

            this._refreshFilter();

            this.forEach(ref, function(row, col, props) {
                var formula = props.formula;
                if (formula) {
                    var diff = row - formula.row;
                    if (diff !== 0) {
                        var start = diff > 0 ? formula.row : formula.row + diff;
                        formula.adjust(this.name(), "row", start, diff);
                    }
                }
            }.bind(this));

            this.triggerChange({ recalc: true });
        },

        _refreshFilter: function() {
            if (this._filter) {
                this._filterBy(this._filter.ref, this._filter.columns);
            }
        },

        _filterBy: function(ref, columns) {
            this.batch(function() {
                for (var ri = ref.topLeft.row; ri <= ref.bottomRight.row; ri++) {
                    if (this.isFilteredRow(ri)) {
                        this._filteredRows.value(ri, ri, false);
                        this._rows.unhide(ri);
                    }
                }

                columns.forEach(function(column) {
                    // do not filter header row
                    var columnRef = ref.resize({ top: 1 }).toColumn(column.index);

                    var cells = [];

                    if (columnRef === kendo.spreadsheet.NULLREF) {
                        return;
                    }

                    this.forEach(columnRef, function(row, col, cell) {
                        cell.row = row;
                        cells.push(cell);
                    });

                    column.filter.prepare(cells);

                    for (var ci = 0; ci < cells.length; ci++) {
                        var cell = cells[ci];
                        var value = column.filter.value(cell);

                        if (column.filter.matches(value) === false) {
                            this._filterRow(cell.row);
                        }
                    }
                }, this);

                this._filter = {
                    ref: ref,
                    columns: columns
                };
            }, { recalc: true, layout: true, filter: true });
        },

        filterColumn: function(ref) {
            var filterRef = this.filter().ref;
            return ref.toRangeRef().topLeft.col - filterRef.topLeft.col;
        },

        filter: function() {
            return this._filter;
        },

        clearFilter: function(spec) {
            this._clearFilter(spec instanceof Array ? spec : [spec]);
        },

        _clearFilter: function(indices) {
            if (this._filter) {
                this.batch(function() {
                    this._filter.columns = this._filter.columns.filter(function(column) {
                        return indices.indexOf(column.index) < 0;
                    });

                    this._refreshFilter();
                }, { recalc: true, layout: true, filter: true });
            }
        },

        getAxisState: function() {
            return {
                rows: this._rows.getState(),
                columns: this._columns.getState()
            };
        },

        setAxisState: function(state) {
            this._rows.setState(state.rows);
            this._columns.setState(state.columns);
            this.triggerChange({ layout: true });
        },

        getState: function() {
            return {
                rows: this._rows.getState(),
                columns: this._columns.getState(),
                mergedCells: this._mergedCells.map(function(cell) { return cell.clone(); }),
                properties: this._properties.getState()
            };
        },

        setState: function(state) {
            this._rows.setState(state.rows);
            this._columns.setState(state.columns);
            this._mergedCells = state.mergedCells;
            this._properties.setState(state.properties);
            this.triggerChange(kendo.spreadsheet.ALL_REASONS);
        },

        _merge: function(ref) {
            var mergedCells = this._mergedCells;

            var sheet = this;
            var mergedRef;
            this.batch(function() {
                mergedRef = ref.map(function(ref) {
                    if (ref instanceof kendo.spreadsheet.CellRef) {
                        return ref;
                    }

                    var currentRef = ref.toRangeRef().union(mergedCells, function(ref) {
                        mergedCells.splice(mergedCells.indexOf(ref), 1);
                    });

                    var range = new Range(currentRef, sheet);
                    var formula = range._get("formula");
                    var value = range.value();
                    var format = range.format();
                    var background = range.background();

                    range.value(null);
                    range.format(null);
                    range.background(null);

                    var topLeft = new Range(currentRef.collapse(), sheet);

                    if (formula) {
                        topLeft._set("formula", formula);
                    } else {
                        topLeft.value(value);
                    }
                    topLeft.format(format);
                    topLeft.background(background);

                    mergedCells.push(currentRef);
                    return currentRef;
                });

                var viewSelection = sheet._viewSelection;

                viewSelection.selection = sheet.unionWithMerged(viewSelection.originalSelection);
                viewSelection._activeCell = sheet.unionWithMerged(viewSelection.originalActiveCell);
            }, { activeCell: true, selection: true });

            return mergedRef;
        },

        _useCultureDecimals: function() {
            return this._workbook && this._workbook.options.useCultureDecimals;
        },

        withCultureDecimals: function(f) {
            var dot = ".";
            if (this._useCultureDecimals()) {
                dot = kendo.culture().numberFormat["."];
            }
            return kendo.spreadsheet.calc.withDecimalSeparator(dot, f);
        },

        drawingBoundingBox: function(drawing) {
            var left = drawing.offsetX;
            var top = drawing.offsetY;
            if (drawing.topLeftCell) {
                // offsets are relative to cell
                left += this._columns.sum(0, drawing.topLeftCell.col - 1);
                top += this._rows.sum(0, drawing.topLeftCell.row - 1);
            }
            return new kendo.spreadsheet.Rectangle(left, top, drawing.width, drawing.height);
        },

        refBoundingBox: function(ref) {
            return this._grid.rectangle(ref.toRangeRef());
        },

        addDrawing: function(drw, activate) {
            if (!(drw instanceof Drawing)) {
                drw = new Drawing(drw);
            }
            this._drawings.push(drw);
            if (activate) {
                this._activeDrawing = drw;
            }
            this.triggerChange({ layout: true });
            return drw;
        },

        removeDrawing: function(drawing) {
            var pos = this._drawings.indexOf(drawing);
            if (pos >= 0) {
                this._drawings.splice(pos, 1);
                this.triggerChange({ layout: true });
            }
        },

        usesImage: function(img) {
            for (var i = this._drawings.length; --i >= 0;) {
                if (this._drawings[i].image === img) {
                    return true;
                }
            }
            return false;
        },

        isMerged: function(ref) {
            var merged = this._mergedCells;
            for (var i = merged.length; --i >= 0;) {
                if (merged[i].eq(ref)) {
                    return true;
                }
            }
            return false;
        }
    });

    var Drawing = kendo.Class.extend({
        init: function Drawing(args) {
            this.reset(args);
        },

        toJSON: function() {
            return {
                topLeftCell: this.topLeftCell.toString(),
                offsetX: this.offsetX,
                offsetY: this.offsetY,
                width: this.width,
                height: this.height,
                image: this.image,
                opacity: this.opacity
            };
        },

        clone: function() {
            return new Drawing(this);
        },

        reset: function(dr) {
            var anchor = dr.topLeftCell;
            if (typeof anchor == "string") {
                anchor = kendo.spreadsheet.calc.parseReference(anchor);
            }
            this.topLeftCell = anchor;
            this.offsetX = dr.offsetX || 0;
            this.offsetY = dr.offsetY || 0;
            this.width = dr.width;
            this.height = dr.height;
            this.image = dr.image;
            this.opacity = dr.opacity != null ? dr.opacity : 1;
        },

        eq: function(dr) {
            return ((!this.topLeftCell && !dr.topLeftCell)
                    || (this.topLeftCell && dr.topLeftCell
                        && this.topLeftCell.eq(dr.topLeftCell)))
                && this.offsetX === dr.offsetX
                && this.offsetY === dr.offsetY
                && this.width === dr.width
                && this.height === dr.height
                && this.image === dr.image
                && this.opacity === dr.opacity;
        }
    });

    Drawing.fromJSON = function(args) {
        return new Drawing(args);
    };

    kendo.spreadsheet.Sheet = Sheet;
    kendo.spreadsheet.Drawing = Drawing;
})(kendo);

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/sheetsbar',[ "../kendo.core", "../kendo.sortable" ], f);
})(function(){

    (function(kendo) {

        var $ = kendo.jQuery;
        var outerWidth = kendo._outerWidth;
        var DOT = ".";
        var EMPTYCHAR = " ";
        var sheetsBarClassNames = {
            sheetsBarWrapper: "k-widget k-header",
            sheetsBarSheetsWrapper: "k-tabstrip k-floatwrap k-tabstrip-bottom",
            sheetsBarActive: "k-spreadsheet-sheets-bar-active",
            sheetsBarInactive: "k-spreadsheet-sheets-bar-inactive",
            sheetsBarAdd: "k-spreadsheet-sheets-bar-add",
            sheetsBarRemove: "k-spreadsheet-sheets-remove",
            sheetsBarItems: "k-spreadsheet-sheets-items",
            sheetsBarEditor: "k-spreadsheet-sheets-editor",
            sheetsBarScrollable: "k-tabstrip-scrollable",
            sheetsBarNext: "k-tabstrip-next",
            sheetsBarPrev: "k-tabstrip-prev",
            sheetsBarKItem: "k-item k-tabstrip-item",
            sheetsBarKActive: "k-state-active k-state-tab-on-top",
            sheetsBarKTextbox: "k-textbox",
            sheetsBarKLink: "k-link",
            sheetsBarKIcon: "k-icon",
            sheetsBarKFontIcon: "k-icon",
            sheetsBarKButton: "k-button k-icon-button",
            sheetsBarKButtonDefaults: "k-button-md k-rounded-md k-button-solid k-button-solid-base",
            sheetsBarKButtonBare: "k-button-md k-rounded-md k-button-flat k-button-flat-base",
            sheetsBarKArrowW: "k-i-arrow-60-left",
            sheetsBarKArrowE: "k-i-arrow-60-right",
            sheetsBarKReset: "k-reset k-tabstrip-items",
            sheetsBarKIconX: "k-i-close",
            sheetsBarKSprite: "k-sprite",
            sheetsBarKIconPlus: "k-i-plus",
            sheetsBarHintWrapper: "k-widget k-tabstrip k-tabstrip-bottom k-spreadsheet-sheets-items-hint",
            sheetsBarKResetItems: "k-reset k-tabstrip-items"
        };

        var SheetsBar = kendo.ui.Widget.extend({
            init: function(element, options) {
                var classNames = SheetsBar.classNames;

                kendo.ui.Widget.call(this, element, options);

                element = this.element;

                element.addClass(classNames.sheetsBarWrapper);

                this._openDialog = options.openDialog;

                this._tree = new kendo.dom.Tree(element[0]);

                this._tree.render([this._addButton(), this._createSheetsWrapper([])]);

                this._toggleScrollEvents(true);

                this._createSortable();

                this._sortable.bind("start", this._onSheetReorderStart.bind(this));

                this._sortable.bind("end", this._onSheetReorderEnd.bind(this));

                element.on("click", DOT + classNames.sheetsBarRemove, this._onSheetRemove.bind(this));

                element.on("click", "li", this._onSheetSelect.bind(this));

                element.on("dblclick", "li" + DOT + classNames.sheetsBarActive, this._createEditor.bind(this));

                element.on("click", DOT + classNames.sheetsBarAdd, this._onAddSelect.bind(this));
            },

            options: {
                name: "SheetsBar",
                scrollable: {
                    distance: 200
                }
            },

            events: [
                "select",
                "reorder",
                "rename"
            ],

            _createEditor: function () {
                if (this._editor) {
                    return;
                }

                this._renderSheets(this._sheets, this._selectedIndex, true);
                this._editor = this.element
                    .find(kendo.format("input{0}{1}",DOT,SheetsBar.classNames.sheetsBarEditor))
                    .trigger("focus")
                    .on("keydown", this._onEditorKeydown.bind(this))
                    .on("blur", this._onEditorBlur.bind(this));
            },

            _destroyEditor: function(canceled) {
                var newSheetName = canceled ? null : this._editor.val();
                this._editor.off();
                this._editor = null;
                this._renderSheets(this._sheets, this._selectedIndex, false);
                this._onSheetRename(newSheetName);
            },

            renderSheets: function(sheets, selectedIndex) {
                if (!sheets || selectedIndex < 0) {
                    return;
                }

                this._renderSheets(sheets, selectedIndex, false);
            },

            _renderSheets: function(sheets, selectedIndex, isInEditMode) {
                var that = this;
                var classNames = SheetsBar.classNames;

                that._isRtl = kendo.support.isRtl(that.element);
                that._sheets = sheets;
                that._selectedIndex = selectedIndex;

                that._renderHtml(isInEditMode, true);

                if (!that._scrollableAllowed()) {
                    return;
                }

                var sheetsWrapper = that._sheetsWrapper();

                sheetsWrapper.addClass(classNames.sheetsBarScrollable + EMPTYCHAR + classNames.sheetsBarSheetsWrapper);

                that._toggleScrollButtons();
            },

            _toggleScrollButtons: function (toggle) {
                var that = this;
                var ul = that._sheetsGroup();
                var wrapper = that._sheetsWrapper();
                var scrollLeft = kendo.scrollLeft(ul);
                var prev = wrapper.find(DOT + SheetsBar.classNames.sheetsBarPrev);
                var next = wrapper.find(DOT + SheetsBar.classNames.sheetsBarNext);

                if (toggle === false) {
                    prev.addClass( 'k-disabled' );
                    next.addClass( 'k-disabled' );
                } else {
                    prev.toggleClass( 'k-disabled', !(that._isRtl ? scrollLeft < ul[0].scrollWidth - ul[0].offsetWidth - 1 : scrollLeft !== 0) );
                    next.toggleClass( 'k-disabled', !(that._isRtl ? scrollLeft !== 0 : scrollLeft < ul[0].scrollWidth - ul[0].offsetWidth - 1) );
                }

            },

            _toggleScrollEvents: function(toggle) {
                var that = this;
                var classNames = SheetsBar.classNames;
                var options = that.options;
                var scrollPrevButton;
                var scrollNextButton;
                var sheetsWrapper = that._sheetsWrapper();
                scrollPrevButton = sheetsWrapper.find(DOT + classNames.sheetsBarPrev);
                scrollNextButton = sheetsWrapper.find(DOT + classNames.sheetsBarNext);

                if (toggle) {
                    scrollPrevButton.on("mousedown", function () {
                        that._nowScrollingSheets = true;
                        that._scrollSheetsByDelta(options.scrollable.distance * (that._isRtl ? 1 : -1));
                    });

                    scrollNextButton.on("mousedown", function () {
                        that._nowScrollingSheets = true;
                        that._scrollSheetsByDelta(options.scrollable.distance * (that._isRtl ? -1 : 1));
                    });

                    scrollPrevButton.add(scrollNextButton).on("mouseup", function () {
                        that._nowScrollingSheets = false;
                    });
                } else {
                    scrollPrevButton.off();
                    scrollNextButton.off();
                }
            },

            _renderHtml: function(isInEditMode, renderScrollButtons) {
                var idx;
                var sheetElements = [];
                var dom = kendo.dom;
                var element = dom.element;
                var sheets = this._sheets;
                var selectedIndex = this._selectedIndex;
                var classNames = SheetsBar.classNames;

                for (idx = 0; idx < sheets.length; idx++) {
                    var sheet = sheets[idx];
                    var isSelectedSheet = (idx === selectedIndex);
                    var attr = { className: classNames.sheetsBarKItem + EMPTYCHAR };
                    var elementContent = [];

                    if (isSelectedSheet) {
                        attr.className += classNames.sheetsBarKActive + EMPTYCHAR + classNames.sheetsBarActive;
                    } else {
                        attr.className += classNames.sheetsBarInactive;
                    }

                    if (isSelectedSheet && isInEditMode) {
                        elementContent.push(element("input", {
                            type: "text",
                            value: sheet.name(),
                            className: classNames.sheetsBarKTextbox + EMPTYCHAR + classNames.sheetsBarEditor,
                            maxlength: 50
                        }, []));
                    } else {
                        elementContent.push(element("span", {
                            className: classNames.sheetsBarKLink,
                            title: sheet.name()
                        }, [dom.text(sheet.name())]));

                        if (sheets.length > 1) {
                            var deleteIcon = element("span", {
                                className: classNames.sheetsBarKIcon + EMPTYCHAR + classNames.sheetsBarKFontIcon + EMPTYCHAR + classNames.sheetsBarKIconX
                            }, []);

                            elementContent.push(element("span", {
                                className: classNames.sheetsBarKLink + EMPTYCHAR + classNames.sheetsBarRemove,
                                'data-type': 'remove'
                            }, [deleteIcon]));
                        }
                    }

                    sheetElements.push(element("li", attr, elementContent));
                }

                this._tree.render([this._addButton(),  this._createSheetsWrapper(sheetElements, renderScrollButtons)]);
            },

            _createSheetsWrapper: function(sheetElements, renderScrollButtons) {
                var element = kendo.dom.element;
                var classNames = SheetsBar.classNames;
                var itemsWrapper = element('div', { className: 'k-tabstrip-items-wrapper k-hstack' } );
                var childrenElements = [null, element("ul", {
                    className: classNames.sheetsBarKReset
                }, sheetElements), null ];

                renderScrollButtons = true;

                if (renderScrollButtons) {
                    var baseButtonClass = classNames.sheetsBarKButton + EMPTYCHAR + classNames.sheetsBarKButtonBare + EMPTYCHAR;

                    childrenElements[0] = (element("span", {className: baseButtonClass + classNames.sheetsBarPrev }, [
                        element("span", {className: "k-button-icon" + EMPTYCHAR + classNames.sheetsBarKIcon + EMPTYCHAR + classNames.sheetsBarKArrowW}, [])
                    ]));

                    childrenElements[2] = (element("span", {className: baseButtonClass + classNames.sheetsBarNext }, [
                        element("span", {className: "k-button-icon" + EMPTYCHAR + classNames.sheetsBarKIcon + EMPTYCHAR + classNames.sheetsBarKArrowE}, [])
                    ]));
                }

                itemsWrapper.children = childrenElements;

                return element("div", { className: classNames.sheetsBarItems }, [ itemsWrapper ]);
            },

            _createSortable: function() {
                var classNames = SheetsBar.classNames;
                this._sortable = new kendo.ui.Sortable(this.element, {
                    filter: kendo.format("ul li.{0},ul li.{1}", classNames.sheetsBarActive, classNames.sheetsBarInactive),
                    container: DOT + classNames.sheetsBarItems,
                    axis: "x",
                    animation: false,
                    ignore: "input",
                    end: function () {
                        if (this.draggable.hint) {
                            this.draggable.hint.remove();
                        }
                    },
                    hint: function (element) {
                        var hint = $(element).clone();
                        return hint.wrap("<div class='" + classNames.sheetsBarHintWrapper + "'><ul class='" + classNames.sheetsBarKResetItems + "'></ul></div>").closest("div");
                    }
                });
            },

            _onEditorKeydown: function(e) {
                if (this._editor) {
                    if (e.which === 13) {
                        this._destroyEditor();
                    }

                    if (e.which === 27) {
                        this._destroyEditor(true);
                    }
                }
            },

            _onEditorBlur: function() {
                if (this._editor) {
                    this._destroyEditor();
                }
            },

            _onSheetReorderEnd: function(e) {
                e.preventDefault();
                this.trigger("reorder", {oldIndex: e.oldIndex, newIndex: e.newIndex});
            },

            _onSheetReorderStart: function(e) {
                if (this._editor) {
                    e.preventDefault();
                }
            },

            _onSheetRemove: function(e) {
                var removedSheetName = $(e.target).closest("li").text();

                if (this._editor) {
                    this._destroyEditor();
                }

                var closeCallback = function(e) {
                    var dlg = e.sender;

                    if (dlg.isConfirmed()) {
                        this.trigger("remove", { name: removedSheetName, confirmation: true });
                    }
                }.bind(this);

                this._openDialog("confirmation", {
                    close: closeCallback
                });
            },

            _onSheetSelect: function(e) {
                var selectedSheetText = $(e.target).text();

                if ($(e.target).is(DOT + SheetsBar.classNames.sheetsBarEditor) || !selectedSheetText) {
                    e.preventDefault();
                    return;
                }

                if (this._editor) {
                    this._destroyEditor();
                }

                this._scrollSheetsToItem($(e.target).closest("li"));

                this.trigger("select", {name: selectedSheetText, isAddButton: false});
            },

            _onSheetRename: function(newSheetName) {
                if (this._sheets[this._selectedIndex].name() === newSheetName || newSheetName === null) {
                    return;
                }

                this.trigger("rename", {name: newSheetName, sheetIndex: this._selectedIndex });
            },

            _onAddSelect: function() {
                this.trigger("select", {isAddButton: true});
            },

            _addButton: function() {
                var element = kendo.dom.element;
                var classNames = SheetsBar.classNames;
                return element("a", {
                    className: classNames.sheetsBarAdd + EMPTYCHAR + classNames.sheetsBarKButton + EMPTYCHAR + classNames.sheetsBarKButtonDefaults
                }, [element("span", {className: "k-button-icon" + EMPTYCHAR + classNames.sheetsBarKIcon + EMPTYCHAR + classNames.sheetsBarKFontIcon + EMPTYCHAR + classNames.sheetsBarKIconPlus}, [])]);
            },

            destroy: function() {
                this._sortable.destroy();
            },

            _scrollableAllowed: function() {
                var options = this.options;
                return options.scrollable && !isNaN(options.scrollable.distance);
            },

            _scrollSheetsToItem: function (item) {
                var that = this;
                var sheetsGroup = that._sheetsGroup();
                var currentScrollOffset = kendo.scrollLeft(sheetsGroup);
                var itemWidth = outerWidth(item);
                var itemOffset = that._isRtl ? item.position().left : item.position().left - sheetsGroup.children().first().position().left;
                var sheetsGroupWidth = sheetsGroup[0].offsetWidth;
                var itemPosition;

                if (that._isRtl) {
                    if (itemOffset < 0) {
                        itemPosition = currentScrollOffset + itemOffset - (sheetsGroupWidth - currentScrollOffset);
                    } else if (itemOffset + itemWidth > sheetsGroupWidth) {
                        itemPosition = currentScrollOffset + itemOffset - itemWidth;
                    }
                } else {
                    if (currentScrollOffset + sheetsGroupWidth < itemOffset + itemWidth) {
                        itemPosition = itemOffset + itemWidth - sheetsGroupWidth;
                    } else if (currentScrollOffset > itemOffset) {
                        itemPosition = itemOffset;
                    }
                }

                sheetsGroup.finish().animate({ "scrollLeft": itemPosition }, "fast", "linear", function () {
                    that._toggleScrollButtons();
                });
            },

            _sheetsGroup: function() {
                return this._sheetsWrapper().find("ul");
            },

            _sheetsWrapper: function() {
                return this.element.find(DOT + SheetsBar.classNames.sheetsBarItems);
            },

            _scrollSheetsByDelta: function (delta) {
                var that = this;
                var sheetsGroup = that._sheetsGroup();
                var scrLeft = kendo.scrollLeft(sheetsGroup);

                sheetsGroup.finish().animate({ "scrollLeft": scrLeft + delta }, "fast", "linear", function () {
                    if (that._nowScrollingSheets) {
                        that._scrollSheetsByDelta(delta);
                    } else {
                        that._toggleScrollButtons();
                    }
                });
            }
        });

        kendo.spreadsheet.SheetsBar = SheetsBar;
        $.extend(true, SheetsBar, { classNames: sheetsBarClassNames });
    })(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

// -*- fill-column: 100 -*-

(function(f, define){
    define('spreadsheet/calc',[ "./runtime" ], f);
})(function(){
    "use strict";

    // WARNING: removing the following jshint declaration and turning
    // == into === to make JSHint happy will break functionality.
    /* jshint eqnull:true, newcap:false, laxbreak:true, shadow:true, -W054 */
    /* jshint latedef: false */

    var util = kendo.util;
    var spreadsheet = kendo.spreadsheet;
    var Ref = spreadsheet.Ref;
    var RangeRef = spreadsheet.RangeRef;
    var CellRef = spreadsheet.CellRef;
    var NameRef = spreadsheet.NameRef;
    var exports = spreadsheet.calc;
    var runtime = exports.runtime;

    // Excel formula parser and compiler to JS.
    // some code adapted from http://lisperator.net/pltut/

    // these two will hold the same operators, except that when the comma is used as decimal
    // separator, the union operator must be the semicolon (;) instead of comma.
    var OPERATORS_STANDARD = Object.create(null);
    var OPERATORS_COMMA = Object.create(null);

    (function(ops){
        ops.forEach(function(cls, i){
            cls.forEach(function(op){
                OPERATORS_STANDARD[op] = ops.length - i;
                OPERATORS_COMMA[op == "," ? ";" : op] = ops.length - i;
            });
        });
    })([
        [ ":" ],
        [ " " ],
        [ "," ],
        [ "%" ],
        [ "^" ],
        [ "*", "/" ],
        [ "+", "-" ],
        [ "&" ],
        [ "=", "<", ">", "<=", ">=", "<>" ]
    ]);

    var OPERATORS = OPERATORS_STANDARD;

    var SEPARATORS = {
        DEC: ".",
        ARG: ",",
        COL: ","
    };

    function setDecimalSeparator(sep) {
        SEPARATORS.DEC = sep;
        SEPARATORS.ARG = sep == "," ? ";" : ",";
        SEPARATORS.COL = sep == "," ? "\\" : ",";
        OPERATORS = sep == "," ? OPERATORS_COMMA : OPERATORS_STANDARD;
    }

    exports.withDecimalSeparator = function(sep, f) {
        if (SEPARATORS.DEC == sep) {
            return f();
        }
        var save = SEPARATORS.DEC;
        setDecimalSeparator(sep);
        try {
            return f();
        } finally {
            setDecimalSeparator(save);
        }
    };

    exports._separators = SEPARATORS;

    var ParseError = kendo.Class.extend({
        init: function ParseError(message, pos) {
            this.message = message;
            this.pos = pos;
        },
        toString: function() {
            return this.message;
        }
    });

    var TRUE = { type: "bool", value: true };
    var FALSE = { type: "bool", value: false };

    function getcol(str) {
        str = str.toUpperCase();
        for (var col = 0, i = 0; i < str.length; ++i) {
            col = col * 26 + str.charCodeAt(i) - 64;
        }
        return col - 1;
    }

    function getrow(str) {
        return parseInt(str, 10) - 1;
    }

    function parseReference(name, noThrow) {
        if (name.toLowerCase() == "#sheet") {
            return spreadsheet.SHEETREF;
        }
        OUT: {
            // this is redundant, but let's keep it fast for the most
            // common case  A1.  If this fails, we'll try to employ the
            // whole tokenizer.
            var m;
            if ((m = /^(\$)?([a-z]+)(\$)?(\d+)$/i.exec(name))) {
                var row = getrow(m[4]), col = getcol(m[2]);
                if (row < 0x100000 && col < 0x4000) {
                    return new CellRef(getrow(m[4]), getcol(m[2]));
                }
                // no NameRef-s from this function
                break OUT;      // jshint ignore:line
            }
            var stream = TokenStream(name, {});
            var a = [];
            while (true) {
                var ref = stream.next();
                if (ref instanceof CellRef) {
                    // this function always makes absolute references
                    ref.rel = 0;
                } else if (ref instanceof RangeRef) {
                    ref.topLeft.rel = 0;
                    ref.bottomRight.rel = 0;
                } else {
                    break OUT;  // jshint ignore:line
                }
                a.push(ref);
                if (stream.eof()) {
                    break;
                }
                if (!stream.is("op", SEPARATORS.ARG)) {
                    break OUT;  // jshint ignore:line
                }
                stream.next();
            }
            return a.length == 1 ? a[0] : new spreadsheet.UnionRef(a);
        }
        if (!noThrow) {
            throw new Error("Cannot parse reference: " + name);
        }
    }

    function parseFormula(sheet, row, col, input) {
        var refs = [];
        input = TokenStream(input, { row: row, col: col });
        var is = input.is;

        return {
            type: "exp",
            ast: parseExpression(true),
            refs: refs,
            sheet: sheet,
            row: row,
            col: col
        };

        function addReference(ref) {
            ref.index = refs.length;
            refs.push(ref);
            return ref;
        }

        function skip(type, value, allowEOF) {
            if (is(type, value)) {
                return input.next();
            } else {
                var tok = input.peek();
                if (tok) {
                    input.croak("Expected " + type + " " + value + " but found " + tok.type + " " + tok.value + "");
                } else if (!allowEOF) {
                    input.croak("Expected " + type + " " + value + "");
                }
            }
        }

        function parseExpression(commas) {
            return maybeBinary(maybeIntersect(parseAtom()), 0, commas);
        }

        function parseSymbol(tok) {
            if (tok.upper == "TRUE" || tok.upper == "FALSE") {
                return tok.upper == "TRUE" ? TRUE : FALSE;
            }
            return addReference(new NameRef(tok.value));
        }

        function parseFuncall() {
            var fname = input.next();
            fname = fname.value;
            skip("punc", "(");
            var args = [];
            while (1) {
                if (is("punc", ")")) {
                    break;
                }
                if (is("op", SEPARATORS.ARG)) {
                    args.push({ type: "null" });
                    input.next();
                    continue;
                }
                args.push(parseExpression(false));
                if (input.eof() || is("punc", ")")) {
                    break;
                }
                skip("op", SEPARATORS.ARG);
            }
            skip("punc", ")", true);
            return {
                type: "func",
                func: fname,
                args: args
            };
        }

        function fixReference(ref) {
            if (!ref.hasSheet()) {
                ref.setSheet(sheet);
            }
            return addReference(ref);
        }

        function parseAtom() {
            var exp;
            if (is("ref")) {
                exp = fixReference(input.next());
            }
            else if (is("func")) {
                exp = parseFuncall();
            }
            else if (is("punc", "(")) {
                input.next();
                exp = parseExpression(true);
                skip("punc", ")", true);
            }
            else if (is("punc", "{")) {
                input.next();
                exp = parseArray();
                skip("punc", "}", true);
            }
            else if (is("num") || is("str") || is("error")) {
                exp = input.next();
            }
            else if (is("sym")) {
                exp = parseSymbol(input.next());
            }
            else if (is("op", "+") || is("op", "-")) {
                exp = {
                    type: "prefix",
                    op: input.next().value,
                    exp: parseAtom()
                };
            }
            else if (!input.peek()) {
                input.croak("Incomplete expression");
            }
            else if (is("punc", "[")) {
                input.croak("External reference not supported");
            }
            else {
                input.croak("Parse error");
            }
            return maybePercent(exp);
        }

        function parseArray() {
            var row = [], value = [ row ], first = true;
            while (!input.eof() && !is("punc", "}")) {
                if (first) {
                    first = false;
                } else if (is(null, ";")) {
                    value.push(row = []);
                    input.next();
                } else {
                    skip(null, SEPARATORS.COL);
                }
                row.push(parseExpression(false));
            }
            return {
                type: "matrix",
                value: value
            };
        }

        function maybeIntersect(exp) {
            if (is("punc", "(") || is("ref") || is("num") || is("func")) {
                return {
                    type: "binary",
                    op: " ",
                    left: exp,
                    right: parseExpression(false)
                };
            } else {
                return exp;
            }
        }

        function maybePercent(exp) {
            if (is("op", "%")) {
                input.next();
                return maybePercent({
                    type: "postfix",
                    op: "%",
                    exp: exp
                });
            } else {
                return exp;
            }
        }

        function maybeBinary(left, my_prec, commas) {
            var tok = is("op");
            if (tok && (commas || tok.value != SEPARATORS.ARG)) {
                var his_prec = OPERATORS[tok.value];
                if (his_prec > my_prec) {
                    input.next();
                    var right = maybeBinary(parseAtom(), his_prec, commas);
                    return maybeBinary({
                        type: "binary",
                        op: tok.value == ";" ? "," : tok.value, // translate union back to comma
                        left: left,
                        right: right
                    }, my_prec, commas);
                }
            }
            return left;
        }
    }

    function parseNameDefinition(name, def) {
        var nameRef = parseFormula(null, 0, 0, name);
        if (!(nameRef.ast instanceof NameRef)) {
            throw new ParseError("Invalid name: " + name);
        }
        nameRef = nameRef.ast;

        if (!(def instanceof Ref)) {
            var defAST = parseFormula(nameRef.sheet, 0, 0, def);
            if (defAST.ast instanceof Ref) {
                def = defAST.ast;   // single reference
            } else if (/^(?:str|num|bool|error)$/.test(defAST.ast.type)) {
                def = defAST.ast.value; // constant
            } else {
                def = makeFormula(defAST); // formula
            }
        }

        return {
            name: nameRef,
            value: def
        };
    }

    var makeClosure = (function(cache){
        return function(code) {
            var f = cache[code];
            if (!f) {
                f = cache[code] = new Function("'use strict';return(" + code + ")")();
            }
            return f;
        };
    })(Object.create(null));

    function makePrinter(exp) {
        return makeClosure("function(row, col, mod){return(" + print(exp.ast, exp, 0) + ")}");
        function print(node, parent, prec) { // jshint ignore:line, because you are stupid.
            switch (node.type) {
              case "num":
                return "(kendo.spreadsheet.calc._separators.DEC == '.' ? "
                    +  JSON.stringify(JSON.stringify(node.value)) + " : "
                    +  JSON.stringify(JSON.stringify(node.value))
                    +  ".replace('.' , kendo.spreadsheet.calc._separators.DEC))";
              case "bool":
                return JSON.stringify(node.value);
              case "error":
                return JSON.stringify("#" + node.value);
              case "str":
                return JSON.stringify(JSON.stringify(node.value));
              case "ref":
                return "this.refs[" + node.index + "].print(row, col, mod)";
              case "prefix":
                return withParens(function(){
                    return JSON.stringify(node.op) + " + " + print(node.exp, node, OPERATORS[node.op]);
                });
              case "postfix":
                return withParens(function(){
                    return print(node.exp, node, OPERATORS[node.op]) + " + " + JSON.stringify(node.op);
                });
              case "binary":
                return withParens(function(){
                    var left = parenthesize(
                        print(node.left, node, OPERATORS[node.op]),
                        node.left instanceof NameRef && node.op == ":"
                    );
                    var right = parenthesize(
                        print(node.right, node, OPERATORS[node.op]),
                        node.right instanceof NameRef && node.op == ":"
                    );
                    if (/^[,;]/.test(node.op)) {
                        return left + " + kendo.spreadsheet.calc._separators.ARG + " + right;
                    } else {
                        return left + " + " + JSON.stringify(node.op) + " + " + right;
                    }
                });
              case "func":
                return JSON.stringify(node.func + "(") + " + "
                    + (node.args.length > 0
                       ? node.args.map(function(arg){
                           return print(arg, node, 0);
                       }).join(" + kendo.spreadsheet.calc._separators.ARG + ' ' + ")
                       : "''")
                    + " + ')'";
              case "matrix":
                return "'{ ' + " + node.value.map(function(el){
                    return el.map(function(el){
                        return print(el, node, 0);
                    }).join(" + kendo.spreadsheet.calc._separators.COL + ' ' + ");
                }).join(" + '; ' + ") + "+ ' }'";
              case "null":
                return "''";
            }
            throw new Error("Cannot make printer for node " + node.type);

            function withParens(f) {
                var op = node.op;
                var needParens = (OPERATORS[op] < prec
                                  || (!prec && op == ",")
                                  || (parent.type == "prefix" && prec == OPERATORS[op] && parent.op == "-")
                                  || (parent.type == "binary" && prec == OPERATORS[op] && node === parent.right));
                return parenthesize(f(), needParens);
            }
        }
        function parenthesize(code, cond) {
            return cond ? "'(' + " + code + " + ')'" : code;
        }
    }

    function toCPS(ast, k) {
        var GENSYM = 0;
        return cps(ast, k);

        function cps(node, k){
            switch (node.type) {
              case "ref"     : return cpsRef(node, k);
              case "num"     :
              case "str"     :
              case "null"    :
              case "error"   :
              case "bool"    : return cpsAtom(node, k);
              case "prefix"  :
              case "postfix" : return cpsUnary(node, k);
              case "binary"  : return cpsBinary(node, k);
              case "func"    : return cpsFunc(node, k);
              case "lambda"  : return cpsLambda(node, k);
              case "matrix"  : return cpsMatrix(node.value, k, true);
            }
            throw new Error("Cannot CPS " + node.type);
        }

        function cpsRef(node, k) {
            return node.ref == "name" ? cpsNameRef(node, k) : cpsAtom(node, k);
        }

        function cpsAtom(node, k) {
            return k(node);
        }

        function cpsNameRef(node, k) {
            return {
                type: "func",
                func: ",getname",
                args: [ makeContinuation(k), node ]
            };
        }

        function cpsUnary(node, k) {
            return cps({
                type: "func",
                func: "unary" + node.op,
                args: [ node.exp ]
            }, k);
        }

        function cpsBinary(node, k) {
            return cps({
                type: "func",
                func: "binary" + node.op,
                args: [ node.left, node.right ]
            }, k);
        }

        function cpsIf(co, th, el, k) {
            return cps(co, function(co){
                // compile THEN and ELSE into a lambda which takes a callback to invoke with the
                // result of the branches, and the IF itself will become a call the internal "if"
                // function.
                var rest = makeContinuation(k);
                var thenK = gensym("T");
                var elseK = gensym("E");
                return {
                    type: "func",
                    func: "if",
                    args: [
                        rest,
                        co, // condition
                        { // then
                            type: "lambda",
                            vars: [ thenK ],
                            body: cps(th || TRUE, function(th){
                                return {
                                    type: "call",
                                    func: { type: "var", name: thenK },
                                    args: [ th ]
                                };
                            })
                        },
                        { // else
                            type: "lambda",
                            vars: [ elseK ],
                            body: cps(el || FALSE, function(el){
                                return {
                                    type: "call",
                                    func: { type: "var", name: elseK },
                                    args: [ el ]
                                };
                            })
                        }
                    ]
                };
            });
        }

        function cpsAnd(args, k) {
            if (args.length === 0) {
                return cpsAtom(TRUE, k);
            }
            return cps({
                type: "func",
                func: "IF",
                args: [
                    // first item
                    args[0],
                    // if true, apply AND for the rest
                    {
                        type: "func",
                        func: "AND",
                        args: args.slice(1)
                    },
                    // otherwise return false
                    FALSE
                ]
            }, k);
        }

        function cpsOr(args, k) {
            if (args.length === 0) {
                return cpsAtom(FALSE, k);
            }
            return cps({
                type: "func",
                func: "IF",
                args: [
                    // first item
                    args[0],
                    // if true, return true
                    TRUE,
                    // otherwise apply OR for the rest
                    {
                        type: "func",
                        func: "OR",
                        args: args.slice(1)
                    }
                ]
            }, k);
        }

        function cpsFunc(node, k) {
            switch (node.func.toLowerCase()) {
              case "if":
                return cpsIf(node.args[0], node.args[1], node.args[2], k);
              case "and":
                return cpsAnd(node.args, k);
              case "or":
                return cpsOr(node.args, k);
              case "true":
                return k(TRUE);
              case "false":
                return k(FALSE);
            }
            // actual function
            return (function loop(args, i){
                if (i == node.args.length) {
                    return {
                        type : "func",
                        func : node.func,
                        args : args
                    };
                }
                else {
                    return cps(node.args[i], function(value){
                        return loop(args.concat([ value ]), i + 1);
                    });
                }
            })([ makeContinuation(k) ], 0);
        }

        function cpsLambda(node, k) {
            var cont = gensym("K");
            var body = cps(node.body, function(body){
                return { type: "call",
                         func: { type: "var", value: cont },
                         args: [ body ] };
            });
            return k({ type: "lambda",
                       vars: [ cont ].concat(node.vars),
                       body: body });
        }

        function cpsMatrix(elements, k, isMatrix) {
            var a = [];
            return (function loop(i){
                if (i == elements.length) {
                    return k({
                        type: "matrix",
                        value: a
                    });
                } else {
                    return (isMatrix ? cpsMatrix : cps)(elements[i], function(val){
                        a[i] = val;
                        return loop(i + 1);
                    });
                }
            })(0);
        }

        function makeContinuation(k) {
            var cont = gensym("R");
            return {
                type : "lambda",
                vars : [ cont ],
                body : k({ type: "var", name: cont })
            };
        }

        function gensym(name) {
            if (!name) {
                name = "";
            }
            name = "_" + name;
            return name + (++GENSYM);
        }
    }

    var FORMULA_CACHE = Object.create(null);

    function makeFormula(exp) {
        var printer = makePrinter(exp);
        var hash = printer.call(exp); // needs .refs
        var formula = FORMULA_CACHE[hash];
        if (formula) {
            // we need to clone because formulas cache the result; even if the formula is the same,
            // its value will depend on its location, hence we need different objects.  Still, using
            // this cache is a good idea because we'll reuse the same refs array, handler and
            // printer instead of allocating new ones (and we skip compiling it).
            return formula.clone(exp.sheet, exp.row, exp.col);
        }
        var code = js(toCPS(exp.ast, function(ret){
            return {
                type: "return",
                value: ret
            };
        }));

        code = [
            "function(){",
            "var context = this, refs = context.formula.absrefs",
            code,
            "}"
        ].join(";\n");

        formula = new runtime.Formula(exp.refs, makeClosure(code), printer, exp.sheet, exp.row, exp.col);
        FORMULA_CACHE[hash] = formula.clone(exp.sheet, exp.row, exp.col);
        return formula;

        function js(node){
            var type = node.type;
            if (type == "num") {
                return node.value + "";
            }
            else if (type == "str") {
                return JSON.stringify(node.value);
            }
            else if (type == "error") {
                return "context.error(" + JSON.stringify(node.value) + ")";
            }
            else if (type == "return") {
                return "context.resolve(" + js(node.value) + ")";
            }
            else if (type == "func") {
                return "context.func(" + JSON.stringify(node.func) + ", "
                    + js(node.args[0]) + ", " // the callback
                    + jsArray(node.args.slice(1)) // the arguments
                    + ")";
            }
            else if (type == "call") {
                return js(node.func) + "(" + node.args.map(js).join(", ") + ")";
            }
            else if (type == "ref") {
                return "refs[" + node.index + "]";
            }
            else if (type == "bool") {
                return "" + node.value;
            }
            else if (type == "if") {
                return "(context.bool(" + js(node.co) + ") ? " + js(node.th) + " : " + js(node.el) + ")";
            }
            else if (type == "lambda") {
                return "(function("
                    + node.vars.join(", ")
                    + "){ return(" + js(node.body) + ") })";
            }
            else if (type == "var") {
                return node.name;
            }
            else if (type == "matrix") {
                return jsArray(node.value);
            }
            else if (type == "null") {
                return "null";
            }
            else {
                throw new Error("Cannot compile expression " + type);
            }
        }

        function jsArray(a) {
            return "[ " + a.map(js).join(", ") + " ]";
        }
    }

    function identity(x) {
        return x;
    }

    function TokenStream(input, options) {
        input = RawTokenStream(InputStream(input), options);
        var ahead = input.ahead;
        var skip = input.skip;
        var token = null;
        var fixCell = options.row != null && options.col != null
            ? function(cell) {
                if (cell.rel & 1) {
                    cell.col -= options.col;
                }
                if (cell.rel & 2) {
                    cell.row -= options.row;
                }
                return cell;
            }
            : identity;

        var addPos = options.forEditor
            ? function(thing, startToken, endToken) {
                thing.begin = startToken.begin;
                thing.end = endToken.end;
                return thing;
            }
            : identity;

        return {
            peek  : peek,
            next  : next,
            croak : input.croak,
            eof   : input.eof,
            is    : is
        };

        function is(type, value) {
            var tok = peek();
            return tok != null
                && (type == null || tok.type === type)
                && (value == null || tok.value === value)
                ? tok : null;
        }

        function peek() {
            if (token == null) {
                token = readNext();
            }
            return token;
        }

        function next() {
            if (token != null) {
                var tmp = token;
                token = null;
                return tmp;
            }
            return readNext();
        }

        function readNext() {
            var ret;
            var t = input.peek();
            if (t) {
                if (t.type == "sym" || t.type == "rc" || t.type == "num") {
                    ret =  ahead(8, refRange3D)
                        || ahead(6, refCell3D)
                        || ahead(6, refSheetRange)
                        || ahead(4, refSheetCell)
                        || ahead(4, refRange)
                        || ahead(2, refCell)
                        || ahead(2, funcall);
                }
                if (!ret) {
                    ret = input.next();
                }
            }
            return ret;
        }

        function toCell(tok, isFirst) {
            if (tok.type == "rc") {
                // RC notation is read properly without knowing where
                // we are, so no need to fixCell on this one.
                // However, if only absolute refs were asked for (from
                // i.e. parseReference) I feel it's alright to yell
                // about it here.
                if (tok.rel && !options.forEditor && (options.row == null || options.col == null)) {
                    input.croak("Cannot read relative cell in RC notation");
                }
                return new CellRef(tok.row, tok.col, tok.rel);
            }
            if (tok.type == "num") {
                if (tok.value <= 1048577) {
                    // whole row
                    return fixCell(new CellRef(
                        getrow(tok.value),
                        isFirst ? -Infinity : +Infinity,
                        2
                    ));
                } else {
                    return null;
                }
            }
            // otherwise it's "sym".  The OOXML spec (SpreadsheetML
            // 18.2.5) defines the maximum value to be interpreted as
            // a cell reference to be XFD1048576.
            var name = tok.value;
            var m = /^(\$)?([a-z]+)(\$)?(\d+)$/i.exec(name);
            if (m) {
                var row = getrow(m[4]), col = getcol(m[2]);
                if (row <= 1048576 && col <= 16383) {
                    return fixCell(new CellRef(
                        getrow(m[4]),
                        getcol(m[2]),
                        (m[1] ? 0 : 1) | (m[3] ? 0 : 2)
                    ));
                } else {
                    return null;
                }
            }
            var abs = name.charAt(0) == "$";
            if (abs) {
                name = name.substr(1);
            }
            if (/^\d+$/.test(name)) {
                var row = getrow(name);
                if (row <= 1048576) {
                    return fixCell(new CellRef(
                        getrow(name),
                        isFirst ? -Infinity : +Infinity,
                        (abs ? 0 : 2)
                    ));
                }
            } else {
                var col = getcol(name);
                if (col <= 16383) {
                    return fixCell(new CellRef(
                        isFirst ? -Infinity : +Infinity,
                        getcol(name),
                        (abs ? 0 : 1)
                    ));
                }
            }
        }

        // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) :(f) C3(g) not followed by paren (h)
        function refRange3D(a, b, c, d, e, f, g, h) {
            if (a.type == "sym" &&
                b.type == "op" && b.value == ":" &&
                c.type == "sym" &&
                d.type == "punc" && d.value == "!" &&
                (e.type == "sym" || e.type == "rc" || (e.type == "num" && e.value == e.value|0)) &&
                f.type == "op" && f.value == ":" &&
                (g.type == "sym" || g.type == "rc" || (g.type == "num" && g.value == g.value|0)) &&
                g.type == e.type &&
                !(h.type == "punc" && h.value == "(" && !g.space))
            {
                var tl = toCell(e, true), br = toCell(g, false);
                if (tl && br) {
                    // skip them except the last one, we only wanted to
                    // ensure it's not paren.
                    skip(7);
                    return addPos(new RangeRef(
                        tl.setSheet(a.value, true),
                        br.setSheet(c.value, true)
                    ).setSheet(a.value, true), a, g);
                }
            }
        }

        // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) not followed by paren (f)
        function refCell3D(a, b, c, d, e, f) {
            if (a.type == "sym" &&
                b.type == "op" && b.value == ":" &&
                c.type == "sym" &&
                d.type == "punc" && d.value == "!" &&
                (e.type == "sym" || e.type == "rc" || (e.type == "num" && e.value == e.value|0)) &&
                !(f.type == "punc" && f.value == "(" && !e.space))
            {
                var tl = toCell(e);
                if (tl) {
                    skip(5);
                    var br = tl.clone();
                    return addPos(new RangeRef(
                        tl.setSheet(a.value, true),
                        br.setSheet(c.value, true)
                    ).setSheet(a.value, true), a, e);
                }
            }
        }

        // Sheet1(a) !(b) A1(c) :(d) C3(e) not followed by paren (f)
        function refSheetRange(a, b, c, d, e, f) {
            if (a.type == "sym" &&
                b.type == "punc" && b.value == "!" &&
                (c.type == "sym" || c.type == "rc" || (c.type == "num" && c.value == c.value|0)) &&
                d.type == "op" && d.value == ":" &&
                (e.type == "sym" || e.type == "rc" || (e.type == "num" && e.value == e.value|0)) &&
                !(f.type == "punc" && f.value == "(" && !e.space))
            {
                var tl = toCell(c, true), br = toCell(e, false);
                if (tl && br) {
                    skip(5);
                    return addPos(new RangeRef(tl, br).setSheet(a.value, true), a, e);
                }
            }
        }

        // Sheet1(a) !(b) A1(c) not followed by paren (d)
        function refSheetCell(a, b, c, d) {
            if (a.type == "sym" &&
                b.type == "punc" && b.value == "!" &&
                (c.type == "sym" || c.type == "rc" || (c.type == "num" && c.value == c.value|0)) &&
                !(d.type == "punc" && d.value == "(" && !c.space))
            {
                skip(3);
                var x = toCell(c);
                if (!x || !isFinite(x.row)) {
                    x = new NameRef(c.value);
                }
                return addPos(x.setSheet(a.value, true), a, c);
            }
        }

        // A1(a) :(b) C3(c) not followed by paren (d)
        function refRange(a, b, c, d) {
            if ((a.type == "sym" || a.type == "rc" || (a.type == "num" && a.value == a.value|0)) &&
                (b.type == "op" && b.value == ":") &&
                (c.type == "sym" || c.type == "rc" || (c.type == "num" && c.value == c.value|0)) &&
                !(d.type == "punc" && d.value == "(" && !c.space))
            {
                var tl = toCell(a, true), br = toCell(c, false);
                if (tl && br) {
                    skip(3);
                    return addPos(new RangeRef(tl, br), a, c);
                }
            }
        }

        // A1(a) not followed by paren (b)
        function refCell(a, b) {
            if ((a.type == "sym" || a.type == "rc") && !(b.type == "punc" && b.value == "(" && !a.space)) {
                var x = toCell(a);
                if (x && isFinite(x.row) && isFinite(x.col)) {
                    skip(1);
                    return addPos(x, a, a);
                }
            }
        }

        function funcall(a, b) {
            if (a.type == "sym" && b.type == "punc" && b.value == "(" && !a.space) {
                a.type = "func";
                skip(1);
                return a;       // already has position
            }
        }
    }

    function isWhitespace(ch) {
        return " \t\r\n\xa0\u200b".indexOf(ch) >= 0;
    }

    var EOF = { type: "eof" };

    function RawTokenStream(input, options) {
        var tokens = [], index = 0;
        var readWhile = input.readWhile;

        return {
            next  : next,
            peek  : peek,
            eof   : eof,
            croak : input.croak,
            ahead : ahead,
            skip  : skip
        };

        function isDigit(ch) {
            return (/[0-9]/i.test(ch));
        }

        function isIdStart(ch) {
            return (/[a-z$_]/i.test(ch) || util.isUnicodeLetter(ch));
        }

        function isId(ch) {
            return isIdStart(ch) || isDigit(ch) || ch == ".";
        }

        function isOpChar(ch) {
            return ch in OPERATORS;
        }

        function isPunc(ch) {
            return "\\!;(){}[]".indexOf(ch) >= 0;
        }

        function readNumber() {
            // XXX: TODO: exponential notation
            var has_dot = false;
            var number = readWhile(function(ch){
                if (ch == SEPARATORS.DEC) {
                    if (has_dot) {
                        return false;
                    }
                    has_dot = true;
                    return true;
                }
                return isDigit(ch);
            });
            if (number == SEPARATORS.DEC) {
                return { type: "punc", value: SEPARATORS.DEC };
            } else {
                return { type: "num", value: parseFloat(number.replace(SEPARATORS.DEC, ".")) };
            }
        }

        function symbol(id, quote) {
            return {
                type  : "sym",
                value : id,
                upper : id.toUpperCase(),
                space : isWhitespace(input.peek()),
                quote : quote
            };
        }

        function getRC(a, b, c) {
            if (!a && !b && !c) {
                return null;
            }
            if ((!a && !c) || (a && c)) {
                var num = b ? parseInt(b, 10) : 0;
                return a ? num : num - 1;
            }
        }

        function readSymbol() {
            var m = input.lookingAt(/^R(\[)?(-?[0-9]+)?(\])?C(\[)?(-?[0-9]+)?(\])?/i);
            if (m) {
                var row = getRC(m[1], m[2], m[3]);
                var col = getRC(m[4], m[5], m[6]);
                if (row != null && col != null) {
                    input.skip(m);
                    return {
                        type: "rc",
                        row: row,
                        col: col,
                        rel: ((m[4] || !(m[4] || m[5] || m[6]) ? 1 : 0) // col
                              |
                              (m[1] || !(m[1] || m[2] || m[3]) ? 2 : 0) // row
                             )
                    };
                }
            }
            return symbol(readWhile(isId));
        }

        function readString() {
            input.next();
            return { type: "str", value: input.readEscaped('"') };
        }

        function readSheetName() {
            input.next();
            return symbol(input.readEscaped("'"), true);
        }

        function readOperator() {
            return {
                type  : "op",
                value : readWhile(function(ch, op){
                    return (op + ch) in OPERATORS;
                })
            };
        }

        function readPunc() {
            return {
                type  : "punc",
                value : input.next()
            };
        }

        function readNext() {
            if (input.eof()) {
                return null;
            }
            var ch = input.peek(), m;
            if (ch == '"') {
                return readString();
            }
            if (ch == "'") {
                return readSheetName();
            }
            if (isDigit(ch) || ch == SEPARATORS.DEC) {
                return readNumber();
            }
            if (isIdStart(ch)) {
                return readSymbol();
            }
            if (isOpChar(ch)) {
                return readOperator();
            }
            if (isPunc(ch)) {
                return readPunc();
            }
            if ((m = input.lookingAt(/^#([a-z\/]+)[?!]?/i))) {
                input.skip(m);
                return { type: "error", value: m[1] };
            }
            if (!options.forEditor) {
                input.croak("Can't handle character with code: " + ch.charCodeAt(0));
            }
            return { type: "error", value: input.next() };
        }

        function peek() {
            while (tokens.length <= index) {
                readWhile(isWhitespace);
                var begin = input.pos();
                var tok = readNext();
                if (options.forEditor && tok) {
                    tok.begin = begin;
                    tok.end = input.pos();
                }
                tokens.push(tok);
            }
            return tokens[index];
        }

        function next() {
            var tok = peek();
            if (tok) {
                index++;
            }
            return tok;
        }

        function ahead(n, f) {
            var pos = index, a = [];
            while (n-- > 0) {
                a.push(next() || EOF);
            }
            index = pos;
            return f.apply(a, a);
        }

        function skip(n) {
            index += n;
        }

        function eof() {
            return peek() == null;
        }
    }

    function InputStream(input) {
        var pos = 0, line = 1, col = 0;
        return {
            next        : next,
            peek        : peek,
            eof         : eof,
            croak       : croak,
            readWhile   : readWhile,
            readEscaped : readEscaped,
            lookingAt   : lookingAt,
            skip        : skip,
            forward     : forward,
            pos         : location
        };
        function location() { // jshint ignore:line, :-(
            return pos;
        }
        function next() {
            var ch = input.charAt(pos++);
            if (ch == "\n") {
                line++;
                col = 0;
            } else {
                col++;
            }
            return ch;
        }
        function peek() {
            return input.charAt(pos);
        }
        function eof() {
            return peek() === "";
        }
        function croak(msg) {
            throw new ParseError(msg + " (input: " + input + ")", pos);
        }
        function skip(ch) {
            if (typeof ch == "string") {
                if (input.substr(pos, ch.length) != ch) {
                    croak("Expected " + ch);
                }
                forward(ch.length);
            } else if (ch instanceof RegExp) {
                var m = ch.exec(input.substr(pos));
                if (m) {
                    forward(m[0].length);
                    return m;
                }
            } else {
                // assuming RegExp match data
                forward(ch[0].length);
            }
        }
        function forward(n) {
            while (n-- > 0) {
                next();
            }
        }
        function readEscaped(end) {
            var escaped = false, str = "";
            while (!eof()) {
                var ch = next();
                if (escaped) {
                    str += ch;
                    escaped = false;
                } else if (ch == "\\") {
                    escaped = true;
                } else if (ch == end) {
                    break;
                } else {
                    str += ch;
                }
            }
            return str;
        }
        function readWhile(predicate) {
            var str = "";
            while (!eof() && predicate(peek(), str)) {
                str += next();
            }
            return str;
        }
        function lookingAt(rx) {
            return rx.exec(input.substr(pos));
        }
    }

    //// exports

    var FORMAT_PARSERS = [];

    var registerFormatParser = exports.registerFormatParser = function(p) {
        FORMAT_PARSERS.push(p);
    };

    exports.parse = function(sheet, row, col, input, format) {
        if (input instanceof Date) {
            return { type: "date", value: runtime.dateToSerial(input) };
        }
        if (typeof input == "number") {
            return { type: "number", value: input };
        }
        if (typeof input == "boolean") {
            return { type: "boolean", value: input };
        }
        input += "";
        if (/^'/.test(input)) {
            return {
                type: "string",
                value: input.substr(1)
            };
        }
        // trivial (integer) percent values; more complex formats are handled below via
        // registerFormatParser; this case could be dropped completely.
        if (/^-?[0-9]+%$/.test(input)) {
            var str = input.substr(0, input.length - 1);
            var num = parseFloat(str);
            if (!isNaN(num) && num == str) {
                return {
                    type: "percent",
                    value: num / 100
                };
            }
        }
        if (/^=/.test(input)) {
            input = input.substr(1);
            if (/\S/.test(input)) {
                return parseFormula(sheet, row, col, input);
            } else {
                return {
                    type: "string",
                    value: "=" + input
                };
            }
        }
        for (var i = 0; i < FORMAT_PARSERS.length; ++i) {
            var result = FORMAT_PARSERS[i](input);
            if (result) {
                return result;
            }
        }
        if (input.toLowerCase() == "true") {
            return { type: "boolean", value: true };
        }
        if (input.toLowerCase() == "false") {
            return { type: "boolean", value: false };
        }
        var date = runtime.parseDate(input, format);
        if (date) {
            return { type: "date", value: runtime.dateToSerial(date) };
        }
        var num = parseFloat(input);
        if (!isNaN(num) && input.length > 0 && num == input) {
            format = null;
            if (num != Math.floor(num)) {
                format = "0." + String(num).split(".")[1].replace(/\d/g, "0");
            }
            return {
                type: "number",
                value: num,
                format: format
            };
        }
        return {
            type: "string",
            value: input
        };
    };

    function tokenize(input, row, col) {
        var tokens = [];
        input = TokenStream(input, { forEditor: true, row: row, col: col });
        while (!input.eof()) {
            tokens.push(next());
        }
        var tok = tokens[0];
        if (tok.type == "op" && tok.value == "=") {
            tok.type = "startexp";
        }
        return tokens;

        function next() {
            var tok = input.next();
            if (tok.type == "sym") {
                if (tok.upper == "TRUE") {
                    tok.type = "bool";
                    tok.value = true;
                } else if (tok.upper == "FALSE") {
                    tok.type = "bool";
                    tok.value = false;
                }
            } else if (tok.type == "ref") {
                tok = {
                    type  : "ref",
                    ref   : (row != null && col != null ? tok.absolute(row, col) : tok),
                    begin : tok.begin,
                    end   : tok.end
                };
            }
            return tok;
        }
    }

    // The `sqref` attribute in dataValidation (XLSX) will contain a space-separated list of
    // references.  This helper is called from excel-reader.js to parse them.
    function parseSqref(input, row, col) {
        row = row || 0;
        col = col || 0;
        input = TokenStream(input, { row: row, col: col });
        var refs = [];
        while (!input.eof()) {
            var ref = input.next();
            if (ref.type != "ref") {
                throw new ParseError("Expecting a reference but got: " + JSON.stringify(ref));
            }
            refs.push(ref.absolute(row, col));
        }
        return refs;
    }

    exports.parseNameDefinition = parseNameDefinition;
    exports.parseFormula = parseFormula;
    exports.parseReference = parseReference;
    exports.compile = makeFormula;
    exports.parseSqref = parseSqref;

    exports.InputStream = InputStream;
    exports.ParseError = ParseError;
    exports.tokenize = tokenize;

    /* -----[ a few special formats ]----- */

    // various time formats
    registerFormatParser(function(input){
        var m, date = 0, format = "";
        // have date part?
        if ((m = /^(\d+)([-/.])(\d+)\2(\d{2}(?:\d{2})?)(\s*)/.exec(input))) {
            var mo = parseInt(m[1], 10);
            var sep = m[2];
            var da = parseInt(m[3], 10);
            var yr = parseInt(m[4], 10);
            if (yr < 30) {
                yr += 2000;
            } else if (yr < 100) {
                yr += 1900;
            }
            var monthFirst = true;
            if (mo > 12) {
                var tmp = mo;
                mo = da;
                da = tmp;
                monthFirst = false;
            }
            if (!runtime.validDate(yr, mo, da)) {
                return null;
            }
            date = runtime.packDate(yr, mo - 1, da);
            if (date < 0) { date--; }
            if (monthFirst) {
                format = ["mm", "dd", "yyyy"].join(sep);
            } else {
                format = ["dd", "mm", "yyyy"].join(sep);
            }
            format += m[5];
            input = input.substr(m[0].length); // skip the date
        }
        // hh:mm
        if ((m = /^(\d+):(\d+)$/.exec(input))) {
            var hh = parseInt(m[1], 10);
            var mm = parseInt(m[2], 10);
            return {
                type   : "date",
                format : format + "hh:mm",
                value  : date + runtime.packTime(hh, mm, 0, 0)
            };
        }
        // mm:ss.ms
        if ((m = /^(\d+):(\d+)(\.\d+)$/.exec(input))) {
            var mm = parseInt(m[1], 10);
            var ss = parseInt(m[2], 10);
            var ms = parseFloat(m[3]) * 1000;
            return {
                type   : "date",
                format : format + "mm:ss.00",
                value  : date + runtime.packTime(0, mm, ss, ms)
            };
        }
        // hh:mm:ss
        if ((m = /^(\d+):(\d+):(\d+)$/.exec(input))) {
            var hh = parseInt(m[1], 10);
            var mm = parseInt(m[2], 10);
            var ss = parseInt(m[3], 10);
            return {
                type   : "date",
                format : format + "hh:mm:ss",
                value  : date + runtime.packTime(hh, mm, ss, 0)
            };
        }
        // hh:mm:ss.ms
        if ((m = /^(\d+):(\d+):(\d+)(\.\d+)$/.exec(input))) {
            var hh = parseInt(m[1], 10);
            var mm = parseInt(m[2], 10);
            var ss = parseInt(m[3], 10);
            var ms = parseFloat(m[4]) * 1000;
            return {
                type   : "date",
                format : format + "hh:mm:ss.00",
                value  : date + runtime.packTime(hh, mm, ss, ms)
            };
        }
    });

    // Support numeric formats with thousands separator and/or currency symbol, like `1,234,567.00`,
    // `$1234`, `123,456.78 $` etc.  I apologize for this code.
    registerFormatParser(function(input){
        var m, n;
        var culture = kendo.culture();
        var comma = culture.numberFormat[","];
        var dot = culture.numberFormat["."];
        var currency = culture.numberFormat.currency.symbol;
        var rxnum = getNumberRegexp(comma, dot);
        var rxcur = new RegExp("^\\s*\\" + currency + "\\s*");
        var sign = 1;
        var format = "";
        var suffix = "";
        var has_currency = false;
        var has_percent = false;

        input = InputStream(input.replace(/^\s+|\s+$/g, ""));

        // has minus before currency?
        if (input.skip(/^-\s*/)) {
            sign = -1;
        }

        // has currency before number?
        if ((m = input.skip(rxcur))) {
            has_currency = true;
            format += '"' + m[0] + '"';
        }

        // has minus after currency?
        if (input.skip(/^-\s*/)) {
            if (sign < 0) {
                return null;    // not a number
            }
            sign = -1;
        }

        // read the number itself
        if (!(n = input.skip(rxnum))) {
            return null;        // not a number
        }
        format += "0";

        // has currency after number?
        if ((m = input.skip(rxcur))) {
            if (has_currency) {
                return null;    // either before or after, not both.
            }
            has_currency = true;
            suffix = '"' + m[0] + '"';
        }

        // has percent after number?
        if (!has_currency && (m = input.skip(/^\s*%\s*/))) {
            has_percent = true;
            suffix = m[0];      // no quotes this time, % is special in format
        }

        if (!input.eof()) {
            return null;        // should anything else follow, not a number
        }

        if (n[2] || has_currency) {
            format = format.replace("0", "#");
            format += ",0";
        }
        if (n[3]) {
            format += "." + repeat("0", n[3].length - 1);
        }
        var value = n[0]
            .replace(new RegExp("\\" + comma, "g"), "")
            .replace(new RegExp("\\" + dot, "g"), ".");

        value = parseFloat(value);
        if (has_percent) {
            value /= 100;
        }

        format += suffix;
        if (has_currency) {
            format += ';-' + format;
        }

        return {
            type: "number",
            currency: has_currency,
            format: format,
            value: sign * value
        };
    });

    registerFormatParser(function(input){
        var m;
        if ((m = /^([0-9]*)\.([0-9]+)(\s*%)$/.exec(input))) {
            return {
                type: "number",
                value: parseFloat(input) / 100,
                format: "0." + repeat("0", m[2].length) + m[3]
            };
        }
    });

    var NUMBER_FORMAT_RX = {};
    function getNumberRegexp(comma, dot) {
        var id = comma + dot;
        var rx = NUMBER_FORMAT_RX[id];
        if (!rx) {
            rx = "^(\\d+(COM\\d{3})*(DOT\\d+)?)";
            rx = rx.replace(/DOT/g, "\\" + dot).replace(/COM/g, "\\" + comma);
            rx = new RegExp(rx);
            NUMBER_FORMAT_RX[id] = rx;
        }
        return rx;
    }

    function repeat(str, len) {
        var out = "";
        while (len-- > 0) {
            out += str;
        }
        return out;
    }

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/excel-reader',[ "../kendo.core", "../kendo.color", "../util/parse-xml", "./calc" ], f);
})(function(){
    "use strict";

    /* global JSZip */

    // WARNING: removing the following jshint declaration and turning
    // == into === to make JSHint happy will break functionality.
    /* jshint eqnull:true, laxbreak:true */
    /* jshint latedef: nofunc */

    var $ = kendo.jQuery;
    var parseXML = kendo.util.parseXML;
    var parseReference = kendo.spreadsheet.calc.parseReference;

    var MAP_EXCEL_OPERATOR = {
        // includes only what differs; key is Excel's operator, value
        // is our operator.
        greaterThanOrEqual : "greaterThanOrEqualTo",
        lessThanOrEqual    : "lessThanOrEqualTo"
    };

    var ERROR_LOG = null;

    function readExcel(file, workbook, deferred) {
        var reader = new FileReader();
        reader.onload = function(e) {
            var zip = new JSZip(e.target.result);
            readWorkbook(zip, workbook, deferred);
        };

        reader.readAsArrayBuffer(file);
    }

    var SEL_CELL = ["sheetData", "row", "c"];
    var SEL_COL = ["cols", "col"];
    var SEL_DEFINED_NAME = ["definedNames", "definedName"];
    var SEL_FORMULA = ["sheetData", "row", "c", "f"];
    var SEL_MERGE = ["mergeCells", "mergeCell"];
    var SEL_PANE = ["sheetViews", "sheetView", "pane"];
    var SEL_ROW = ["sheetData", "row"];
    var SEL_SELECTION = ["sheetViews", "sheetView", "selection"];
    var SEL_SHEET = ["sheets", "sheet"];
    var SEL_STRING = ["sheetData", "row", "c", "is"];
    var SEL_TEXT = ["t"];
    var SEL_SHARED_STRING = ["si"];
    var SEL_VALUE = ["sheetData", "row", "c", "v"];
    var SEL_VIEW = ["bookViews", "workbookView"];
    var SEL_SHEET_VIEW = ["sheetViews", "sheetView"];
    var SEL_HYPERLINK = ["hyperlinks", "hyperlink"];

    /* A validation section looks like this:
     *
     * <dataValidations count="1">
     *   <dataValidation type="list" allowBlank="1" showInputMessage="1" showErrorMessage="1" sqref="B2">
     *     <formula1>$E$2:$E$5</formula1>
     *   </dataValidation>
     * </dataValidations>
     */
    var SEL_VALIDATION = ["dataValidations", "dataValidation"];
    var SEL_VALIDATION_FORMULA1 = ["dataValidations", "dataValidation", "formula1"];
    var SEL_VALIDATION_FORMULA2 = ["dataValidations", "dataValidation", "formula2"];

    /* However, when a validation formula in one sheet references
     * cells from another sheet, Excel produces this version instead:
     *
     * <extLst>
     *   <ext xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" uri="{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}">
     *     <x14:dataValidations xmlns:xm="http://schemas.microsoft.com/office/excel/2006/main" count="1">
     *       <x14:dataValidation type="list" allowBlank="1" showInputMessage="1" showErrorMessage="1">
     *         <x14:formula1>
     *           <xm:f>Sheet2!$B$3:$B$6</xm:f>
     *         </x14:formula1>
     *         <xm:sqref>B1</xm:sqref>
     *       </x14:dataValidation>
     *     </x14:dataValidations>
     *   </ext>
     * </extLst>
     *
     * I call it the "insane version", because that's what it is.
     * Barring the case that the engineers who produced this horror
     * were on LSD, the only plausible reason for it is that Microsoft
     * does not want third party software to be compatible with Excel
     * (sentiment I've had over and over while working on the
     * Spreadsheet widget).
     */
    // XXX: technically, the aliases `x14` and `xm` below could be
    // different, but Excel seems to be hard-coded on these; our
    // parser does not support proper namespaces for now anyway, so
    // hard-coded they are.
    var SEL_VALIDATION_INSANE = ["x14:dataValidations", "x14:dataValidation"];
    var SEL_VALIDATION_SQREF_INSANE = ["x14:dataValidations", "x14:dataValidation", "xm:sqref"];
    var SEL_VALIDATION_FORMULA1_INSANE = ["x14:dataValidations", "x14:dataValidation", "x14:formula1", "xm:f"];
    var SEL_VALIDATION_FORMULA2_INSANE = ["x14:dataValidations", "x14:dataValidation", "x14:formula2", "xm:f"];

    // comment selectors (in files like comments1.xml)
    var SEL_COMMENT = ["commentList", "comment"];
    var SEL_AUTHOR = ["authors", "author"];
    var SEL_COMMENT_TEXT = ["t"];

    function xl(file) {
        if (!/^\//.test(file)) {
            if (!/^xl\//.test(file)) {
                file = "xl/" + file;
            }
        } else {
            file = file.substr(1);
        }
        return file;
    }

    function readWorkbook(zip, workbook, progress) {
        ERROR_LOG = workbook.excelImportErrors = [];

        var strings = readStrings(zip);
        var relationships = readRelationships(zip, "_rels/workbook.xml");
        var theme = readTheme(zip, relationships.byType.theme[0]);
        var styles = readStyles(zip, theme);
        var items = [];
        var activeSheet = 0;

        parse(zip, "xl/workbook.xml", {
            enter: function(tag, attrs) {
                if (this.is(SEL_SHEET)) {
                    var relId = attrs["r:id"];
                    var file = relationships.byId[relId];
                    var name = attrs.name;
                    var dim = sheetDimensions(zip, file);

                    workbook.options.columnWidth = dim.columnWidth || workbook.options.columnWidth;
                    workbook.options.rowHeight = dim.rowHeight || workbook.options.rowHeight;

                    items.push({
                        workbook: workbook,
                        zip: zip,
                        strings: strings,
                        styles: styles,
                        file: file,
                        options: {
                            name: name,
                            rows: Math.max(workbook.options.rows || 0, dim.rows),
                            columns: Math.max(workbook.options.columns || 0, dim.cols),
                            columnWidth: dim.columnWidth,
                            rowHeight: dim.rowHeight
                        }
                    });
                } else if (this.is(SEL_VIEW)) {
                    if (attrs.activeTab) {
                        activeSheet = integer(attrs.activeTab);
                    }
                }
            },
            text: function(text) {
                var attrs = this.is(SEL_DEFINED_NAME);
                if (attrs && !(bool(attrs["function"]) || bool(attrs.vbProcedure))) {
                    var localSheetId = attrs.localSheetId;
                    var sheet = null;
                    if (localSheetId != null) {
                        sheet = items[localSheetId].options.name;
                    }
                    var name = attrs.name;
                    if (name != "_xlnm._FilterDatabase") {
                        if (sheet) {
                            name = "'" + sheet.replace(/\'/g, "\\'") + "'!" + name;
                        }
                        withErrorLog(sheet, null, function(){
                            workbook.defineName(name, text, bool(attrs.hidden));
                        }, "reading user-defined name: " + name);
                    }
                }
            }
        });

        var loading = new $.Deferred();
        loading.progress(function(args) {
            if (progress) {
                progress.notify(args);
            }
        })
        .then(function() {
            var sheets = workbook.sheets();
            recalcSheets(sheets);

            workbook.activeSheet(sheets[activeSheet]);

            if (progress) {
                progress.resolve();
            }
        });

        loadSheets(items, workbook, loading);
    }

    function loadSheets(items, workbook, progress) {
        var ready = (new $.Deferred()).resolve();
        for (var i = 0; i < items.length; i++) {
            /*jshint -W083 */
            (function(entry, i) {
                ready = ready.then(function() {
                    var sheet = workbook.insertSheet(entry.options);
                    sheet.suspendChanges(true);

                    var promise = queueSheet(sheet, entry);
                    var args = {
                        sheet: sheet,
                        progress: i / (items.length - 1)
                    };

                    promise.then(function() {
                        progress.notify(args);
                    });

                    return promise;
                });
            })(items[i], i);
        }

        ready.then(function() {
            progress.resolve();
        });
    }

    function queueSheet(sheet, ctx) {
        var deferred = new $.Deferred();

        setTimeout(function() {
            readSheet(ctx.zip, ctx.file, sheet, ctx.strings, ctx.styles);
            deferred.resolve();
        }, 0);

        return deferred;
    }

    function recalcSheets(sheets) {
        for (var i = 0; i < sheets.length; i++) {
            sheets[i]
                .suspendChanges(false)
                .triggerChange({ recalc: true });
        }
    }

    function sheetDimensions(zip, file) {
        var ref, dim = {
            rows: 0,
            cols: 0
        };

        parse(zip, xl(file), {
            enter: function(tag, attrs) {
                if (tag == "dimension") {
                    ref = parseReference(attrs.ref);
                    if (ref.bottomRight) {
                        dim.cols = ref.bottomRight.col + 1;
                        dim.rows = ref.bottomRight.row + 1;
                    }
                } else if (tag === "sheetFormatPr") {
                    if (attrs.defaultColWidth) {
                        dim.columnWidth = toColWidth(parseFloat(attrs.defaultColWidth));
                    }

                    if (attrs.defaultRowHeight) {
                        dim.rowHeight = toRowHeight(parseFloat(attrs.defaultRowHeight));
                    }
                } else if (this.is(SEL_ROW) && attrs.r) {
                    dim.rows = Math.max(dim.rows, +attrs.r);
                } else if (this.is(SEL_CELL) && attrs.r) {
                    ref = parseReference(attrs.r);
                    dim.rows = Math.max(dim.rows, ref.row + 1);
                    dim.cols = Math.max(dim.cols, ref.col + 1);
                }
            }
        });

        return dim;
    }

    function toColWidth(size) {
        // No font to compute agains, hence the magic number
        var maximumDigitWidth = 7;

        // The formula below is taken from the OOXML spec
        var fraction = (256 * size + Math.floor(128 / maximumDigitWidth)) / 256;
        return fraction * maximumDigitWidth;
    }

    function toRowHeight(pts) {
        return pts * (4 / 3);
    }

    function readSheet(zip, file, sheet, strings, styles) {
        var sharedFormulas = {};
        var ref, type, value, formula, formulaRange, isArrayFormula;
        var nCols = sheet._columns._count;
        var prevCellRef = null;
        var relsFile = file.replace(/worksheets\//, "worksheets/_rels/");
        var relationships = readRelationships(zip, relsFile);
        var formula1, formula2;

        var filterRef;
        var filterColumn;
        var customFilterLogic;
        var customFilterCriteria;
        var valueFilterBlanks;
        var valueFilterValues;
        var filters = [];

        ERROR_LOG = sheet._workbook.excelImportErrors;

        file = xl(file);

        parse(zip, file, {
            enter: function(tag, attrs, closed) {
                var tmp;
                if (this.is(SEL_FORMULA)) {
                    if (closed) {
                        if (attrs.t == "shared" && attrs.si != null) {
                            formula = sheet.range(sharedFormulas[attrs.si])._get("formula");
                        }
                    }
                }
                else if (this.is(SEL_CELL)) {
                    value = null;
                    formula = null;
                    ref = attrs.r;
                    formulaRange = null;

                    if (ref == null) {
                        // apparently some tools omit the `r` for
                        // consecutive cells in a row, so we'll figure
                        // it out from the previous cell's reference.
                        // XXX: this could be slightly optimized by
                        // keeping it parsed instead of stringifying
                        // it to parse it again later.
                        ref = parseReference(prevCellRef);
                        ref.col++;
                        ref = ref.toString();
                    }
                    prevCellRef = ref;

                    // XXX: can't find no type actually, so everything is
                    // interpreted as string.  Additionally, cells having
                    // a formula will contain both <f> and <v> nodes,
                    // which makes the value take precedence because it's
                    // the second node; hence, the hack is to keep note of
                    // them in the `text` handler, and apply the
                    // appropriate one in the `leave` handler below.
                    type = attrs.t;

                    var styleIndex = attrs.s;
                    if (styleIndex != null) {
                        applyStyle(sheet, ref, styles, styleIndex);
                    }
                }
                else if (this.is(SEL_MERGE)) {
                    sheet.range(attrs.ref).merge();
                }
                else if (this.is(SEL_COL)) {
                    var start = integer(attrs.min) - 1;
                    var stop = Math.min(nCols, integer(attrs.max)) - 1;
                    var width;
                    if (attrs.width) {
                        width = toColWidth(parseFloat(attrs.width));
                        if (width !== 0) {
                            sheet._columns.values.value(start, stop, width);
                        }
                    }
                    if (attrs.hidden === "1" || width === 0) {
                        for (var ci = start; ci <= stop; ci++) {
                            sheet.hideColumn(ci);
                        }
                    }
                    if (attrs.style != null) {
                        // apply style on a whole range of columns
                        applyStyle(sheet, new kendo.spreadsheet.RangeRef(
                            new kendo.spreadsheet.CellRef(-Infinity, start),
                            new kendo.spreadsheet.CellRef(+Infinity, stop)
                        ), styles, attrs.style);
                    }
                }
                else if (this.is(SEL_ROW)) {
                    var row = integer(attrs.r) - 1;
                    var height;
                    if (attrs.ht) {
                        height = toRowHeight(parseFloat(attrs.ht));
                        if (height !== 0) {
                            sheet._rows.values.value(row, row, height);
                        }
                    }
                    if (attrs.hidden === "1" || height === 0) {
                        sheet.hideRow(row);
                    }
                }
                else if (this.is(SEL_SELECTION)) {
                    if (attrs.activeCell) {
                        var acRef = parseReference(attrs.activeCell);
                        sheet.select(acRef, true);
                    }
                }
                else if (this.is(SEL_PANE)) {
                    if (attrs.state && attrs.state.indexOf("frozen") > -1) {
                        if (attrs.xSplit) {
                            sheet.frozenColumns(integer(attrs.xSplit));
                        }

                        if (attrs.ySplit) {
                            sheet.frozenRows(integer(attrs.ySplit));
                        }
                    }
                }
                else if (this.is(SEL_SHEET_VIEW)) {
                    sheet.showGridLines(bool(attrs.showGridLines, true));
                }
                else if (this.is(SEL_HYPERLINK)) {
                    var relId = attrs["r:id"];
                    var target = relationships.byId[relId];
                    if (target) {
                        sheet.range(attrs.ref).link(target);
                    }
                }
                else if (this.is(["autoFilter"])) {
                    filterRef = attrs.ref;
                    if (closed) {
                        addAutoFilter();
                    }
                }
                else if (filterRef) {
                    if (this.is(["filterColumn"])) {
                        filterColumn = parseInt(attrs.colId, 10);
                    }
                    else if (this.is(["customFilters"])) {
                        customFilterLogic = bool(attrs.and) ? "and" : "or";
                        customFilterCriteria = [];
                    }
                    else if (this.is(["customFilter"])) {
                        tmp = getCustomFilter(attrs.operator, attrs.val);
                        if (tmp) {
                            customFilterCriteria.push({
                                operator: tmp.operator,
                                value: tmp.value
                            });
                        }
                    }
                    else if (this.is(["dynamicFilter"])) {
                        filters.push({
                            column: filterColumn,
                            filter: new kendo.spreadsheet.DynamicFilter({
                                type: dynamicFilterType(attrs.type)
                            })
                        });
                    }
                    else if (this.is(["top10"])) {
                        filters.push({
                            column: filterColumn,
                            filter: new kendo.spreadsheet.TopFilter({
                                value: getFilterVal(attrs.val),
                                type: (function(percent, top){
                                    return percent && top ? "topPercent"
                                        :  top ? "topNumber"
                                        :  percent ? "bottomPercent"
                                        :  "bottomNumber";
                                })(bool(attrs.percent), bool(attrs.top))
                            })
                        });
                    }
                    else if (this.is(["filters"])) {
                        valueFilterBlanks = bool(attrs.blank);
                        valueFilterValues = [];
                    }
                    else if (this.is(["filter"])) {
                        valueFilterValues.push(getFilterVal(attrs.val));
                    }
                }
            },
            leave: function(tag, attrs) {
                if (this.is(SEL_FORMULA)) {
                    if (!formula && attrs.t == "shared" && attrs.si != null) {
                        formula = sheet.range(sharedFormulas[attrs.si])._get("formula");
                    }
                }
                else if (this.is(SEL_CELL)) {
                    if (formula != null) {
                        var failed = withErrorLog(sheet, formulaRange || ref, function(){
                            sheet.range(formulaRange || ref).formula(formula, isArrayFormula);
                        }, "parsing formula");
                        if (failed) {
                            sheet.range(formulaRange || ref).value(formula)
                                .background("#ffaaaa");
                        }
                    } else if (value != null) {
                        var range = sheet.range(ref);

                        if (!range._get("formula")) {
                            // Check for "shared" formulas before applying a value.
                            if (!type || type == "n") {
                                value = parseFloat(value);
                            } else if (type == "s") {
                                value = strings[integer(value)];
                            } else if (type == "b") {
                                value = value === "1";
                            } else if (type == "d") {
                                value = kendo.parseDate(value);
                            }

                            if (value != null) {
                                range.value(value);
                            }
                        }
                    }
                } else if (this.is(SEL_VALIDATION) ||
                           this.is(SEL_VALIDATION_INSANE)) {
                    (function(){
                        var refs = kendo.spreadsheet.calc.parseSqref(attrs.sqref);
                        var type = attrs.type.toLowerCase();
                        var operator = attrs.operator;
                        if (/^(?:whole|decimal)$/.test(type)) {
                            // we only support "number"
                            type = "number";
                        } else if (type == "list") {
                            // there'll be no operator from Excel for lists
                            operator = "list";
                        }
                        if (!operator && /^(?:number|date)$/.test(type)) {
                            // Excel skips setting the operator for
                            // "between", because why not.
                            operator = "between";
                        }
                        refs.forEach(function(ref){
                            withErrorLog(sheet, ref, function(){
                                sheet.range(ref).validation({
                                    type             : bool(attrs.showErrorMessage, true) ? "reject" : "warning",
                                    from             : formula1,
                                    to               : formula2,
                                    dataType         : type,
                                    comparerType     : MAP_EXCEL_OPERATOR[operator] || operator,
                                    allowNulls       : bool(attrs.allowBlank),
                                    showButton       : bool(attrs.showDropDown) || type == "date" || type == "list",
                                    messageTemplate  : attrs.error,
                                    titleTemplate    : attrs.errorTitle
                                });
                            }, "parsing validation");
                        });
                    })();
                } else if (tag == "cols") {
                    sheet._columns._refresh();
                } else if (tag == "sheetData") {
                    sheet._rows._refresh();
                } else if (tag == "autoFilter") {
                    addAutoFilter();
                } else if (filterRef) {
                    if (tag == "customFilters") {
                        filters.push({
                            column: filterColumn,
                            filter: new kendo.spreadsheet.CustomFilter({
                                logic: customFilterLogic,
                                criteria: customFilterCriteria
                            })
                        });
                    } else if (tag == "filters") {
                        filters.push({
                            column: filterColumn,
                            filter: new kendo.spreadsheet.ValueFilter({
                                values: valueFilterValues,
                                blanks: valueFilterBlanks
                            })
                        });
                    }
                }
            },
            text: function(text) {
                var attrs;
                if (this.is(SEL_VALUE) || this.is(SEL_STRING)) {
                    value = text;
                } else if ((attrs = this.is(SEL_FORMULA))) {
                    formula = text;
                    isArrayFormula = attrs.t == "array";
                    if (isArrayFormula) {
                        formulaRange = attrs.ref;
                    } else if (attrs.t == "shared") {
                        sharedFormulas[attrs.si] = ref;
                    }
                } else if (this.is(SEL_VALIDATION_FORMULA1) ||
                           this.is(SEL_VALIDATION_FORMULA1_INSANE)) {
                    formula1 = text;
                } else if (this.is(SEL_VALIDATION_FORMULA2) ||
                           this.is(SEL_VALIDATION_FORMULA2_INSANE)) {
                    formula2 = text;
                } else if (this.is(SEL_VALIDATION_SQREF_INSANE)) {
                    // put it in <dataValidation>'s attributes where it should be
                    this.stack[this.stack.length - 2].sqref = text;
                }
            }
        });

        if (relationships.byType.comments) {
            var commentFile = relative_file(file, relationships.byType.comments[0]);
            readComments(zip, commentFile, sheet);
        }

        if (relationships.byType.drawing) {
            var drawingFile = relative_file(file, relationships.byType.drawing[0]);
            readDrawings(zip, drawingFile, sheet);
        }

        function addAutoFilter() {
            sheet.range(filterRef).filter(filters);
            filterRef = null;
        }
    }

    function getContentType(filename) {
        var m = /\.([^.]+)$/.exec(filename);
        if (m && m[1]) {
            return {
                jpg  : "image/jpeg",
                jpeg : "image/jpeg",
                png  : "image/png",
                gif  : "image/gif"
            }[m[1].toLowerCase()];
        }
    }

    function getFileName(filename) {
        var m = /[^/]+$/.exec(filename);
        return m && m[0];
    }

    function readDrawings(zip, file, sheet) {
        var sel_two_cell_anchor = [ "xdr:twoCellAnchor" ];
        var sel_ext = [ "xdr:ext" ];
        var sel_one_cell_anchor = [ "xdr:oneCellAnchor" ];
        var sel_from = [ "xdr:from" ];
        var sel_to = [ "xdr:to" ];
        var sel_row = [ "xdr:row" ];
        var sel_col = [ "xdr:col" ];
        var sel_row_offset = [ "xdr:rowOff" ];
        var sel_col_offset = [ "xdr:colOff" ];
        var sel_blip = [ "xdr:blipFill", "a:blip" ];

        var relsFile = file.replace(/drawings\//, "drawings/_rels/");
        var relationships = readRelationships(zip, relsFile);

        if (relationships.byType.image) {
            Object.keys(relationships.byId).forEach(function(id){
                var img = relative_file(file, relationships.byId[id]);
                var type = getContentType(img);

                if (type) {
                    // XXX: file.asArrayBuffer() is deprecated in JSZip 3
                    var data = zip.files[img].asArrayBuffer();
                    var name = getFileName(img);
                    var blob = name && !(kendo.support.browser.msie || kendo.support.browser.edge)
                        ? new window.File([ data ], name, { type: type })
                        : new window.Blob([ data ], { type: type });
                    relationships.byId[id] = sheet._workbook.addImage(blob);
                }
            });
        }

        var cdr, ref, width, height;
        parse(zip, file, {
            enter: function(tag, attrs) {
                if (this.is(sel_two_cell_anchor) || this.is(sel_one_cell_anchor)) {
                    cdr = {};
                }
                else if (this.is(sel_from) || this.is(sel_to)) {
                    ref = {};
                }
                else if (this.is(sel_blip)) {
                    var id = attrs["r:embed"];
                    cdr.image = relationships.byId[id];
                }
                else if (this.is(sel_ext)) {
                    width = excelToPixels(parseFloat(attrs.cx));
                    height = excelToPixels(parseFloat(attrs.cy));
                }
            },
            leave: function() {
                if (this.is(sel_from)) {
                    cdr.topLeftCell = new kendo.spreadsheet.CellRef(ref.row, ref.col);
                    cdr.offsetX = excelToPixels(ref.colOffset);
                    cdr.offsetY = excelToPixels(ref.rowOffset);
                }
                else if (this.is(sel_to)) {
                    cdr.brCell = new kendo.spreadsheet.CellRef(ref.row, ref.col);
                    cdr.brX = excelToPixels(ref.colOffset);
                    cdr.brY = excelToPixels(ref.rowOffset);
                }
                // Add drawing only when it is image
                else if (this.is(sel_two_cell_anchor) && cdr.image) {
                    var left = sheet._columns.sum(0, cdr.topLeftCell.col - 1) + cdr.offsetX;
                    var top = sheet._rows.sum(0, cdr.topLeftCell.row - 1) + cdr.offsetY;
                    var right = sheet._columns.sum(0, cdr.brCell.col - 1) + cdr.brX;
                    var bottom = sheet._rows.sum(0, cdr.brCell.row - 1) + cdr.brY;

                    sheet.addDrawing({
                        topLeftCell : cdr.topLeftCell,
                        offsetX     : cdr.offsetX,
                        offsetY     : cdr.offsetY,
                        width       : width != null ? width : right - left,
                        height      : height != null ? height : bottom - top,
                        image       : cdr.image,
                        opacity     : 1
                    });
                }
                // Add drawing only when it is image
                else if (this.is(sel_one_cell_anchor) && cdr.image) {
                    sheet.addDrawing({
                        topLeftCell : cdr.topLeftCell,
                        offsetX     : cdr.offsetX,
                        offsetY     : cdr.offsetY,
                        width       : width,
                        height      : height,
                        image       : cdr.image,
                        opacity     : 1
                    });
                }
            },
            text: function(text) {
                if (this.is(sel_row)) {
                    ref.row = parseFloat(text);
                }
                else if (this.is(sel_col)) {
                    ref.col = parseFloat(text);
                }
                else if (this.is(sel_row_offset)) {
                    ref.rowOffset = parseFloat(text);
                }
                else if (this.is(sel_col_offset)) {
                    ref.colOffset = parseFloat(text);
                }
            }
        });
    }

    function readComments(zip, file, sheet) {
        var authors = [];
        var author;
        var comment;
        parse(zip, file, {
            enter: function(tag, attrs) {
                if (this.is(SEL_COMMENT)) {
                    comment = {
                        author: authors[attrs.authorId],
                        ref: attrs.ref,
                        text: ""
                    };
                } else if (this.is(SEL_AUTHOR)) {
                    author = "";
                }
            },
            leave: function() {
                if (this.is(SEL_COMMENT)) {
                    sheet.range(comment.ref).comment(comment.text);
                } else if (this.is(SEL_AUTHOR)) {
                    authors.push(author);
                }
            },
            text: function(text) {
                if (this.is(SEL_COMMENT_TEXT)) {
                    comment.text += text;
                } else if (this.is(SEL_AUTHOR)) {
                    author += text;
                }
            }
        });
    }

    function getCustomFilter(op, value) {
        var ourOp = {
            equal               : "eq",
            notEqual            : "ne",
            greaterThan         : "gt",
            greaterThanOrEqual  : "gte",
            lessThan            : "lt",
            lessThanOrEqual     : "lte"
        }[op];

        value = getFilterVal(value);

        if (ourOp && typeof value == "number") {
            return { operator: ourOp, value: value };
        }

        if ((op == "notEqual" || !op) && typeof value == "string") {
            // Excel text operators support * and ? wildcards.  Since
            // our startswith/endswith/contains filters do not, we
            // can't really use them here, so we'll apply the more
            // generic "matches" and "doesnotmatch" filters.
            return {
                operator: op ? "doesnotmatch" : "matches",
                value: value
            };
        }
    }

    function dynamicFilterType(type) {
        return {
            Q1  : "quarter1",
            Q2  : "quarter2",
            Q3  : "quarter3",
            Q4  : "quarter4",
            M1  : "january",
            M2  : "february",
            M3  : "march",
            M4  : "april",
            M5  : "may",
            M6  : "june",
            M7  : "july",
            M8  : "august",
            M9  : "september",
            M10 : "october",
            M11 : "november",
            M12 : "december"
        }[type.toUpperCase()] || type;
    }

    function getFilterVal(val) {
        var tmp = parseFloat(val);
        if (!isNaN(tmp) && tmp == val) {
            return tmp;
        }
        return val;
    }

    function withErrorLog(sheet, ref, func, context) {
        try {
            func();
            return false;
        } catch(ex) {
            var err = { context: context, error: String(ex) };
            if (sheet && sheet.name) {
                err.sheet = sheet.name();
            } else if (sheet) {
                err.sheet = sheet;
            }
            if (ref) {
                err.location = String(ref);
            }
            ERROR_LOG.push(err);
            return true;
        }
    }

    var BORDER_WIDTHS = {
        "none"            : 0,
        "thin"            : 1,
        "medium"          : 2,
        "dashed"          : 1,
        "dotted"          : 1,
        "thick"           : 3,
        "double"          : 3,
        "hair"            : 1,
        "mediumDashed"    : 2,
        "dashDot"         : 1,
        "mediumDashDot"   : 2,
        "dashDotDot"      : 1,
        "mediumDashDotDot": 2,
        "slantDashDot"    : 1
    };

    var DEFAULT_FORMATS = {
        0  : "General",
        1  : "0",
        2  : "0.00",
        3  : "#,##0",
        4  : "#,##0.00",
        9  : "0%",
        10 : "0.00%",
        11 : "0.00E+00",
        12 : "# ?/?",
        13 : "# ??/??",
        14 : "mm-dd-yy",
        15 : "d-mmm-yy",
        16 : "d-mmm",
        17 : "mmm-yy",
        18 : "h:mm AM/PM",
        19 : "h:mm:ss AM/PM",
        20 : "h:mm",
        21 : "h:mm:ss",
        22 : "m/d/yy h:mm",
        37 : "#,##0 ;(#,##0)",
        38 : "#,##0 ;[Red](#,##0)",
        39 : "#,##0.00;(#,##0.00)",
        40 : "#,##0.00;[Red](#,##0.00)",
        45 : "mm:ss",
        46 : "[h]:mm:ss",
        47 : "mmss.0",
        48 : "##0.0E+0",
        49 : "@"
    };

    function applyStyle(sheet, ref, styles, styleIndex) {
        var range = sheet.range(ref);
        var xf = styles.inlineStyles[styleIndex], base, value;
        if (xf.xfId) {
            base = styles.namedStyles[xf.xfId];
        }
        if (shouldSet("applyBorder", "borderId")) {
            setBorder(styles.borders[value]);
        }
        if (shouldSet("applyFont", "fontId")) {
            setFont(styles.fonts[value]);
        }
        if (shouldSet("applyAlignment", "textAlign")) {
            range.textAlign(value);
        }
        if (shouldSet("applyAlignment", "verticalAlign")) {
            range.verticalAlign(value);
        }
        if (shouldSet("applyAlignment", "indent")) {
            range.indent(value);
        }
        if (shouldSet("applyAlignment", "wrapText")) {
            // don't use range.wrap to avoid recomputing row height
            range._property("wrap", value);
        }
        if (shouldSet("applyFill", "fillId")) {
            setFill(styles.fills[value]);
        }
        if (shouldSet("applyNumberFormat", "numFmtId")) {
            setFormat(styles.numFmts[value] || DEFAULT_FORMATS[value]);
        }

        function setFormat(f) {
            var format = typeof f == "string" ? f : f.formatCode;
            if (format != null && !/^general$/i.test(format)) {
                // XXX: drop locale info.
                // http://stackoverflow.com/questions/894805/excel-number-format-what-is-409
                // not supported by the formatting library.
                format = format.replace(/^\[\$-[0-9]+\]/, "");
                range.format(format);
            }
        }

        function setFill(f) {
            if (f.type == "solid") {
                range.background(f.color);
            }
        }

        function setFont(f) {
            range.fontFamily(f.name);
            //range.fontSize(f.size); //XXX: will recalc row height.
            // converting from points to pixels
            if (f.size) {
                range._property("fontSize", f.size * 4 / 3);
            }
            if (f.bold) {
                range.bold(true);
            }
            if (f.italic) {
                range.italic(true);
            }
            if (f.underline) {
                range.underline(true);
            }
            if (f.color) {
                range.color(f.color);
            }
        }

        function setBorder(b) {
            function set(side, prop) {
                var border = b[side];
                if (!border) {
                    return;
                }

                var width = BORDER_WIDTHS[border.style];
                if (width === 0) {
                    return;
                }

                var color = border.color;
                if (color == null) {
                    color = "#000";
                }

                range._property(prop, { size: width, color: color });
            }

            set("left", "borderLeft");
            set("top", "borderTop");
            set("right", "borderRight");
            set("bottom", "borderBottom");
        }

        function shouldSet(applyName, propName) {
            var t = xf[applyName];
            if (t != null && !t) {
                return false;
            }
            value = xf[propName];
            if (base && value == null) {
                t = base[applyName];
                if (t != null && !t) {
                    return false;
                }
                value = base[propName];
            }
            return value != null;
        }
    }

    function parse(zip, file, callbacks) {
        var part = zip.files[file];
        if (part) {
            parseXML(part.asUint8Array(), callbacks);
        }
    }

    function readStrings(zip) {
        var strings = [];
        var current = null;
        parse(zip, "xl/sharedStrings.xml", {
            leave: function() {
                if (this.is(SEL_SHARED_STRING)) {
                    strings.push(current);
                    current = null;
                }
            },
            text: function(text) {
                if (this.is(SEL_TEXT)) {
                    if (current == null) {
                        current = "";
                    }
                    current += text;
                }
            }
        });
        return strings;
    }

    function readRelationships(zip, file) {
        var map = { byId: {}, byType: { theme: [] } };
        parse(zip, xl(file) + ".rels", {
            enter: function(tag, attrs) {
                if (tag == "Relationship") {
                    map.byId[attrs.Id] = attrs.Target;

                    var type = attrs.Type.match(/\w+$/)[0];
                    var entries = map.byType[type] || [];
                    entries.push(attrs.Target);
                    map.byType[type] = entries;
                }
            }
        });
        return map;
    }

    var SEL_BORDER = ["borders", "border"];
    var SEL_FILL = ["fills", "fill"];
    var SEL_FONT = ["fonts", "font"];
    var SEL_INLINE_STYLE = ["cellXfs", "xf"];
    var SEL_NAMED_STYLE = ["cellStyleXfs", "xf"];
    var SEL_NUM_FMT = ["numFmts", "numFmt"];

    var INDEXED_COLORS = [
        toCSSColor("FF000000"), toCSSColor("FFFFFFFF"), toCSSColor("FFFF0000"),
        toCSSColor("FF00FF00"), toCSSColor("FF0000FF"), toCSSColor("FFFFFF00"),
        toCSSColor("FFFF00FF"), toCSSColor("FF00FFFF"), toCSSColor("FF000000"),
        toCSSColor("FFFFFFFF"), toCSSColor("FFFF0000"), toCSSColor("FF00FF00"),
        toCSSColor("FF0000FF"), toCSSColor("FFFFFF00"), toCSSColor("FFFF00FF"),
        toCSSColor("FF00FFFF"), toCSSColor("FF800000"), toCSSColor("FF008000"),
        toCSSColor("FF000080"), toCSSColor("FF808000"), toCSSColor("FF800080"),
        toCSSColor("FF008080"), toCSSColor("FFC0C0C0"), toCSSColor("FF808080"),
        toCSSColor("FF9999FF"), toCSSColor("FF993366"), toCSSColor("FFFFFFCC"),
        toCSSColor("FFCCFFFF"), toCSSColor("FF660066"), toCSSColor("FFFF8080"),
        toCSSColor("FF0066CC"), toCSSColor("FFCCCCFF"), toCSSColor("FF000080"),
        toCSSColor("FFFF00FF"), toCSSColor("FFFFFF00"), toCSSColor("FF00FFFF"),
        toCSSColor("FF800080"), toCSSColor("FF800000"), toCSSColor("FF008080"),
        toCSSColor("FF0000FF"), toCSSColor("FF00CCFF"), toCSSColor("FFCCFFFF"),
        toCSSColor("FFCCFFCC"), toCSSColor("FFFFFF99"), toCSSColor("FF99CCFF"),
        toCSSColor("FFFF99CC"), toCSSColor("FFCC99FF"), toCSSColor("FFFFCC99"),
        toCSSColor("FF3366FF"), toCSSColor("FF33CCCC"), toCSSColor("FF99CC00"),
        toCSSColor("FFFFCC00"), toCSSColor("FFFF9900"), toCSSColor("FFFF6600"),
        toCSSColor("FF666699"), toCSSColor("FF969696"), toCSSColor("FF003366"),
        toCSSColor("FF339966"), toCSSColor("FF003300"), toCSSColor("FF333300"),
        toCSSColor("FF993300"), toCSSColor("FF993366"), toCSSColor("FF333399"),
        toCSSColor("FF333333"),
        toCSSColor("FF000000"), // System Foreground
        toCSSColor("FFFFFFFF")  // System Background
    ];

    function readStyles(zip, theme) {
        var styles = {
            fonts        : [],
            numFmts      : {},
            fills        : [],
            borders      : [],
            namedStyles  : [],
            inlineStyles : []
        };
        var font = null;
        var fill = null;
        var border = null;
        var xf = null;
        parse(zip, "xl/styles.xml", {
            enter: function(tag, attrs, closed) {
                if (this.is(SEL_NUM_FMT)) {
                    styles.numFmts[attrs.numFmtId] = attrs;
                }
                else if (this.is(SEL_FONT)) {
                    styles.fonts.push(font = {});
                    if (closed) {
                        // apparently, there's XLSX in the wild with
                        // <font/>, because why not (also, <border/>).
                        // if we don't null the variable, we always
                        // enter below and effectively ignore the rest
                        // of the file.
                        font = null;
                    }
                } else if (font) {
                    if (tag == "sz") {
                        font.size = parseFloat(attrs.val);
                    } else if (tag == "name") {
                        font.name = attrs.val;
                    } else if (tag == "b") {
                        font.bold = bool(attrs.val, true);
                    } else if (tag == "i") {
                        font.italic = bool(attrs.val, true);
                    } else if (tag == "u") {
                        font.underline = (attrs.val == null || attrs.val == "single");
                    } else if (tag == "color") {
                        font.color = getColor(attrs, null);
                    }
                }
                else if (this.is(SEL_FILL)) {
                    styles.fills.push(fill = {});
                    if (closed) {
                        fill = null;
                    }
                } else if (fill) {
                    if (tag == "patternFill") {
                        fill.type = attrs.patternType;
                    } else if (tag == "fgColor" && fill.type === "solid") {
                        fill.color = getColor(attrs, INDEXED_COLORS[0]);
                    } else if (tag == "bgColor" && fill.type !== "solid") {
                        fill.color = getColor(attrs, INDEXED_COLORS[0]);
                    }
                }
                else if (this.is(SEL_BORDER)) {
                    styles.borders.push(border = {});
                    if (closed) {
                        border = null;
                    }
                } else if (border) {
                    if (/^(?:left|top|right|bottom)$/.test(tag)) {
                        border[tag] = { style: attrs.style || "none" };
                    }
                    if (tag == "color") {
                        var side = this.stack[this.stack.length - 2].$tag;
                        border[side].color = getColor(attrs, INDEXED_COLORS[0]);
                    }
                }
                else if (this.is(SEL_NAMED_STYLE)) {
                    xf = getXf(attrs);
                    styles.namedStyles.push(xf);
                    if (closed) {
                        xf = null;
                    }
                } else if (this.is(SEL_INLINE_STYLE)) {
                    xf = getXf(attrs);
                    styles.inlineStyles.push(xf);
                    if (closed) {
                        xf = null;
                    }
                } else if (xf) {
                    if (tag == "alignment") {
                        if (/^(?:left|center|right|justify)$/.test(attrs.horizontal)) {
                            xf.textAlign = attrs.horizontal;
                        }
                        if (/^(?:top|center|bottom)$/.test(attrs.vertical)) {
                            xf.verticalAlign = attrs.vertical;
                        }
                        if (attrs.wrapText != null) {
                            xf.wrapText = bool(attrs.wrapText);
                        }
                        if (attrs.indent != null) {
                            xf.indent = integer(attrs.indent);
                        }
                    }
                }
            },
            leave: function(tag) {
                if (this.is(SEL_FONT)) {
                    font = null;
                } else if (this.is(SEL_FILL)) {
                    fill = null;
                } else if (this.is(SEL_BORDER)) {
                    border = null;
                } else if (tag == "xf") {
                    xf = null;
                }
            }
        });

        function getXf(attrs) {
            var xf = {
                borderId          : integer(attrs.borderId),
                fillId            : integer(attrs.fillId),
                fontId            : integer(attrs.fontId),
                numFmtId          : integer(attrs.numFmtId),
                pivotButton       : bool(attrs.pivotButton),
                quotePrefix       : bool(attrs.quotePrefix),
                xfId              : integer(attrs.xfId)
            };
            addBool("applyAlignment");
            addBool("applyBorder");
            addBool("applyFill");
            addBool("applyFont");
            addBool("applyNumberFormat");
            addBool("applyProtection");
            function addBool(name) {
                if (attrs[name] != null) {
                    xf[name] = bool(attrs[name]);
                }
            }
            return xf;
        }

        function getColor(attrs, defaultThemeColor) {
            if (attrs.rgb) {
                return toCSSColor(attrs.rgb);
            } else if (attrs.indexed) {
                return INDEXED_COLORS[integer(attrs.indexed)];
            } else if (attrs.theme) {
                var themeColor = theme.colorScheme[integer(attrs.theme)];
                if (!themeColor) {
                    // returning black by default for font color causes
                    // https://github.com/telerik/kendo-ui-core/issues/5826
                    // in default cell style, color is undefined
                    return defaultThemeColor;
                }

                var color = kendo.parseColor(themeColor);

                if (attrs.tint) {
                    color = color.toHSL();

                    var tint = parseFloat(attrs.tint);
                    if (tint < 0) {
                        color.l = color.l * (1 + tint);
                    } else {
                        color.l = color.l * (1 - tint) + (100 - 100 * (1 - tint));
                    }
                }

                return color.toCssRgba();
            }
        }

        return styles;
    }

    var SEL_SCHEME_RGBCLR = ["a:clrScheme", "*", "a:srgbClr"];
    var SEL_SCHEME_SYSCLR = ["a:clrScheme", "*", "a:sysClr"];
    function readTheme(zip, rel) {
        var scheme = [];
        var theme = {
            colorScheme: scheme
        };

        var file = xl(rel);
        if (zip.files[file]) {
            parse(zip, file, {
                enter: function(tag, attrs) {
                    if (this.is(SEL_SCHEME_SYSCLR)) {
                        scheme.push(toCSSColor(
                            attrs.val == "window" ? "FFFFFFFF" : "FF000000"
                        ));
                    } else if (this.is(SEL_SCHEME_RGBCLR)) {
                        scheme.push(toCSSColor("FF" + attrs.val));
                    }
                }
            });

            if (scheme.length > 3) {
                // lt1 <-> dk1
                swap(scheme, 0, 1);
                // lt2 <-> dk2
                swap(scheme, 2, 3);
            }
        }

        function swap(arr, a, b) {
            var tmp = arr[a];
            arr[a] = arr[b];
            arr[b] = tmp;
        }

        return theme;
    }

    function integer(val) {
        return val == null ? null : parseInt(val, 10);
    }

    function bool(val, def) {
        if (val == null) {
            return def;
        }
        return val == "true" || val === true || val == 1;
    }

    function toCSSColor(rgb) {
        var m = /^([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(rgb);
        return "rgba(" +
            parseInt(m[2], 16) + ", " +
            parseInt(m[3], 16) + ", " +
            parseInt(m[4], 16) + ", " +
            parseInt(m[1], 16) / 255 + ")";
    }

    function relative_file(base, name) {
        base = base.split(/\/+/);
        name = name.split(/\/+/);
        base.pop();
        while (name.length) {
            var part = name.shift();
            if (part === "") {
                base = [];      // absolute
            } else if (part === ".") {
                continue;
            } else if (part === "..") {
                base.pop();
            } else {
                base.push(part);
            }
        }
        return base.join("/");
    }

    function excelToPixels(val) {
        return val / 9525;
    }

    kendo.spreadsheet.readExcel = readExcel;
    kendo.spreadsheet._readSheet = readSheet;
    kendo.spreadsheet._readStrings = readStrings;
    kendo.spreadsheet._readStyles = readStyles;
    kendo.spreadsheet._readTheme = readTheme;
    kendo.spreadsheet._readWorkbook = readWorkbook;

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/workbook',[ "../kendo.core", "./runtime", "./references", "./excel-reader" ], f);
})(function(){

(function(kendo) {

    // jshint latedef: nofunc
    // jshint eqnull: true, laxbreak: true

    var $ = kendo.jQuery;
    var Formula = kendo.spreadsheet.calc.runtime.Formula;
    var Ref = kendo.spreadsheet.Ref;
    var CalcError = kendo.spreadsheet.CalcError;

    kendo.spreadsheet.messages.workbook = {
        defaultSheetName: "Sheet"
    };

    function loadBinary(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
            callback(xhr.response, xhr.getResponseHeader("Content-Type"));
        };
        xhr.onerror = function() {
            callback(null);
        };
        xhr.open("GET", url);
        xhr.responseType = "arraybuffer";
        xhr.send();
    }

    var Workbook = kendo.Observable.extend({
        options: {},

        init: function(options, view) {
            kendo.Observable.fn.init.call(this);

            this.options = options;

            this._view = view;
            this._sheets = [];
            this._images = {};
            this._imgID = 0;

            this._sheetsSearchCache = {};

            this._sheet = this.insertSheet({
                rows: this.options.rows,
                columns: this.options.columns,
                rowHeight: this.options.rowHeight,
                columnWidth: this.options.columnWidth,
                headerHeight: this.options.headerHeight,
                headerWidth: this.options.headerWidth,
                dataSource: this.options.dataSource
            });

            this.undoRedoStack = new kendo.util.UndoRedoStack();
            this.undoRedoStack.bind(["undo", "redo"], this._onUndoRedo.bind(this));

            this._context = new kendo.spreadsheet.FormulaContext(this);
            this._validationContext = new kendo.spreadsheet.ValidationFormulaContext(this);
            this._names = Object.create(null);

            this.fromJSON(this.options);
        },

        clipboard: function() {
            if(!this._clipboard) {
                 this._clipboard = new kendo.spreadsheet.Clipboard(this);
            }
            return this._clipboard;
        },

        destroy: function() {
            this.unbind();

            if (this._clipboard) {
                this._clipboard.destroy();
            }
        },

        events: [
            "cut",
            "copy",
            "paste",
            "changing",
            "change",
            "excelImport",
            "excelExport",
            "insertSheet",
            "removeSheet",
            "selectSheet",
            "renameSheet",
            "insertRow",
            "insertColumn",
            "deleteRow",
            "deleteColumn",
            "hideRow",
            "hideColumn",
            "unhideRow",
            "unhideColumn",
            "select",
            "changeFormat",
            "dataBinding",
            "dataBound",
            "progress"
        ],

        _sheetChanging: function(e) {
            if (this.trigger("changing", e)) {
                e.preventDefault();
            }
        },

        _sheetChange: function(e) {
            this.trigger("change", e);
        },

        _sheetInsertRow: function(e) {
            if (this.trigger("insertRow", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        },

        _sheetInsertColumn: function(e) {
            if (this.trigger("insertColumn", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        },

        _sheetDeleteRow: function(e) {
            if (this.trigger("deleteRow", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        },

        _sheetDeleteColumn: function(e) {
            if (this.trigger("deleteColumn", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        },

        _sheetHideRow: function(e) {
            if (this.trigger("hideRow", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        },

        _sheetHideColumn: function(e) {
            if (this.trigger("hideColumn", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        },

        _sheetUnhideRow: function(e) {
            if (this.trigger("unhideRow", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        },

        _sheetUnhideColumn: function(e) {
            if (this.trigger("unhideColumn", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        },

        _sheetSelect: function(e) {
            this.trigger("select", e);
        },

        _sheetDataBinding: function(e) {
            if (this.trigger("dataBinding", {
                sheet: e.sender
            })) {
                e.preventDefault();
            }
        },

        _sheetDataBound: function(e) {
            this.trigger("dataBound", {
                sheet: e.sender
            });
        },

        _sheetProgress: function(e) {
            var that = this;

            setTimeout(function() {
                that.trigger("progress", {
                    toggle: e.toggle
                });
            });
        },

        _sheetCommandRequest: function(e) {
            this.trigger("commandRequest", e);
        },

        _inputForRef: function(ref) {
            var self = this;
            return self._sheet.withCultureDecimals(function(){
                return new kendo.spreadsheet.Range(ref, self._sheet).input();
            });
        },

        _onUndoRedo: function(e) {
            e.command.range().select();
        },

        execute: function(options) {
            var commandOptions = $.extend({ workbook: this }, options.options);
            var command = new kendo.spreadsheet[options.command](commandOptions);
            var sheet = this.activeSheet();

            if (commandOptions.origin) {
                command.origin(commandOptions.origin);
            }

            if (commandOptions.operatingRange) {
                command.range(commandOptions.operatingRange);
            } else {
                command.range(sheet.selection());
            }

            if (commandOptions.editRange) {
                command._editRange = commandOptions.editRange;
            }

            var result = command.exec();

            if (!result || result.reason !== "error") {
                if (!command.cannotUndo) {
                    this.undoRedoStack.push(command);
                }
            }

            // when the undo/redo stack is truncated (by e.g. adding a
            // non-redo command after undoing) it's possible to
            // discard images from the dropped commands.
            this.cleanupImages();

            return result;
        },

        resetFormulas: function() {
            this._sheets.forEach(function(sheet){
                sheet.resetFormulas();
            });
        },

        resetValidations: function() {
            this._sheets.forEach(function(sheet){
                sheet.resetValidations();
            });
        },

        refresh: function(reason) {
            if (reason.recalc) {
                this.resetFormulas();
                this.resetValidations();
                this._sheet.recalc(this._context);
                this._sheet.revalidate(this._validationContext);
            }
        },

        activeSheet: function(sheet) {
            if (sheet === undefined) {
                return this._sheet;
            }

            if (!this.sheetByName(sheet.name())) {
                return;
            }

            this._sheet = sheet;

            //TODO: better way to get all reasons?
            sheet.triggerChange(kendo.spreadsheet.ALL_REASONS);
        },

        moveSheetToIndex: function(sheet, toIndex) {
            var fromIndex = this.sheetIndex(sheet);
            var sheets = this._sheets;

            if (fromIndex === -1) {
                return;
            }

            this._sheetsSearchCache = {};

            sheets.splice(toIndex, 0, sheets.splice(fromIndex, 1)[0]);

            this.trigger("change", { sheetSelection: true });
        },

        insertSheet: function(options) {
            options = options || {};
            var that = this;
            var insertIndex = typeof options.index === "number" ? options.index : that._sheets.length;
            var sheetName;
            var sheets = that._sheets;

            var getUniqueSheetName = function(sheetNameSuffix) {
                sheetNameSuffix = sheetNameSuffix ? sheetNameSuffix : 1;

                var name = kendo.spreadsheet.messages.workbook.defaultSheetName + sheetNameSuffix;

                if (!that.sheetByName(name)) {
                    return name;
                }

                return getUniqueSheetName(sheetNameSuffix + 1);
            };

            if (options.name && that.sheetByName(options.name)) {
                return;
            }

            this._sheetsSearchCache = {};

            sheetName = options.name || getUniqueSheetName();

            var sheet = new kendo.spreadsheet.Sheet(
                options.rows || this.options.rows,
                options.columns || this.options.columns,
                options.rowHeight || this.options.rowHeight,
                options.columnWidth || this.options.columnWidth,
                options.headerHeight || this.options.headerHeight,
                options.headerWidth || this.options.headerWidth,
                options.defaultCellStyle || this.options.defaultCellStyle
            );

            sheet._workbook = this;

            sheet._name(sheetName);

            this._bindSheetEvents(sheet);

            sheets.splice(insertIndex, 0, sheet);

            if (options.data) {
                sheet.fromJSON(options.data);
            }

            if (options.dataSource) {
                sheet.setDataSource(options.dataSource);
            }

            this.trigger("change", { sheetSelection: true });

            return sheet;
        },

        _bindSheetEvents: function(sheet) {
            sheet.bind("changing", this._sheetChanging.bind(this));
            sheet.bind("change", this._sheetChange.bind(this));
            sheet.bind("insertRow", this._sheetInsertRow.bind(this));
            sheet.bind("insertColumn", this._sheetInsertColumn.bind(this));
            sheet.bind("deleteRow", this._sheetDeleteRow.bind(this));
            sheet.bind("deleteColumn", this._sheetDeleteColumn.bind(this));
            sheet.bind("hideRow", this._sheetHideRow.bind(this));
            sheet.bind("hideColumn", this._sheetHideColumn.bind(this));
            sheet.bind("unhideRow", this._sheetUnhideRow.bind(this));
            sheet.bind("unhideColumn", this._sheetUnhideColumn.bind(this));
            sheet.bind("select", this._sheetSelect.bind(this));
            sheet.bind("commandRequest", this._sheetCommandRequest.bind(this));
            sheet.bind("dataBinding", this._sheetDataBinding.bind(this));
            sheet.bind("dataBound", this._sheetDataBound.bind(this));
            sheet.bind("progress", this._sheetProgress.bind(this));
        },

        sheets: function() {
            return this._sheets.slice();
        },

        sheetByName: function (sheetName) {
            return this._sheets[this.sheetIndex(sheetName)];
        },

        sheetByIndex: function(index) {
            return this._sheets[index];
        },

        sheetIndex: function(sheet) {
            var sheets = this._sheets;
            var sheetName = (typeof sheet == "string" ? sheet : sheet.name()).toLowerCase();
            var idx = this._sheetsSearchCache[sheetName];

            if (idx >= 0) {
                return idx;
            }

            for(idx = 0; idx < sheets.length; idx++) {
                var name = sheets[idx].name().toLowerCase();
                this._sheetsSearchCache[name] = idx;

                if (name === sheetName) {
                    return idx;
                }
            }

            return -1;
        },

        renameSheet: function(sheet, newSheetName) {
            var oldSheetName = sheet.name().toLowerCase();

            if (!newSheetName ||
                oldSheetName === newSheetName.toLowerCase() ||
                this.sheetByName(newSheetName)) {
                return;
            }

            sheet = this.sheetByName(oldSheetName);

            if (!sheet) {
                return;
            }

            this._sheetsSearchCache = {};

            if (this.trigger("renameSheet", {
                sheet: sheet,
                newSheetName: newSheetName
            })) {
                return;
            }

            // update references
            this._sheets.forEach(function(sheet){
                sheet._forFormulas(function(formula){
                    formula.renameSheet(oldSheetName, newSheetName);
                });
            });

            this.forEachName(function(def, name){
                // 1. redefine sheet-local names
                if (def.nameref.renameSheet(oldSheetName, newSheetName)) {
                    this.undefineName(name);
                    def.name = def.nameref.print();
                    this.nameDefinition(def.name, def);
                }
                // 2. if the value is reference or formula, update it
                if (def.value instanceof Ref || def.value instanceof Formula) {
                    def.value.renameSheet(oldSheetName, newSheetName);
                }
            }.bind(this));

            sheet._name(newSheetName);

            this.trigger("change", { sheetSelection: true });

            return sheet;
        },

        removeSheet: function(sheet) {
            var that = this;
            var sheets = that._sheets;
            var name = sheet.name();
            var index = that.sheetIndex(sheet);

            if (sheets.length === 1) {
                return;
            }

            if (this.trigger("removeSheet", { sheet: sheet })) {
                return;
            }

            this._sheetsSearchCache = {};

            if (index > -1) {
                sheet.unbind();

                sheets.splice(index, 1);

                if (that.activeSheet().name() === name) {
                    var newSheet = sheets[index === sheets.length ? index-1 : index];
                    that.activeSheet(newSheet);
                } else {
                    this.trigger("change", { recalc: true,  sheetSelection: true });
                }
            }
        },

        _clearSheets: function() {
            for (var i = 0; i < this._sheets.length; i++) {
                this._sheets[i]._activeDrawing = [];
                this._sheets[i]._drawings = [];
                this._sheets[i].unbind();
            }
            this._sheets = [];
            this._sheetsSearchCache = {};
            this._names = {};
            this._images = {};
            this._imgID = 0;
        },

        // _loadImages: function() {
        //     var self = this;
        //     var ids = Object.keys(self._images);
        //     var count = ids.length;
        //     if (count) {
        //         ids.forEach(function(id){
        //             var img = self._images[id];
        //             if (!img.blob) {
        //                 loadBinary(img.url, function(data, type) {
        //                     // XXX: can we do something better in case of error?
        //                     if (data != null) {
        //                         img.blob = new Blob([ data ], { type: type });
        //                         delete img.url;
        //                     }
        //                     next();
        //                 });
        //             }
        //         });
        //     } else {
        //         next();
        //     }
        //     function next() {
        //         if (--count <= 0) {
        //             self.activeSheet().triggerChange({ layout: true });
        //         }
        //     }
        // },

        fromJSON: function(json) {
            if (json.sheets) {
                this._clearSheets();

                if (json.images) {
                    this._imgID = 0;
                    this._images = {};
                    Object.keys(json.images).forEach(function(id){
                        if (!isNaN(id)) {
                            var num = parseFloat(id);
                            if (isFinite(num)) {
                                this._imgID = Math.max(this._imgID, num);
                            }
                        }
                        this._images[id] = { url: json.images[id] };
                    }, this);
                    // this._loadImages();
                }

                for (var idx = 0; idx < json.sheets.length; idx++) {
                    var data = json.sheets[idx];
                    var args = sheetParamsFromJSON(data, this.options);
                    var sheet = this.insertSheet({
                        rows         : args.rowCount,
                        columns      : args.columnCount,
                        rowHeight    : args.rowHeight,
                        columnWidth  : args.columnWidth,
                        headerHeight : args.headerHeight,
                        headerWidth  : args.headerWidth,
                        data         : data
                    });

                    if (data.dataSource) {
                        sheet.setDataSource(data.dataSource);
                    }
                }
            }

            if (json.activeSheet) {
                this.activeSheet(this.sheetByName(json.activeSheet));
            } else {
                this.activeSheet(this._sheets[0]);
            }

            if (json.names) {
                json.names.forEach(function(def){
                    this.defineName(def.name, def.value, def.hidden);
                }, this);
            }
        },

        toJSON: function() {
            this.resetFormulas();
            this.resetValidations();
            var names = Object.keys(this._names).map(function(name){
                var def = this._names[name];
                var val = def.value;
                if (val instanceof Ref || val instanceof Formula) {
                    val = val.print(0, 0, true);
                } else if (val instanceof CalcError) {
                    val = val + "";
                } else {
                    val = JSON.stringify(val);
                }
                return {
                    value     : val,
                    hidden    : def.hidden,
                    name      : def.name,

                    // these two are not really useful in
                    // deserialization, but are handy in OOXML export.
                    sheet     : def.nameref.sheet,
                    localName : def.nameref.name
                };
            }, this);
            return {
                activeSheet: this.activeSheet().name(),
                sheets: this._sheets.map(function(sheet) {
                    sheet.recalc(this._context);
                    sheet.revalidate(this._validationContext);
                    return sheet.toJSON();
                }, this),
                names: names,
                columnWidth: this.options.columnWidth,
                rowHeight: this.options.rowHeight
            };
        },

        saveJSON: function() {
            var self = this;
            var deferred = new $.Deferred();
            var data = self.toJSON();
            var ids = Object.keys(self._images).filter(function(id){
                return self.usesImage(id) === 1;
            });
            var count = ids.length;
            data.images = {};
            if (count) {
                ids.forEach(function(id){
                    var img = self._images[id];
                    if (img.blob) {
                        var reader = new FileReader();
                        reader.onload = function() {
                            data.images[id] = reader.result;
                            next();
                        };
                        reader.readAsDataURL(img.blob);
                    } else {
                        data.images[id] = img.url;
                        next();
                    }
                });
            } else {
                next();
            }
            return deferred.promise();

            function next() {
                if (--count <= 0) {
                    deferred.resolve(data);
                }
            }
        },

        fromFile: function(file) {
            var deferred = new $.Deferred();
            var promise = deferred.promise();
            var args = { file: file, promise: promise };

            if (file && !this.trigger("excelImport", args)) {
                this._clearSheets();
                kendo.spreadsheet.readExcel(file, this, deferred);
            } else {
                deferred.reject();
            }

            return promise;
        },

        saveAsExcel: function(options) {
            var self = this;
            options = $.extend({}, self.options.excel, options);
            var data = self.toJSON();

            if (self.trigger("excelExport", { workbook: data })) {
                return;
            }

            var ids = Object.keys(self._images).filter(function(id){
                return self.usesImage(id) === 1;
            });
            var count = ids.length;
            var images = count ? {} : null;
            if (count) {
                ids.forEach(function(id){
                    var img = self._images[id];
                    if (img.blob) {
                        var reader = new FileReader();
                        reader.onload = function() {
                            images[id] = {
                                type: img.blob.type,
                                name: img.blob.name,
                                data: reader.result
                            };
                            next();
                        };
                        reader.readAsArrayBuffer(img.blob);
                    } else {
                        loadBinary(img.url, function(data, type){
                            images[id] = { type: type, data: data };
                            next();
                        });
                    }
                });
            } else {
                next();
            }

            function next() {
                if (--count <= 0) {
                    data.images = images;
                    var workbook = new kendo.ooxml.Workbook(data);
                    kendo.saveAs({
                        dataURI: options.forceProxy ? workbook.toDataURL() : workbook.toBlob(),
                        fileName: data.fileName || options.fileName,
                        proxyURL: options.proxyURL,
                        forceProxy: options.forceProxy
                    });
                }
            }
        },

        draw: function(options, callback) {
            if (typeof options == "function" && !callback) {
                callback = options;
                options = {};
            }
            var parts = [], sheets = this._sheets;
            (function loop(i){
                if (i < sheets.length) {
                    sheets[i].draw(kendo.spreadsheet.SHEETREF, options, function(group){
                        parts.push(group);
                        loop(i + 1);
                    });
                } else {
                    var group = parts[0];
                    for (i = 1; i < parts.length; ++i) {
                        group.children = group.children.concat(parts[i].children);
                    }
                    callback(group);
                }
            })(0);
        },

        nameForRef: function(ref, sheet) {
            if (sheet === undefined) {
                sheet = ref.sheet;
            }
            sheet = sheet.toLowerCase();
            var str = ref + "";
            for (var name in this._names) {
                var def = this._names[name];
                var val = def.value;
                if (val instanceof Ref) {
                    if (!val.sheet || (val.sheet && sheet == val.sheet.toLowerCase())) {
                        if (val + "" == str) {
                            return def;
                        }
                    }
                }
            }
            return { name: str };
        },

        defineName: function(name, value, hidden) {
            var x = kendo.spreadsheet.calc.parseNameDefinition(name, value);
            name = x.name.print();
            this._names[name.toLowerCase()] = {
                value   : x.value,
                hidden  : hidden,
                name    : name,
                nameref : x.name
            };
        },

        undefineName: function(name) {
            delete this._names[name.toLowerCase()];
        },

        nameValue: function(name) {
            name = name.toLowerCase();
            if (name in this._names) {
                return this._names[name].value;
            }
            return null;
        },

        nameDefinition: function(name, def) {
            name = name.toLowerCase();
            if (arguments.length > 1) {
                if (def === undefined) {
                    delete this._names[name];
                } else {
                    this._names[name] = def;
                }
            }
            return this._names[name];
        },

        forEachName: function(func) {
            Object.keys(this._names).forEach(function(name){
                func(this._names[name], name);
            }, this);
        },

        adjustNames: function(affectedSheet, forRow, start, delta) {
            affectedSheet = affectedSheet.toLowerCase();
            Object.keys(this._names).forEach(function(name){
                var def = this._names[name];
                var x = def.value;
                if (x instanceof Ref &&
                    x.sheet.toLowerCase() == affectedSheet) {
                    def.value = x.adjust(null, null, null, null, forRow, start, delta);
                }
                else if (x instanceof Formula) {
                    x.adjust(affectedSheet, forRow ? "row" : "col", start, delta);
                }
            }, this);
        },

        addImage: function(image) {
            var id = String(++this._imgID);
            if (typeof image == "string") {
                this._images[id] = { url: image };
            } else {
                this._images[id] = { blob: image };
            }
            return id;
        },

        imageUrl: function(id) {
            var img = this._images[id];
            var url = img.url;
            if (!url) {
                url = img.url = window.URL.createObjectURL(img.blob);
            }
            return url;
        },

        cleanupImages: function() {
            Object.keys(this._images).forEach(function(id){
                if (!this.usesImage(id)) {
                    var url = this._images[id].url;
                    if (url) {
                        window.URL.revokeObjectURL(url);
                    }
                    delete this._images[id];
                }
            }, this);
        },

        usesImage: function(img) {
            var i;
            var sheets = this._sheets;
            for (i = sheets.length; --i >= 0;) {
                if (sheets[i].usesImage(img)) {
                    return 1;
                }
            }
            var stack = this.undoRedoStack.stack;
            for (i = stack.length; --i >= 0;) {
                if (stack[i].usesImage(img)) {
                    return 2; // signal that it's only in the undo stack
                }
            }
            return false;
        }

    });

    function sheetParamsFromJSON(data, options) {
        function or(a, b, c) {
            return a !== undefined ? a : b !== undefined ? b : c;
        }

        var rowCount     = or(data.rowCount, options.rows, 200),
            columnCount  = or(data.columnCount, options.columns, 50),
            rowHeight    = or(data.rowHeight, options.rowHeight, 20),
            columnWidth  = or(data.columnWidth, options.columnWidth, 64),
            headerHeight = or(data.headerHeight, options.headerHeight, 20),
            headerWidth  = or(data.headerWidth, options.headerWidth, 32);

        if (data.rows !== undefined) {
            for (var i = 0; i < data.rows.length; ++i) {
                var row = data.rows[i];
                var ri = or(row.index, i);
                if (ri >= rowCount) { rowCount = ri + 1; }
                if (row.cells) {
                    for (var j = 0; j < row.cells.length; ++j) {
                        var cell = row.cells[j];
                        var ci = or(cell.index, j);
                        if (ci >= columnCount) { columnCount = ci + 1; }
                    }
                }
            }
        }

        return {
            rowCount     : rowCount,
            columnCount  : columnCount,
            rowHeight    : rowHeight,
            columnWidth  : columnWidth,
            headerHeight : headerHeight,
            headerWidth  : headerWidth
        };
    }

    kendo.spreadsheet.Workbook = Workbook;
    if (kendo.PDFMixin) {
        kendo.PDFMixin.extend(Workbook.prototype);

        Workbook.prototype.saveAsPDF = function(options) {
            var progress = new $.Deferred();
            var promise = progress.promise();
            var args = { promise: promise };
            if (this.trigger("pdfExport", args)) {
                return;
            }

            this._drawPDF(options, progress)
            .then(function(root) {
                return options.forceProxy
                    ? kendo.pdf.exportPDF(root) // produce data URI for proxy
                    : kendo.pdf.exportPDFToBlob(root);
            })
            .done(function(dataURI) {
                kendo.saveAs({
                    dataURI: dataURI,
                    fileName: options.fileName,
                    proxyURL: options.proxyURL,
                    forceProxy: options.forceProxy,
                    proxyTarget: options.proxyTarget
                });

                progress.resolve();
            })
            .fail(function(err) {
                progress.reject(err);
            });

            return promise;
        };

        Workbook.prototype._drawPDF = function(options) {
            var result = new $.Deferred();
            var callback = function(group) {
                result.resolve(group);
            };
            switch(options.area) {
            case "workbook":
                options.workbook.draw(options, callback);
                break;
            case "sheet":
                options.workbook.activeSheet().draw(options, callback);
                break;
            case "selection":
                options.workbook.activeSheet().selection().draw(options, callback);
                break;
            }

            return result.promise();
        };
    }
})(kendo);

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/formulacontext',[ '../kendo.core' ], f);
})(function() {

    /* jshint eqnull:true */

    var spreadsheet = kendo.spreadsheet;
    var CellRef = spreadsheet.CellRef;
    var RangeRef = spreadsheet.RangeRef;
    var UnionRef = spreadsheet.UnionRef;
    var NameRef = spreadsheet.NameRef;
    var Ref = spreadsheet.Ref;

    var FormulaContext = kendo.Class.extend({
        init: function (workbook) {
            this.workbook = workbook;
        },

        getRefCells: function(ref, hiddenInfo, fsheet, frow, fcol, wantNulls) {
            var sheet, formula, value, i;
            if (ref instanceof CellRef) {
                sheet = this.workbook.sheetByName(ref.sheet);
                if (!sheet || !ref.valid()) {
                    return [{
                        value: new kendo.spreadsheet.calc.runtime.CalcError("REF")
                    }];
                }
                formula = sheet.formula(ref);
                value = sheet.range(ref.row, ref.col).value();

                if (wantNulls || formula != null || value != null) {
                    return [{
                        formula: formula,
                        value: value,
                        row: ref.row,
                        col: ref.col,
                        sheet: ref.sheet,
                        hidden: hiddenInfo ? (sheet.columnWidth(ref.col) === 0 || sheet.rowHeight(ref.row) === 0) : false
                    }];
                } else {
                    return [];
                }
            }
            if (ref instanceof RangeRef) {
                i = this.workbook.sheetIndex(ref.sheet);
                var states = [], n = i;
                if (ref.endSheet) {
                    // "3D" reference.
                    n = this.workbook.sheetIndex(ref.endSheet);
                    if (i > n) {
                        var tmp = i;
                        i = n;
                        n = tmp;
                    }
                }

                if (i < 0 || n < 0 || !ref.valid()) {
                    return [{
                        value: new kendo.spreadsheet.calc.runtime.CalcError("REF")
                    }];
                }

                // XXX: This is nicer, but significantly slower.
                // Should investigate why, or add some options to make
                // it faster (i.e. probably because it adds all cell
                // properties, while we only need value and formula).
                //
                //     var add = function(row, col, data){
                //         data.row = row;
                //         data.col = col;
                //         data.sheet = sheet.name();
                //         states.push(data);
                //     };
                //     while (i <= n) {
                //         sheet = this.workbook.sheetByIndex(i++);
                //         sheet.forEach(ref, add);
                //     }
                //
                // For now keep doing it "manually".

                while (i <= n) {
                    sheet = this.workbook.sheetByIndex(i++);
                    var tl = sheet._grid.normalize(ref.topLeft);
                    var br = sheet._grid.normalize(ref.bottomRight);

                    var startCellIndex = sheet._grid.cellRefIndex(tl);
                    var endCellIndex = sheet._grid.cellRefIndex(br);

                    var values = sheet._properties.iterator("value", startCellIndex, endCellIndex);

                    for (var col = tl.col; col <= br.col; ++col) {
                        for (var row = tl.row; row <= br.row; ++row) {
                            var index = sheet._grid.index(row, col);
                            formula = sheet._properties.get("formula", index);
                            value = values.at(index);
                            if (wantNulls || formula != null || value != null) {
                                states.push({
                                    formula : formula,
                                    value   : value,
                                    row     : row,
                                    col     : col,
                                    sheet   : sheet.name(),
                                    hidden  : hiddenInfo ? (sheet.columnWidth(col) === 0 || sheet.rowHeight(row) === 0) : false
                                });
                            }
                        }
                    }
                }

                return states;
            }
            if (ref instanceof UnionRef) {
                var a = [];
                for (i = 0; i < ref.refs.length; ++i) {
                    a = a.concat(this.getRefCells(ref.refs[i], hiddenInfo, fsheet, frow, fcol));
                }
                return a;
            }
            if (ref instanceof NameRef) {
                var val = this.nameValue(ref, fsheet, frow, fcol);
                // XXX: revise this
                if (val instanceof Ref) {
                    return this.getRefCells(val, hiddenInfo, fsheet, frow, fcol);
                }
                return [{
                    value: val == null ? new kendo.spreadsheet.calc.runtime.CalcError("NAME") : val
                }];
            }
            return [];
        },

        isMerged: function(ref) {
            var sheet = this.workbook.sheetByName(ref.sheet);
            return sheet.isMerged(ref);
        },

        nameValue: function(ref, fsheet, frow, fcol) {
            var val;
            if (ref.hasSheet()) {
                // qualified name
                val = this.workbook.nameValue(ref.print());
            } else {
                // try local name
                ref = ref.clone().setSheet(fsheet, true);
                val = this.workbook.nameValue(ref.print());
                if (val == null) {
                    // try global name
                    val = this.workbook.nameValue(ref.name);
                }
            }
            if (val instanceof Ref) {
                val = val.absolute(frow, fcol);
            }
            return val;
        },

        getData: function(ref, fsheet, frow, fcol, wantNulls) {
            var single = ref instanceof CellRef;
            if (ref instanceof NameRef) {
                single = this.workbook.nameValue(ref.name) instanceof CellRef;
            }
            var data = this.getRefCells(ref, false, fsheet, frow, fcol, wantNulls).map(function(cell){
                var val = cell.value;
                if (val instanceof kendo.spreadsheet.calc.runtime.Formula) {
                    val = val.value;
                }
                return val;
            });
            return single ? data[0] : data;
        },

        onFormula: function(f) {
            var sheet = this.workbook.sheetByName(f.sheet);
            var row = f.row, col = f.col, value = f.value;
            var currentFormula = sheet.formula({ row: row, col: col });
            if (currentFormula !== f) {
                // could have been deleted or modified in the mean time,
                // if the formula was asynchronous.  ignore this result.
                return false;
            }

            var arrayRange = f.arrayFormulaRange;
            if (arrayRange) {
                // `value` will always be a Matrix in this case;
                // enforced in runtime.js (Context::_resolve).  We
                // must fill only cells in arrayRange.
                var tlRow, tlCol;
                var width = value.width;
                var height = value.height;
                sheet.forEach(arrayRange, function(row, col){
                    if (tlRow === undefined) {
                        tlRow = row;
                        tlCol = col;
                    }
                    var vrow = row - tlRow;
                    var vcol = col - tlCol;
                    var val;
                    if (vrow < height && vcol < width) {
                        val = value.get(vrow, vcol);
                    } else {
                        val = new kendo.spreadsheet.calc.runtime.CalcError("N/A");
                    }
                    sheet._value(row, col, val);
                });
            }
            else {
                // formulas may return references.  if a range or union,
                // we'll just save the first cell.
                if (value instanceof Ref) {
                    value = this.getData(value, f.sheet, row, col);
                    if (Array.isArray(value)) {
                        value = value[0];
                    }
                    if (value === undefined) {
                        value = null; // clear contents
                    }
                }

                // when not saved as an array formula, a formula
                // returning a Matrix will just save the first value.
                if (value instanceof kendo.spreadsheet.calc.runtime.Matrix) {
                    value = value.get(0, 0);
                }

                sheet._value(row, col, value);
            }

            clearTimeout(sheet._formulaContextRefresh);
            sheet._formulaContextRefresh = setTimeout(function(){
                sheet.batch(function(){}, { layout: true });
            }, 50);

            return true;
        }
    });

    var ValidationFormulaContext = FormulaContext.extend({
        onFormula: function() {
            return true;
        }
    });

    spreadsheet.FormulaContext = FormulaContext;
    spreadsheet.ValidationFormulaContext = ValidationFormulaContext;

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/controller',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {
    'use strict';

    var $ = kendo.jQuery;
    var alphaNumRegExp = /:alphanum$/;

    var ACTIONS = {
        "up": "up",
        "down": "down",
        "left": "left",
        "right": "right",
        "home": "first-col",
        "end": "last-col",
        "ctrl+left": "word-left",
        "ctrl+right": "word-right",
        "ctrl+up": "word-up",
        "ctrl+down": "word-down",
        "ctrl+home": "first",
        "ctrl+end": "last",
        "pageup": "prev-page",
        "pagedown": "next-page"
    };

    var ENTRY_ACTIONS = {
        "tab": "next",
        "shift+tab": "previous",
        "enter": "lower",
        "shift+enter": "upper",
        "delete": "clearContents",
        "backspace": "clearContents",
        "shift+:alphanum": "edit",
        "alt+:alphanum": "edit",
        ":alphanum": "edit",
        "ctrl+:alphanum": "ctrl",
        "alt+ctrl+:alphanum": "edit",
        ":edit": "edit"
    };

    var CONTAINER_EVENTS = {
        "wheel": "onWheel",
        "*+mousedown": "onMouseDown",
        "contextmenu": "onContextMenu",
        "*+mousedrag": "onMouseDrag",
        "*+mouseup": "onMouseUp",
        "*+dblclick": "onDblClick",
        "mousemove": "onMouseMove"
    };

    var CLIPBOARD_EVENTS = {
        "pageup": "onPageUp",
        "pagedown": "onPageDown",
        "mouseup": "onMouseUp",
        "*+cut": "onCut",
        "*+paste": "onPaste",
        "*+copy": "onCopy"
    };

    var EDITOR_EVENTS = {
        "esc": "onEditorEsc",
        "enter": "onEditorBlur",
        "alt+enter": "insertNewline",
        "shift+enter": "onEditorBlur",
        "tab": "onEditorBlur",
        "shift+tab": "onEditorBlur",
        "shift+ctrl+enter": "onEditorArrayFormula"
    };

    var FORMULABAR_EVENTS = $.extend({ focus: "onEditorBarFocus" }, EDITOR_EVENTS);
    var FORMULAINPUT_EVENTS = $.extend({ focus: "onEditorCellFocus" }, EDITOR_EVENTS);

    var SELECTION_MODES = {
       cell: "range",
       rowheader: "row",
       columnheader: "column",
       topcorner: "sheet",
       autofill: "autofill"
    };

    function toActionSelector(selectors) {
        return selectors.map(function(action) {
            return '[data-action="' + action + '"]';
        }).join(",");
    }

    var COMPOSITE_UNAVAILABLE_ACTION_SELECTORS = toActionSelector([ 'cut', 'copy', 'paste', 'insert-left', 'insert-right', 'insert-above', 'insert-below' ]);
    var UNHIDE_ACTION_SELECTORS = toActionSelector([ 'unhide-row', 'unhide-column' ]);

    var ACTION_KEYS = [];
    var SHIFT_ACTION_KEYS = [];
    var ENTRY_ACTION_KEYS = [];

    for (var key in ACTIONS) {
        ACTION_KEYS.push(key);
        SHIFT_ACTION_KEYS.push("shift+" + key);
    }

    for (key in ENTRY_ACTIONS) {
        ENTRY_ACTION_KEYS.push(key);
    }

    CLIPBOARD_EVENTS[ACTION_KEYS] = "onAction";
    CLIPBOARD_EVENTS[SHIFT_ACTION_KEYS] = "onShiftAction";
    CLIPBOARD_EVENTS[ENTRY_ACTION_KEYS] = "onEntryAction";

    FORMULAINPUT_EVENTS[ACTION_KEYS] = "onEditorAction";
    FORMULAINPUT_EVENTS[SHIFT_ACTION_KEYS] = "onEditorShiftAction";

    var Controller = kendo.Class.extend({
        init: function(view, workbook) {
            this.view = view;
            this.workbook(workbook);
            this.container = $(view.container);
            this.clipboardElement = $(view.clipboard);
            this.cellContextMenu = view.cellContextMenu;
            this.rowHeaderContextMenu = view.rowHeaderContextMenu;
            this.colHeaderContextMenu = view.colHeaderContextMenu;
            this.drawingContextMenu = view.drawingContextMenu;
            this.scroller = view.scroller;
            this.tabstrip = view.tabstrip;
            this.sheetsbar = view.sheetsbar;

            view.nameEditor.bind("enter", this.onNameEditorEnter.bind(this));
            view.nameEditor.bind("cancel", this.onNameEditorCancel.bind(this));
            view.nameEditor.bind("select", this.onNameEditorSelect.bind(this));
            view.nameEditor.bind("delete", this.onNameEditorDelete.bind(this));

            this.editor = view.editor;
            this.editor.bind("change", this.onEditorChange.bind(this));
            this.editor.bind("activate", this.onEditorActivate.bind(this));
            this.editor.bind("deactivate", this.onEditorDeactivate.bind(this));
            this.editor.bind("update", this.onEditorUpdate.bind(this));

            $(view.scroller).on("scroll", this.onScroll.bind(this));
            this.listener = new kendo.spreadsheet.EventListener(this.container, this, CONTAINER_EVENTS);
            $(view.scroller).on("mousedown", this.onMouseDown.bind(this));

            this._enableEditorEvents();

            if (this.sheetsbar) {
                this.sheetsbar.bind("select", this.onSheetBarSelect.bind(this));
                this.sheetsbar.bind("reorder", this.onSheetBarReorder.bind(this));
                this.sheetsbar.bind("rename", this.onSheetBarRename.bind(this));
                this.sheetsbar.bind("remove", this.onSheetBarRemove.bind(this));
            }

            this.cellContextMenu.bind("select", this.onContextMenuSelect.bind(this));
            this.rowHeaderContextMenu.bind("select", this.onContextMenuSelect.bind(this));
            this.colHeaderContextMenu.bind("select", this.onContextMenuSelect.bind(this));
            this.drawingContextMenu.bind("select", this.onContextMenuSelect.bind(this));

            // this is necessary for Windows to catch prevent context menu correctly
            this.cellContextMenu.element
                .add(this.rowHeaderContextMenu.element)
                .add(this.colHeaderContextMenu.element)
                .add(this.drawingContextMenu.element)
                .on("contextmenu", false);

            if (this.tabstrip) {
                this.tabstrip.bind("action", this.onCommandRequest.bind(this));
                this.tabstrip.bind("dialog", this.onDialogRequest.bind(this));
            }
        },

        _enableEditorEvents: function (enable) {
            if (enable === undefined || enable) {
                this.keyListener = new kendo.spreadsheet.EventListener(this.clipboardElement, this, CLIPBOARD_EVENTS);
                this.barKeyListener = new kendo.spreadsheet.EventListener(this.editor.barElement(), this, FORMULABAR_EVENTS);
                this.inputKeyListener = new kendo.spreadsheet.EventListener(this.editor.cellElement(), this, FORMULAINPUT_EVENTS);
            } else {
                this.keyListener.destroy();
                this.barKeyListener.destroy();
                this.inputKeyListener.destroy();
            }
        },

        _execute: function(options) {
            var result = this._workbook.execute(options);

            if (options.command === "EditCommand" && !result) {
                this._workbook.trigger("change", { editorClose: true });
            }

            if (result) {
                this._preventNavigation = true;
                if (result.reason === "error") {
                    this.editor.deactivate(true); // make sure we don't call any change hooks
                    this.view.showError(result, function(){
                        // we only get here in case of a validation error when the user decided to retry.
                        this.activateEditor(false);
                        // reset to last input from user
                        this.editor.value(this._lastEditorValue);
                        // however, set _value manually such that it'll detect change properly.  ugly :-\
                        this.editor._value = this._workbook._inputForRef(this._workbook.activeSheet()._viewActiveCell());
                        // seems like a nice UX to have the whole input selected
                        this.editor.select();
                    }.bind(this));
                } else {
                    this.view.openDialog(result.reason);
                }
            }

            return result;
        },

        _activeTooltip: function() {
            return this._workbook.activeSheet().activeCell().simplify().toString();
        },

        onContextMenuSelect: function(e) {
            var action = $(e.item).data("action");
            var command;
            switch(action) {
              case "cut":
                command = { command: "ToolbarCutCommand", options: { workbook: this._workbook } };
                break;
              case "copy":
                command = { command: "ToolbarCopyCommand", options: { workbook: this._workbook } };
                break;
              case "paste":
                command = { command: "ToolbarPasteCommand", options: { workbook: this._workbook } };
                break;
              case "delete-drawing":
                command = { command: "DeleteDrawingCommand", options: { drawing: this.navigator._sheet._activeDrawing } };
                break;
              case "bring-to-front":
                command = { command: "BringToFrontCommand", options: { drawing: this.navigator._sheet._activeDrawing } };
                break;
              case "send-to-back":
                command = { command: "SendToBackCommand", options: { drawing: this.navigator._sheet._activeDrawing } };
                break;
              case "unmerge":
                command = { command: "MergeCellCommand", options: { value: "unmerge" } };
                break;
              case "merge":
                this.view.openDialog("merge");
                break;
              case "hide-row":
                command = { command: "HideLineCommand", options: { axis: "row" } };
                break;
              case "hide-column":
                command = { command: "HideLineCommand", options: { axis: "column" } };
                break;
              case "unhide-row":
                command = { command: "UnHideLineCommand", options: { axis: "row" } };
                break;
              case "unhide-column":
                command = { command: "UnHideLineCommand", options: { axis: "column" } };
                break;
              case "delete-row":
                command = { command: "DeleteRowCommand" };
                break;
              case "delete-column":
                command = { command: "DeleteColumnCommand" };
                break;
            }

            if (command) {
                this._execute(command);
            }
        },

        onSheetBarRemove: function(e) {
            var sheet = this._workbook.sheetByName(e.name);

            //TODO: move to model!
            if (!sheet) {
                return;
            }

            this._workbook.removeSheet(sheet);
        },

        destroy: function() {
            this.listener.destroy();
            this._enableEditorEvents(false);
            this.keyListener.destroy();
            this.inputKeyListener.destroy();
        },

        onSheetBarSelect: function(e) {
            var sheet;
            var workbook = this._workbook;

            if (e.isAddButton) {
                if (this._workbook.trigger("insertSheet")) {
                    return;
                }

                sheet = workbook.insertSheet();
            } else {
                sheet = workbook.sheetByName(e.name);
            }

            //TODO: move to model
            if (workbook.activeSheet().name() !== sheet.name()) {
                if (this._workbook.trigger("selectSheet", { sheet: sheet })) {
                    return;
                }

                if (!this.editor.canInsertRef(false)) {
                    this.editor.deactivate();
                }

                workbook.activeSheet(sheet);
            }
        },

        onSheetBarReorder: function(e) {
            var workbook = this._workbook;
            var sheet = workbook.sheetByIndex(e.oldIndex);
            var activeSheet = workbook.activeSheet();
            var activeSheetName = activeSheet.name();

            workbook.moveSheetToIndex(sheet, e.newIndex);

            if (activeSheetName !== sheet.name()) {
                if (workbook.trigger("selectSheet", { sheet: sheet })) {
                    workbook.activeSheet(activeSheet);
                    return;
                }

                if (!this.editor.canInsertRef(false)) {
                    this.editor.deactivate();
                }

                workbook.activeSheet(sheet);
            }
        },

        onSheetBarRename: function(e) {
            var sheet = this._workbook.sheetByIndex(e.sheetIndex);

            if (this._workbook.sheetByName(e.name)) {
                this.view.showError({ reason: "error", type: "duplicateSheetName" });
                return;
            }

            this._workbook.renameSheet(sheet, e.name);

            this.clipboardElement.focus();
        },

        sheet: function(sheet) {
            this.navigator = sheet.navigator();
            this.axisManager = sheet.axisManager();
        },

        workbook: function(workbook) {
            this._workbook = workbook;
            this.clipboard = workbook.clipboard();
            workbook.bind("commandRequest", this.onCommandRequest.bind(this));
        },

        refresh: function() {
            var editor = this.editor;
            var workbook = this._workbook;
            var sheet = workbook.activeSheet();

            this._viewPortHeight = this.view.scroller.clientHeight;
            this.navigator.height(this._viewPortHeight);

            if (!editor.isActive() && !this.isEditorDisabled) {
                editor.enable(sheet.selection().enable() !== false);
                this.resetEditorValue();
            }

            var ref = sheet.selection()._ref.simplify();
            var def = this._workbook.nameForRef(ref, sheet.name());
            this.view.nameEditor.value(def.name);
        },

        onScroll: function() {
            this.view.render({ scroll: true });
        },

        onWheel: function(event) {
            var deltaX = event.originalEvent.deltaX;
            var deltaY = event.originalEvent.deltaY;

            if (event.originalEvent.deltaMode === 1) {
                deltaX *= 10;
                deltaY *= 10;
            }

            this.scrollWith(deltaX, deltaY);

            event.preventDefault();
        },

        onAction: function(event, action) {
            var sheet = this._workbook.activeSheet();
            sheet._activeDrawing = null;
            this.navigator.moveActiveCell(ACTIONS[action]);
            event.preventDefault();
        },

        onPageUp: function() {
            this.scrollDown(-this._viewPortHeight);
        },

        onPageDown: function() {
            this.scrollDown(this._viewPortHeight);
        },

        onEntryAction: function(event, action) {
            var sheet = this._workbook.activeSheet();

            if (event.mod) {
                var key = String.fromCharCode(event.keyCode);
                var shouldPrevent = true;

                switch(key) {
                  case "A":
                    sheet._activeDrawing = null;
                    this.navigator.selectAll();
                    break;
                  case "Y":
                    this._workbook.undoRedoStack.redo();
                    break;
                  case "Z":
                    this._workbook.undoRedoStack.undo();
                    break;
                  default:
                    shouldPrevent = false;
                    break;
                }
                if (shouldPrevent) {
                    event.preventDefault();
                }
            } else {
                var disabled = sheet.selection().enable() === false;
                var casual = action !== ":edit";

                if (action == "delete" || action == "backspace") {
                    if (sheet._activeDrawing) {
                        this._execute({
                            command: "DeleteDrawingCommand",
                            options: { drawing: sheet._activeDrawing }
                        });
                    } else if (!disabled) {
                        this._execute({ command: "ClearContentCommand" });
                    }
                    event.preventDefault();
                } else if (alphaNumRegExp.test(action) || !casual) {
                    sheet._activeDrawing = null;
                    if (disabled) {
                        event.preventDefault();
                        return;
                    }
                    if (casual) {
                        this.editor.value("");
                    }
                    this.activateEditor(casual);
                } else {
                    this.navigator.navigateInSelection(ENTRY_ACTIONS[action]);
                    event.preventDefault();
                }
            }
        },

        onShiftAction: function(event, action) {
            this.navigator.modifySelection(ACTIONS[action.replace("shift+", "")], this.appendSelection);
            event.preventDefault();
        },

        onMouseMove: function(event) {
            var sheet = this._workbook.activeSheet();

            if (sheet.resizingInProgress() || sheet.selectionInProgress()) {
                return;
            }

            var object = this.objectAt(event);
            if (object.type === "columnresizehandle" || object.type === "rowresizehandle") {
                sheet.positionResizeHandle(object.ref);
            } else {
                sheet.removeResizeHandle();
            }

            sheet._renderComment(object.type == "cell" ? object.ref : null);
        },

        onMouseDown: function(event) {
            var object = this.objectAt(event);
            if (object.pane) {
                this.originFrame = object.pane;
            }

            if (this._startResizingDrawing(event, object)) {
                event.stopPropagation();
                return;
            }

            var sheet = this._workbook.activeSheet();
            var win = this.container.closest('[' + kendo.attr("role") + '="window"]');
            if (win.length) {
                win = kendo.widgetInstance(win);
                if (win && win.options.modal) {
                    event.stopPropagation();
                }
            }

            sheet._activeDrawing = null;
            if (object.type === "drawing") {
                sheet._activeDrawing = object.drawing;
                object.copy = object.drawing.clone();
                object.startBox = sheet.drawingBoundingBox(object.copy);
                sheet.startDragging(object);
                sheet.triggerChange({ dragging: true });
                event.preventDefault();
                return;
            }

            if (object.type === "editor") {
                // XXX: canceling the edits, because they might not
                // validate.  Not sure it's the Right Thing.
                this.onEditorEsc();
                this.openCustomEditor();
                event.preventDefault();
                return;
            }

            if (this.editor.canInsertRef(false) && object.ref) {
                this._workbook.activeSheet()._setFormulaSelections(this.editor.highlightedRefs());
                this.navigator.startSelection(object.ref, this._selectionMode, this.appendSelection, event.shiftKey, this.view);
                event.preventDefault();
                return;
            } else {
                this._preventNavigation = false;
                this.editor.deactivate();
                if (this._preventNavigation) {
                    return;     // validation error
                }
            }

            if (object.type === "columnresizehandle" || object.type === "rowresizehandle") {
                sheet.startResizing({ x: object.x, y: object.y });
                event.preventDefault();
                return;
            }

            if (object.type === "filtericon") {
                this.openFilterMenu(event);
                event.preventDefault();
                return;
            }

            this._selectionMode = SELECTION_MODES[object.type];
            this.appendSelection = event.mod;
            this.navigator.startSelection(object.ref, this._selectionMode, this.appendSelection, event.shiftKey, this.view);
        },

        _startResizingDrawing: function(event) {
            var handle = $(event.target).closest(".k-spreadsheet-drawing-handle");
            if (handle.length) {
                var location = this.translateCoords(event);
                var direction = handle.data("direction");
                var sheet = this._workbook.activeSheet();
                var drawing = sheet._activeDrawing;
                sheet.startDragging({
                    pane     : this.originFrame,
                    drawing  : drawing,
                    copy     : drawing.clone(),
                    startBox : sheet.drawingBoundingBox(drawing),
                    resize   : direction,
                    //aspect   : drawing.width / drawing.height,
                    startX   : location.x,
                    startY   : location.y
                });
                return true;
            }
        },

        onContextMenu: function(event) {
            var sheet = this._workbook.activeSheet();

            event.preventDefault();

            if (sheet.resizingInProgress() || sheet.draggingInProgress()) {
                return;
            }

            this.cellContextMenu.close();
            this.colHeaderContextMenu.close();
            this.rowHeaderContextMenu.close();
            this.drawingContextMenu.close();

            var menu;

            var object = this.objectAt(event);

            if (object.type === "columnresizehandle" || object.type === "rowresizehandle") {
                return;
            }

            if (object.ref) {
                this.navigator.selectForContextMenu(object.ref, SELECTION_MODES[object.type]);
            } else if (object.type == "drawing") {
                this.navigator.selectDrawingForContextMenu(object.drawing);
            }

            var isComposite = this.navigator._sheet.select() instanceof kendo.spreadsheet.UnionRef;
            var showUnhide = false;
            var showUnmerge = false;

            if (object.type == "columnheader") {
                menu = this.colHeaderContextMenu;
                showUnhide = !isComposite && this.axisManager.selectionIncludesHiddenColumns();
            } else if (object.type == "rowheader") {
                menu = this.rowHeaderContextMenu;
                showUnhide = !isComposite && this.axisManager.selectionIncludesHiddenRows();
            } else if (object.type == "drawing") {
                menu = this.drawingContextMenu;
            } else {
                menu = this.cellContextMenu;
                showUnmerge = this.navigator.selectionIncludesMergedCells();
            }

            menu.element.find(COMPOSITE_UNAVAILABLE_ACTION_SELECTORS).toggle(!isComposite);
            menu.element.find(UNHIDE_ACTION_SELECTORS).toggle(showUnhide);
            menu.element.find('[data-action=unmerge]').toggle(showUnmerge);

            // avoid the immediate close
            setTimeout(function() {
                menu.open(event.pageX, event.pageY);
            });
        },

        prevent: function(event) {
            event.preventDefault();
        },

        constrainResize: function(type, ref) {
            var sheet = this._workbook.activeSheet();
            var resizeHandle = sheet.resizeHandlePosition();

            return !resizeHandle || type === "outside" || type === "topcorner" || ref.col < resizeHandle.col || ref.row < resizeHandle.row;
        },

        _dragDrawing: function(event) {
            var sheet = this._workbook.activeSheet();
            var drag = sheet.draggingInProgress();
            if (!drag) {
                return false;
            }

            var location = this.translateCoords(event);
            var drawing = drag.drawing;
            var deltaX = location.x - drag.startX;
            var deltaY = location.y - drag.startY;

            if (drag.resize == "SE") {
                if (drag.aspect) {
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        drawing.width = Math.max(drag.copy.width + deltaX, 20);
                        drawing.height = drawing.width / drag.aspect;
                    } else {
                        drawing.height = Math.max(drag.copy.height + deltaY, 20);
                        drawing.width = drawing.height * drag.aspect;
                    }
                } else {
                    drawing.width = Math.max(drag.copy.width + deltaX, 20);
                    drawing.height = Math.max(drag.copy.height + deltaY, 20);
                }
            }
            else if (drag.resize == "E") {
                drawing.width = Math.max(drag.copy.width + deltaX, 20);
            }
            else if (drag.resize == "S") {
                drawing.height = Math.max(drag.copy.height + deltaY, 20);
            }
            else if (drag.resize == "N") {
                if (drag.copy.height - deltaY > 20) {
                    drawing.height = drag.copy.height - deltaY;
                    drawing.offsetY = drag.copy.offsetY + deltaY;
                }
            }
            else if (drag.resize == "W") {
                if (drag.copy.width - deltaX > 20) {
                    drawing.width = drag.copy.width - deltaX;
                    drawing.offsetX = drag.copy.offsetX + deltaX;
                }
            }
            else if (drag.resize == "NE") {
                drawing.width = Math.max(drag.copy.width + deltaX, 20);
                if (drag.copy.height - deltaY > 20) {
                    drawing.height = drag.copy.height - deltaY;
                    drawing.offsetY = drag.copy.offsetY + deltaY;
                }
            }
            else if (drag.resize == "SW") {
                drawing.height = Math.max(drag.copy.height + deltaY, 20);
                if (drag.copy.width - deltaX > 20) {
                    drawing.width = drag.copy.width - deltaX;
                    drawing.offsetX = drag.copy.offsetX + deltaX;
                }
            }
            else if (drag.resize == "NW") {
                if (drag.copy.height - deltaY > 20) {
                    drawing.height = drag.copy.height - deltaY;
                    drawing.offsetY = drag.copy.offsetY + deltaY;
                }
                if (drag.copy.width - deltaX > 20) {
                    drawing.width = drag.copy.width - deltaX;
                    drawing.offsetX = drag.copy.offsetX + deltaX;
                }
            }
            // just moving (no resize)
            else {
                drawing.offsetX = drag.copy.offsetX + deltaX;
                drawing.offsetY = drag.copy.offsetY + deltaY;
            }

            sheet.triggerChange({ dragging: true });

            return true;
        },

        onMouseDrag: function(event) {
            if (this._selectionMode === "sheet") {
                return;
            }

            var location = { clientX: event.clientX, clientY: event.clientY };
            var sheet = this._workbook.activeSheet();

            if (this._dragDrawing(event)) {
                return;
            }

            var object = this.objectAt(location);

            if (sheet.resizingInProgress()) {

                if (!this.constrainResize(object.type, object.ref)) {
                    sheet.resizeHintPosition({ x: object.x, y: object.y });
                }

                return;
            }

            if (object.type === "outside") {
                this.startAutoScroll(object);
                return;
            }

            if (this.originFrame === object.pane) {
                this.selectToLocation(location);
            } else { // cross frame selection
                var frame = this.originFrame._grid;

                if (object.x > frame.right) {
                    kendo.scrollLeft(this);
                }

                if (object.y > frame.bottom) {
                    this.scrollTop();
                }

                if (object.y < frame.top || object.x < frame.left) {
                    this.startAutoScroll(object, location);
                } else {
                    this.selectToLocation(location);
                }
            }

            event.preventDefault();
        },

        onMouseUp: function(event) {
            var sheet = this._workbook.activeSheet();
            sheet.completeResizing();
            sheet.completeDragging();

            this.navigator.completeSelection();
            this.stopAutoScroll();

            var editor = this.editor.activeEditor();
            if (!editor) {
                return;
            }
            var el = event.target;
            while (el) {
                if (el === editor.element[0]) {
                    return;
                }
                el = el.parentNode;
            }

            var object = this.objectAt(event);
            if (object && object.ref && editor.canInsertRef(false)) {
                editor.refAtPoint(sheet);
                sheet._setFormulaSelections(editor.highlightedRefs());
            }
        },

        onDblClick: function(event) {
            var object = this.objectAt(event);
            var disabled = this._workbook.activeSheet().selection().enable() === false;

            if (object.type !== "cell" || disabled) {
                return;
            }

            var sel = this._workbook.activeSheet().selection();
            this.activateEditor(!sel.value() && !sel.formula());
            this.onEditorUpdate();
        },

        onCut: function(e) {
            var self = this;
            setTimeout(function(){
                self.clipboard.menuInvoked = (e === undefined);
                self._execute({
                    command: "CutCommand",
                    options: { workbook: self.view._workbook, event: e.originalEvent || e }
                });
            });
        },

        clipBoardValue: function() {
            return this.clipboardElement.html();
        },

        _pasteImage: function(blob) {
            var self = this;
            var img = new window.Image();
            img.src = window.URL.createObjectURL(blob);
            img.onload = function() {
                self._execute({
                    command: "InsertImageCommand",
                    options: {
                        blob: blob,
                        width: img.width,
                        height: img.height
                    }
                });
            };
            setTimeout(function(){
                window.URL.revokeObjectURL(img.src);
            }, 10);
        },

        onPaste: function(e) {
            var self = this;
            var html = "";
            var plain = "";
            self.clipboard.menuInvoked = (e === undefined);
            if (e) {
                var clipboardData = e.originalEvent.clipboardData;
                if (clipboardData && clipboardData.getData) {
                    e.preventDefault();
                    var hasHTML = false;
                    var hasPlainText = false;
                    // Firefox uses DOMStringList, needs special handling
                    if (window.DOMStringList && clipboardData.types instanceof window.DOMStringList) {
                        hasHTML = clipboardData.types.contains("text/html");
                        hasPlainText = clipboardData.types.contains("text/plain");
                    } else if (Array.isArray(clipboardData.types)) {
                        hasHTML = clipboardData.types.indexOf("text/html") >= 0;
                        hasPlainText = clipboardData.types.indexOf("text/plain") >= 0;
                    } else {
                        hasHTML = /text\/html/.test(clipboardData.types);
                        hasPlainText = /text\/plain/.test(clipboardData.types);
                    }
                    if (hasHTML) {
                        html = clipboardData.getData('text/html').trim();
                    }
                    if (hasPlainText) {
                        plain = clipboardData.getData('text/plain').trim();
                    }
                    if (!html && !plain && clipboardData.items && clipboardData.items.length) {
                        for (var i = 0; i < clipboardData.items.length; ++i) {
                            var item = clipboardData.items[i];
                            if (item.kind == "file" && /^image\/(?:png|jpe?g|gif)$/i.test(item.type)) {
                                return self._pasteImage(item.getAsFile());
                            }
                        }
                    }
                } else {
                    if (window.clipboardData.files && window.clipboardData.files.length) {
                        var file = window.clipboardData.files[0];
                        if (/^image\/(?:png|jpe?g|gif)$/i.test(file.type)) {
                            return self._pasteImage(file);
                        }
                    }

                    plain = window.clipboardData.getData("Text");
                    if (plain) {
                        plain = plain.trim();
                    }

                    // There's no way to get the HTML clipboard contents in IE other than letting
                    // the browser handle the event (it pastes into our clipboardElement), and then
                    // we can read the HTML from there.  Need to allow a small timeout for this.
                    self.clipboardElement.empty();
                    setTimeout(function(){
                        html = self.clipboardElement.html();
                        if (html || plain) {
                            self.clipboard.external({ html: html, plain: plain });
                            self._execute({
                                command: "PasteCommand",
                                options: { workbook: self.view._workbook, event: e.originalEvent || e }
                            });
                        }
                    });

                    return;
                }
            } else {
                if (kendo.support.browser.msie) {
                    self.clipboardElement.trigger("focus").select();
                    document.execCommand('paste');
                    return;
                } else {
                    self.clipboard.menuInvoked = true;
                }
            }

            if (!html && !plain) {
                return;
            }
            self.clipboard.external({ html: html, plain:plain });
            self._execute({
                command: "PasteCommand",
                options: { workbook: self.view._workbook, event: e.originalEvent || e }
            });
        },

        onCopy: function(e) {
            this.clipboard.menuInvoked = (e === undefined);
            this._execute({
                command: "CopyCommand",
                options: { workbook: this.view._workbook, event: e.originalEvent || e }
            });
        },

////////////////////////////////////////////////////////////////////

        scrollTop: function() {
            this.scroller.scrollTop = 0;
        },

        scrollLeft: function() {
            this.scroller.scrollLeft = 0;
        },

        scrollDown: function(value) {
            this.scroller.scrollTop += value;
        },

        scrollRight: function(value) {
            this.scroller.scrollLeft += value;
        },

        scrollWith: function(right, down) {
            this.scroller.scrollTop += down;
            this.scroller.scrollLeft += right;
        },

        translateCoords: function(location) {
            var box = this.container[0].getBoundingClientRect();
            return {
                x: location.clientX - box.left,
                y: location.clientY - box.top
            };
        },

        objectAt: function(location, noDrawing) {
            if (!location) {
                return;
            }
            location = this.translateCoords(location);
            return this.view.objectAt(location.x, location.y, noDrawing);
        },

        selectToLocation: function(cellLocation) {
            var object = this.objectAt(cellLocation, true);

            if (object.pane && object.ref) { // cell, rowheader or columnheader
                this.extendSelection(object);
                this.lastKnownCellLocation = cellLocation;
                this.originFrame = object.pane;
            }

            this.stopAutoScroll();
        },

        extendSelection: function(object) {
            this.navigator.extendSelection(object.ref, this._selectionMode);
        },

        autoScroll: function() {
            var x = this._autoScrollTarget.x;
            var y = this._autoScrollTarget.y;
            var boundaries = this.originFrame._grid;
            var scroller = this.view.scroller;
            var scrollStep = 8;

            var scrollLeft = scroller.scrollLeft;
            var scrollTop = scroller.scrollTop;

            if (x < boundaries.left) {
                this.scrollRight(-scrollStep);
            }
            if (x > boundaries.right) {
                this.scrollRight(scrollStep);
            }
            if (y < boundaries.top) {
                this.scrollDown(-scrollStep);
            }
            if (y > boundaries.bottom) {
                this.scrollDown(scrollStep);
            }

            if (scrollTop === scroller.scrollTop && scrollLeft === scroller.scrollLeft) {
                this.selectToLocation(this.finalLocation);
            } else {
                this.extendSelection(this.objectAt(this.lastKnownCellLocation));
            }
        },

        startAutoScroll: function(viewObject, location) {
            if (!this._scrollInterval) {
                this._scrollInterval = setInterval(this.autoScroll.bind(this), 50);
            }

            this.finalLocation = location || this.lastKnownCellLocation;

            this._autoScrollTarget = viewObject;
        },

        stopAutoScroll: function() {
            clearInterval(this._scrollInterval);
            this._scrollInterval = null;
        },

        openCustomEditor: function() {
            this.view.openCustomEditor();
        },

        openFilterMenu: function(event) {
            var object = this.objectAt(event);
            var sheet = this._workbook.activeSheet();
            var column = sheet.filterColumn(object.ref);
            var filterMenu = this.view.createFilterMenu(column);

            filterMenu.bind("action", this.onCommandRequest.bind(this));
            filterMenu.bind("action", filterMenu.close.bind(filterMenu));

            filterMenu.openFor(event.target, event);
        },

////////////////////////////////////////////////////////////////////

        _saveEditorValue: function(arrayFormula) {
            var sheet = this.editor._range.sheet();
            var value = this.editor.value();
            if (this._workbook.activeSheet() !== sheet) {
                // remove highlighted refs (XXX: which are mostly wrong, BTW)
                this._workbook.activeSheet()._setFormulaSelections();
                // go back to the original sheet
                this._workbook.activeSheet(sheet);
            }
            sheet.isInEditMode(false);
            this._lastEditorValue = value;
            this._execute({
                command: "EditCommand",
                options: {
                    value: value,
                    arrayFormula: arrayFormula
                }
            });
        },

        onEditorChange: function() {
            this._saveEditorValue(false);
        },

        onEditorArrayFormula: function() {
            this._saveEditorValue(true);
            this.editor.deactivate(true);
        },

        onEditorActivate: function() {
            var workbook = this._workbook;
            var sheet = workbook.activeSheet();

            sheet._setFormulaSelections(this.editor.highlightedRefs());
            sheet.isInEditMode(true);
        },

        onEditorDeactivate: function() {
            var sheet = this._workbook.activeSheet();

            sheet.isInEditMode(false);
            sheet._setFormulaSelections([]);
        },

        onEditorUpdate: function() {
            this._workbook.activeSheet()._setFormulaSelections(this.editor.highlightedRefs());
        },

        onEditorBarFocus: function() {
            var disabled = this._workbook.activeSheet().selection().enable() === false;
            if (disabled) {
                return;
            }
            this.editor
                .activate({
                    range: this._workbook.activeSheet().selection(),
                    rect: this.view.activeCellRectangle(),
                    tooltip: this._activeTooltip()
                });
        },

        onEditorCellFocus: function() {
            this.editor.scale();
        },

        onEditorEsc: function() {
            this.resetEditorValue();
            this.editor.deactivate();

            this.clipboardElement.trigger("focus");
        },

        insertNewline: function(e) {
            e.preventDefault();
            this.editor.insertNewline();
        },

        onEditorBlur: function(_, action) {
            if (this.editor.isFiltered()) {
                return;
            }

            this._preventNavigation = false;
            this.editor.deactivate();

            if (!this._preventNavigation) {
                this.clipboardElement.trigger("focus");
                this.navigator.navigateInSelection(ENTRY_ACTIONS[action]);
            }
        },

        onEditorAction: function(event, action) {
            var editor = this.editor;
            var sheet = this._workbook.activeSheet();

            if (this._casualEditing && /^(?:up|right|down|left)$/.test(action)) {
                this.deactivateEditor();
                this.navigator.moveActiveCell(ACTIONS[action]);
                event.preventDefault();
            }
            else if (editor.canInsertRef(true)) {
                this.navigator.moveActiveCell(ACTIONS[action]);
                editor.activeEditor().refAtPoint(sheet);
                sheet._setFormulaSelections(editor.highlightedRefs());
                event.preventDefault();
            }
        },

        onEditorShiftAction: function(event, action) {
            var editor = this.editor;
            var sheet = this._workbook.activeSheet();

            if (editor.canInsertRef(true)) {
                this.navigator.modifySelection(ACTIONS[action.replace("shift+", "")], this.appendSelection);

                editor.activeEditor().refAtPoint(sheet);
                sheet._setFormulaSelections(editor.highlightedRefs());

                event.preventDefault();
            }
        },

////////////////////////////////////////////////////////////////////
        resetEditorValue: function() {
            var sheet = this._workbook.activeSheet();
            var ref = sheet.activeCell();
            var input = this._workbook._inputForRef(ref);
            var x = sheet.range(ref).intersectingArrayFormula();
            if (x) {
                input = "=" + x.formula;
            }
            this.editor.value(input, !!x);
        },

        activateEditor: function(casual) {
            // This flag will be false when F2 has been pressed, and
            // true when editing is "casual", i.e., user just started
            // typing.  In this case we want arrow keys to do cell
            // navigation rather than move the cursor.
            // https://github.com/telerik/kendo-ui-core/issues/3644
            this._casualEditing = casual;

            this.editor.activate({
                range: this._workbook.activeSheet().selection(),
                rect: this.view.activeCellRectangle(),
                tooltip: this._activeTooltip()
            }).focus();
        },

        deactivateEditor: function() {
            this.view.editor.deactivate();
        },

        onCommandRequest: function(e) {
            if (e.command) {
                this._execute(e);
            } else {
                this._workbook.undoRedoStack[e.action]();
            }
        },

        onDialogRequest: function(e) {
            var additionalOptions = {
                pdfExport: this._workbook.options.pdf,
                excelExport: this._workbook.options.excel
            };

            if (e.options) {
                $.extend(true, e.options, additionalOptions);
            } else {
                e.options = additionalOptions;
            }

            this.view.openDialog(e.name, e.options);
        },

        onNameEditorEnter: function() {
            var ref;
            var workbook = this._workbook;
            var sheet = workbook.activeSheet();
            var name = this.view.nameEditor.value();

            // 1. does it look like a reference, or already defined
            // name?  If so, just select it (don't define/modify any
            // names)
            ref = kendo.spreadsheet.calc.parseReference(name, true) || workbook.nameValue(name);
            if (ref instanceof kendo.spreadsheet.Ref) {
                if (ref.sheet && ref.sheet.toLowerCase() != sheet.name().toLowerCase()) {
                    // reference points to another sheet, select it if found
                    var tmp = workbook.sheetByName(ref.sheet);
                    if (tmp) {
                        workbook.activeSheet(tmp);
                        sheet = tmp;
                    }
                }
                sheet.range(ref).select();
                return;
            }

            ref = sheet.selection()._ref.clone().simplify().setSheet(sheet.name(), true);

            // XXX: should we check if a name is already defined for this range, and update it instead?
            // Excel just adds a new one, and provides a more complete Name Manager dialog.
            //var def = workbook.nameForRef(ref, sheet.name());

            // just define new name
            this._execute({
                command: "DefineNameCommand",
                options: { name: name, value: ref }
            });

            this.clipboardElement.trigger("focus");
        },
        onNameEditorCancel: function() {
            this.clipboardElement.trigger("focus");
        },
        onNameEditorSelect: function(ev) {
            var name = ev.name;
            var workbook = this._workbook;
            var sheet = workbook.activeSheet();
            var ref = workbook.nameValue(name);
            if (ref instanceof kendo.spreadsheet.Ref) {
                if (ref.sheet && ref.sheet.toLowerCase() != sheet.name().toLowerCase()) {
                    // reference points to another sheet, select it if found
                    var tmp = workbook.sheetByName(ref.sheet);
                    if (tmp) {
                        workbook.activeSheet(tmp);
                        sheet = tmp;
                    }
                }
                sheet.range(ref).select();
                return;
            }
            this.clipboardElement.trigger("focus");
        },
        onNameEditorDelete: function(ev) {
            this._execute({
                command: "DeleteNameCommand",
                options: { name: ev.name }
            });
            this.clipboardElement.trigger("focus");
        }
    });

    kendo.spreadsheet.Controller = Controller;
})(window.kendo);

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/view',[ "../kendo.core", "../kendo.menu", "./sheetsbar", "../util/main" ], f);
})(function(){

(function(kendo) {

    var $ = kendo.jQuery;
    var CellRef = kendo.spreadsheet.CellRef;
    var DOT = ".";
    var RESIZE_HANDLE_WIDTH = 7;
    var EDIT_BUTTON_WIDTH = 20;
    var ERROR = "Error";
    var viewClassNames = {
        view: "k-spreadsheet-view",
        fixedContainer: "k-spreadsheet-fixed-container",
        editContainer: "k-spreadsheet-edit-container",
        scroller: "k-spreadsheet-scroller",
        viewSize: "k-spreadsheet-view-size",
        clipboard: "k-spreadsheet-clipboard",
        cellEditor: "k-spreadsheet-cell-editor",
        barEditor: "k-spreadsheet-editor",
        topCorner: "k-spreadsheet-top-corner",
        filterHeadersWrapper: "k-filter-wrapper",
        filterRange: "k-filter-range",
        filterButton: "k-spreadsheet-filter",
        filterButtonSelected: "k-selected",
        horizontalResize: "k-horizontal-resize",
        verticalResize: "k-vertical-resize",
        icon: "k-icon",
        iconFilterDefault: "k-i-arrow-60-down",
        sheetsBar: "k-spreadsheet-sheets-bar",
        sheetsBarActive: "k-spreadsheet-sheets-bar-active",
        sheetsBarInactive: "k-spreadsheet-sheets-bar-inactive",
        cellContextMenu: "k-spreadsheet-cell-context-menu",
        rowHeaderContextMenu: "k-spreadsheet-row-header-context-menu",
        colHeaderContextMenu: "k-spreadsheet-col-header-context-menu",
        drawingContextMenu: "k-spreadsheet-drawing-context-menu"
    };

    kendo.spreadsheet.messages.view = {
        nameBox: "Name Box",
        errors: {
            openUnsupported: "Unsupported format. Please select an .xlsx file.",
            shiftingNonblankCells: "Cannot insert cells due to data loss possibility. Select another insert location or delete the data from the end of your worksheet.",
            insertColumnWhenRowIsSelected: "Cannot insert column when all columns are selected.",
            insertRowWhenColumnIsSelected: "Cannot insert row when all rows are selected.",
            filterRangeContainingMerges: "Cannot create a filter within a range containing merges",
            sortRangeContainingMerges: "Cannot sort a range containing merges",
            cantSortMultipleSelection: "Cannot sort multiple selection",
            cantSortNullRef: "Cannot sort empty selection",
            cantSortMixedCells: "Cannot sort range containing cells of mixed shapes",
            validationError: "The value that you entered violates the validation rules set on the cell.",
            cannotModifyDisabled: "Cannot modify disabled cells.",
            insertRowBelowLastRow: "Cannot insert row below the last row.",
            insertColAfterLastCol: "Cannot insert column to the right of the last column."
        },
        tabs: {
            home: "Home",
            insert: "Insert",
            data: "Data"
        }
    };

    kendo.spreadsheet.messages.menus = {
        "cut"          : "Cut",
        "copy"         : "Copy",
        "paste"        : "Paste",
        "merge"        : "Merge",
        "unmerge"      : "Unmerge",
        "delete"       : "Delete",
        "hide"         : "Hide",
        "unhide"       : "Unhide",
        "bringToFront" : "Bring to front",
        "sendToBack"   : "Send to back"
    };

    function selectElementContents(el) {
        var sel = window.getSelection();
        sel.removeAllRanges();

        var range = document.createRange();
        range.selectNodeContents(el);

        sel.addRange(range);
    }

    function cellBefore(table, row) {
        var cells = table.trs[row].children;
        return cells[cells.length - 2];
    }

    function cellAbove(table, row) {
        var prevRow = table.trs[row-1];
        var index = table.trs[row].children.length-1;

        if (prevRow && index >= 0) {
            return prevRow.children[index];
        }
    }

    function cellBorder(value) {
        return (value.size || 1) + "px solid " + (value.color || "#000");
    }

    function asURL(link) {
        if (!/:\/\//.test(link)) {
            link = "http://" + link;
        }
        return link;
    }

    function drawCell(collection, cell, cls, showGrid) {
        function maybeLink(el) {
            var link = cell.link;
            if (!link) {
                if (typeof cell.value == "object") {
                    link = cell.value.link;
                }
            }
            if (link) {
                var style = {
                    textDecoration: "none"
                };
                if (cell.color) {
                    style.color = cell.color;
                }
                if (cell.underline) {
                    style.textDecoration = "underline";
                }
                return kendo.dom.element("a", {
                    href   : asURL(link),
                    style  : style,
                    target : "_blank" // XXX: customizable?
                }, el ? [ el ] : []);
            }
            return el;
        }

        var shouldDraw = (cell.value != null || (cell.validation != null && !cell.validation.value) || // jshint ignore:line
                          cell.background || cell.merged || cell.comment);
        if (!cls && !shouldDraw) {
            return;
        }

        var style = {};
        var background = cell.background;
        if (background) {
            var defaultBorder = background;
            if (showGrid) {
                // darken
                defaultBorder = kendo.parseColor(defaultBorder).toHSV();
                defaultBorder.v *= 0.9;
                defaultBorder = defaultBorder.toCssRgba();
            }
            defaultBorder = cellBorder({ color: defaultBorder });
            style.outline = defaultBorder;
        }

        if (background) {
            style.backgroundColor = background;
        }

        if (cell.color) {
            style.color = cell.color;
        }

        if (cell.fontFamily) {
            style.fontFamily = cell.fontFamily;
        }

        if (cell.underline) {
            style.textDecoration = "underline";
        }

        if (cell.italic) {
            style.fontStyle = "italic";
        }

        if (cell.textAlign) {
            style.textAlign = cell.textAlign;
        }

        if (cell.bold) {
            style.fontWeight = "bold";
        }

        if (cell.fontSize) {
            style.fontSize = cell.fontSize + "px";
        }

        if (cell.wrap === true) {
            style.whiteSpace = "pre-wrap";
            style.overflowWrap = "break-word";
            style.wordWrap = "break-word";
        } else {
            style.whiteSpace = "pre";
            style.overflowWrap = "normal";
            style.wordWrap = "normal";
        }

        style.left = (cell.left + 1) + "px";
        style.top = (cell.top + 1) + "px";
        style.width = (cell.width - 1) + "px";
        style.height = (cell.height - 1) + "px";

        var data = cell.value, type = typeof data, format = cell.format;
        if (!format && type == "number" && data != Math.floor(data)) {
            format = "0.##############";
        }
        if (format && data != null) { // jshint ignore:line
            data = kendo.spreadsheet.formatting.format(data, format);
            if (data.__dataType) {
                type = data.__dataType;
            }
        } else if (data !== null && data !== undefined) {
            if(cell.html){
                data = kendo.dom.html(data);
            } else {
                data = kendo.dom.text(data);
            }
        }

        if (!style.textAlign) {
            switch (type) {
              case "number":
              case "date":
              case "percent":
              case "currency":
                style.textAlign = "right";
                break;
              case "boolean":
                style.textAlign = "center";
                break;
            }
        }

        // defined in print.js
        kendo.spreadsheet.draw.applyIndent(cell, style);

        var classNames = [ paneClassNames.cell ];

        if (cls) {
            classNames.push(cls);
        }
        if (cell.enable === false) {
            classNames.push("k-state-disabled");
        }
        if (cell.merged) {
            classNames.push("k-spreadsheet-merged-cell");
        }
        if (cell.comment) {
            classNames.push("k-spreadsheet-has-comment");
        }

        var verticalAlign = cell.verticalAlign || "bottom";

        if (verticalAlign && data) {
            data = kendo.dom.element("div", { className: "k-vertical-align-" + verticalAlign }, [ maybeLink(data) ]);
        } else {
            data = maybeLink(data);
        }

        var children = data ? [ data ] : [];
        var properties = {
            style: style
        };
        var validation = cell.validation;
        if (validation && !validation.value) {
            children.push(kendo.dom.element("span", { className: "k-dirty" }));
            classNames.push("k-dirty-cell");

            properties.title = validation.message;
        }
        properties.className = classNames.join(" ");

        var div = kendo.dom.element("div", properties, children);
        collection.push(div);
        return div;
    }

    function addCell(table, row, cell) {
        var style = {};

        if (cell.background) {
            style.backgroundColor = cell.background;
        }

        if (cell.color) {
            style.color = cell.color;
        }

        if (cell.fontFamily) {
            style.fontFamily = cell.fontFamily;
        }

        if (cell.underline) {
            style.textDecoration = "underline";
        }

        if (cell.italic) {
            style.fontStyle = "italic";
        }

        if (cell.textAlign) {
            style.textAlign = cell.textAlign;
        }

        if (cell.verticalAlign) {
            style.verticalAlign = (cell.verticalAlign === "center") ? "middle" : cell.verticalAlign;
        }

        if (cell.bold) {
            style.fontWeight = "bold";
        }

        if (cell.fontSize) {
            style.fontSize = cell.fontSize + "px";
        }

        if (cell.wrap === true) {
            style.whiteSpace = "pre-wrap";
        }

        if (cell.borderRight) {
            style.borderRight = cellBorder(cell.borderRight);
        } else if (cell.background) {
            style.borderRightColor = cell.background;
        }

        if (cell.borderBottom) {
            style.borderBottom = cellBorder(cell.borderBottom);
        } else if (cell.background) {
            style.borderBottomColor = cell.background;
        }

        var data = cell.value, type = typeof data, format = cell.format;
        if (!format && type == "number" && data != Math.floor(data)) {
            format = "0.##############";
        }
        if (format && data != null) { // jshint ignore:line
            data = kendo.spreadsheet.formatting.format(data, format);
            if (data.__dataType) {
                type = data.__dataType;
            }
        }

        if (!style.textAlign) {
            switch (type) {
              case "number":
              case "date":
              case "percent":
              case "currency":
                style.textAlign = "right";
                break;
              case "boolean":
                style.textAlign = "center";
                break;
            }
        }

        var className = null;

        if (cell.enable === false) {
            className = "k-state-disabled";
        }

        var td = table.addCell(row, data, style, className, cell.validation);

        var border, sibling;

        if (cell.borderLeft) {
            sibling = cellBefore(table, row);
            border = cellBorder(cell.borderLeft);
            if (sibling && border) {
                sibling.attr.style.borderRight = border;
            }
        } else if (cell.background) {
            style.borderLeftColor = cell.background;
        }

        if (cell.borderTop) {
            sibling = cellAbove(table, row);
            border = cellBorder(cell.borderTop);
            if (sibling && border) {
                sibling.attr.style.borderBottom = border;
            }
        } else if (cell.background) {
            style.borderTopColor = cell.background;
        }

        return td;
    }

    var HtmlTable = kendo.Class.extend({
        init: function() {
            this.cols = [];
            this.trs = [];
            this._height = 0;
            this._width = 0;
        },

        addColumn: function(width) {
            this._width += width;

            var col = kendo.dom.element("col", { style: { width: width + "px" } });

            col.visible = width > 0;

            this.cols.push(col);
        },

        addRow: function(height) {
            var attr = null;

            attr = { style: { height: height + "px" } };

            this._height += height;

            var tr = kendo.dom.element("tr", attr);

            tr.visible = height > 0;

            this.trs.push(tr);
        },

        addCell: function(rowIndex, text, style, className, validation) {
            if (text === null || text === undefined) {
                text = "";
            }
            if (!(text instanceof kendo.dom.Node)) {
                text = kendo.dom.text(text);
            }

            var children = [ text ];
            var properties = { style: style };

            if (validation && !validation.value) {
                children.push(kendo.dom.element("span", { className: "k-dirty" }));

                className = (className || "") + (className ? " " : "") + "k-dirty-cell";
                properties.title = validation.message;
            }

            if (className) {
                properties.className = className;
            }
            var td = kendo.dom.element("td", properties, children);

            this.trs[rowIndex].children.push(td);
            return td;
        },

        toDomTree: function(x, y, className) {
            this.trs = this.trs.filter(function(tr) {
                return tr.visible;
            });

            var offset = 0;
            this.cols = this.cols.filter(function(col, ci) {
                if (!col.visible) {
                    this.trs.forEach(function(tr) {
                        tr.children.splice(ci - offset, 1);
                    });
                    offset++;
                }

                return col.visible;
            }, this);

            return kendo.dom.element("table", {
                style: { left: x + "px", top: y + "px", height: this._height + "px", width: this._width + "px" },
                className: className,
                role: "presentation"
            },[
                kendo.dom.element("colgroup", null, this.cols),
                kendo.dom.element("tbody", null, this.trs)
            ]);
        }
    });

    var CELL_CONTEXT_MENU = '<ul class="#=classNames.cellContextMenu#">' +
        '<li data-action=cut>#: messages.cut #</li>' +
        '<li data-action=copy>#: messages.copy #</li>' +
        '<li data-action=paste>#: messages.paste #</li>' +
        '<li class="k-separator"></li>' +
        '<li data-action=merge>#: messages.merge #</li>' +
        '<li data-action=unmerge>#: messages.unmerge #</li>' +
    '</ul>';

    var ROW_HEADER_CONTEXT_MENU = '<ul class="#=classNames.rowHeaderContextMenu#">' +
        '<li data-action=cut>#: messages.cut #</li>' +
        '<li data-action=copy>#: messages.copy #</li>' +
        '<li data-action=paste>#: messages.paste #</li>' +
        '<li class="k-separator"></li>' +
        '<li data-action="delete-row">#: messages.delete #</li>'+
        '<li data-action="hide-row">#: messages.hide #</li>'+
        '<li data-action="unhide-row">#: messages.unhide #</li>'+
    '</ul>';

    var COL_HEADER_CONTEXT_MENU = '<ul class="#=classNames.colHeaderContextMenu#">' +
        '<li data-action=cut>#: messages.cut #</li>' +
        '<li data-action=copy>#: messages.copy #</li>' +
        '<li data-action=paste>#: messages.paste #</li>' +
        '<li class="k-separator"></li>' +
        '<li data-action="delete-column">#: messages.delete #</li>'+
        '<li data-action="hide-column">#: messages.hide #</li>'+
        '<li data-action="unhide-column">#: messages.unhide #</li>'+
    '</ul>';

    var DRAWING_CONTEXT_MENU = '<ul class="#=classNames.drawingContextMenu#">' +
        // '<li data-action=cut>#: messages.cut #</li>' +
        // '<li data-action=copy>#: messages.copy #</li>' +
        // '<li data-action=paste>#: messages.paste #</li>' +
        // '<li class="k-separator"></li>' +
        '<li data-action="bring-to-front">#: messages.bringToFront #</li>' +
        '<li data-action="send-to-back">#: messages.sendToBack #</li>' +
        '<li class="k-separator"></li>' +
        '<li data-action="delete-drawing">#: messages.delete #</li>' +
    '</ul>';

    kendo.spreadsheet.ContextMenu = kendo.ui.ContextMenu;

    var VIEW_CONTENTS = kendo.template('<div class="#=classNames.view#"><div class="#=classNames.fixedContainer#"></div><div class="#=classNames.scroller#"><div class="#=classNames.viewSize#"></div></div>' +
        '<div tabindex="0" class="#=classNames.clipboard#" contenteditable=true></div><div class="#=classNames.cellEditor#"></div></div><div class="#=classNames.sheetsBar#"></div>' +
        CELL_CONTEXT_MENU + ROW_HEADER_CONTEXT_MENU + COL_HEADER_CONTEXT_MENU + DRAWING_CONTEXT_MENU
    );

    function within(value, min, max) {
        return value >= min && value <= max;
    }

    var View = kendo.Class.extend({
        init: function(element, options) {
            var classNames = View.classNames;

            this.element = element;

            this.options = $.extend(true, {
                messages: kendo.spreadsheet.messages.view
            }, this.options, options);

            this._chrome();

            this._dialogs = [];

            element.append(VIEW_CONTENTS({
                classNames: classNames,
                messages: kendo.spreadsheet.messages.menus
            }));

            this._formulaInput();

            this.wrapper =      element.find(DOT + classNames.view);
            this.container =    element.find(DOT + classNames.fixedContainer)[0];
            this.scroller =     element.find(DOT + classNames.scroller)[0];
            this.clipboard =    element.find(DOT + classNames.clipboard);

            this.viewSize = $(this.scroller.firstChild);

            this.tree = new kendo.dom.Tree(this.container);
            this.clipboardContents = new kendo.dom.Tree(this.clipboard[0]);

            this.editor = new kendo.spreadsheet.SheetEditor(this);

            this._sheetsbar();

            var contextMenuConfig = {
                target: element,
                animation: false,
                showOn: "never" // this is just an invalid event name to prevent the show
            };

            this.cellContextMenu = new kendo.spreadsheet.ContextMenu(element.find(DOT + classNames.cellContextMenu), contextMenuConfig);

            this.colHeaderContextMenu = new kendo.spreadsheet.ContextMenu(element.find(DOT + classNames.colHeaderContextMenu), contextMenuConfig);

            this.rowHeaderContextMenu = new kendo.spreadsheet.ContextMenu(element.find(DOT + classNames.rowHeaderContextMenu), contextMenuConfig);

            this.drawingContextMenu = new kendo.spreadsheet.ContextMenu(element.find(DOT + classNames.drawingContextMenu), contextMenuConfig);
        },

        enableClipboard: function(enable) {
            this.isClipboardDeactivated = !enable;

            if (enable) {
                this.clipboard.attr("contenteditable", enable);
            } else {
                this.clipboard.removeAttr("contenteditable");
            }
        },

        _resize: function() {
            var actionBar = $(this.formulaBar.element).parents(".k-spreadsheet-action-bar");
            var outerHeight = kendo._outerHeight;
            var tabstripHeight = this.tabstrip ? outerHeight(this.tabstrip.element) : 0;
            var formulaBarHeight = actionBar ? outerHeight(actionBar) : 0;
            var sheetsBarHeight = this.sheetsbar ? outerHeight(this.sheetsbar.element) : 0;

            this.wrapper.height(
                this.element.height() -
                    (tabstripHeight + formulaBarHeight + sheetsBarHeight)
            );

            if (this.tabstrip) {
                this.tabstrip.quickAccessAdjust();
            }
        },

        _chrome: function() {
            var wrapper = $("<div class='k-spreadsheet-action-bar' />").prependTo(this.element);

            var nameEditor = $("<div class='k-spreadsheet-name-editor' />").appendTo(wrapper);
            this.nameEditor = new kendo.spreadsheet.NameEditor(nameEditor, this.options);

            var formulaBar = $("<div />").appendTo(wrapper);
            this.formulaBar = new kendo.spreadsheet.FormulaBar(formulaBar);

            if (this.options.toolbar) {
                this._tabstrip();
            }
        },

        _formulaInput: function() {
            var editor = this.element.find(DOT + View.classNames.cellEditor);

            this.formulaInput = new kendo.spreadsheet.FormulaInput(editor, {
                autoScale: true
            });
        },

        _sheetsbar: function() {
            if (this.options.sheetsbar) {
                var options = $.extend(true, {
                    openDialog: this.openDialog.bind(this)
                }, this.options.sheetsbar);

                this.sheetsbar = new kendo.spreadsheet.SheetsBar(this.element.find(DOT + View.classNames.sheetsBar), options);
            }
        },

        _tabstrip: function() {
            var messages = this.options.messages.tabs;
            var options = $.extend(true, { home: true, insert: true, data: true }, this.options.toolbar);
            var tabs = [];

            if (this.tabstrip) {
                this.tabstrip.destroy();
                this.element.children(".k-tabstrip").remove();
            }

            for (var name in options) {
                if (options[name] === true || options[name] instanceof Array) {
                    tabs.push({ id: name, text: messages[name], content: "" });
                }
            }

            this.tabstrip = new kendo.spreadsheet.TabStrip($("<div />").prependTo(this.element), {
                animation: false,
                dataTextField: "text",
                dataContentField: "content",
                dataSource: tabs,
                toolbarOptions: options,
                view: this
            });

            this.tabstrip.select(0);
        },

        _executeCommand: function(e) {
            this._sheet.trigger("commandRequest", e);
        },

        workbook: function(workbook) {
            this._workbook = workbook;
            workbook._view = this;
            this.nameEditor._workbook = workbook;
        },

        sheet: function(sheet) {
            this._sheet = sheet;
        },

        activeCellRectangle: function() {
            return this.cellRectangle(this._sheet._viewActiveCell());
        },

        _rectangle: function(pane, ref) {
            return pane._grid.boundingRectangle(ref.toRangeRef());
        },

        isColumnResizer: function(x, pane, col) {
            // relative to content
            x -= this._sheet._grid._headerWidth;

            // add scroll if pane is not frozen
            if (!pane._grid.columns.frozen) {
                x += this.scroller.scrollLeft;
            }

            col = this._sheet._grid._columns.locate(0, col, function(w){
                return Math.abs(x - w) <= RESIZE_HANDLE_WIDTH/2;
            });

            return col !== null && !this._sheet.isHiddenColumn(col) ? col : null;
        },

        isRowResizer: function(y, pane, row) {
            // relative to content
            y -= this._sheet._grid._headerHeight;

            // add scroll if pane is not frozen
            if (!pane._grid.rows.frozen) {
                y += this.scroller.scrollTop;
            }

            row = this._sheet._grid._rows.locate(0, row, function(h){
                return Math.abs(y - h) <= RESIZE_HANDLE_WIDTH/2;
            });

            return row !== null && !this._sheet.isHiddenRow(row) ? row : null;
        },

        isFilterIcon: function(x, y, pane, ref) {
            var self = this;
            var theGrid = pane._grid;
            var scrollTop = theGrid.rows.frozen ? 0 : self.scroller.scrollTop;
            var scrollLeft = theGrid.columns.frozen ? 0 : self.scroller.scrollLeft;

            x -= self._sheet._grid._headerWidth - scrollLeft;
            y -= self._sheet._grid._headerHeight - scrollTop;

            return kendo.util.withExit(function(exit){
                self._sheet.forEachFilterHeader(ref, function(ref) {
                    var rect = self._rectangle(pane, ref);
                    if (pane.filterIconRect(rect).intersects(x, y)) {
                        exit(true);
                    }
                });
            });
        },

        isAutoFill: function(x, y, pane) {
            var selection = this._sheet.select();

            if (selection.size > 1) {
                return false;
            }

            x -= this._sheet._grid._headerWidth;
            y -= this._sheet._grid._headerHeight;

            if (!pane._grid.columns.frozen) {
                x += this.scroller.scrollLeft;
            }

            if (!pane._grid.rows.frozen) {
                y += this.scroller.scrollTop;
            }

            var rectangle = this._rectangle(pane, selection);

            return Math.abs(rectangle.right - x) < 8 && Math.abs(rectangle.bottom - y) < 8;
        },

        isEditButton: function(x, y, pane) {
            var ed = this._sheet.activeCellCustomEditor();
            if (ed) {
                var r = this.activeCellRectangle();
                // XXX: hard-coded button width (20)

                if (y >= r.top && y <= r.bottom) {
                    return pane._editorInLastColumn ? x < r.left && x >= r.left - EDIT_BUTTON_WIDTH
                        : x > r.right && x <= r.right + EDIT_BUTTON_WIDTH;
                }
            }
        },

        drawingAt: function(x, y, pane) {
            x -= this._sheet._grid._headerWidth;
            y -= this._sheet._grid._headerHeight;

            if (!pane._grid.columns.frozen) {
                x += this.scroller.scrollLeft;
            }

            if (!pane._grid.rows.frozen) {
                y += this.scroller.scrollTop;
            }

            var sheet = this._sheet;
            var drawings = this._sheet._drawings;
            for (var i = drawings.length; --i >= 0;) {
                var d = drawings[i];
                var box = sheet.drawingBoundingBox(d);
                if (box.intersects(x, y)) {
                    return {
                        drawing: d,

                        // also include how far is the drawing's
                        // top-left from the mouse position, as it's
                        // not easy to compute some place else.
                        drx: box.left - x,
                        dry: box.top - y
                    };
                }
            }
        },

        objectAt: function(x, y, noDrawing) {
            var grid = this._sheet._grid;
            var object, pane;

            if (x < 0 || y < 0 || x > this.scroller.clientWidth || y > this.scroller.clientHeight) {
                object = { type: "outside" };
            } else if (x < grid._headerWidth && y < grid._headerHeight) {
                object = { type: "topcorner" };
            } else {
                pane = this.paneAt(x, y);

                if (!pane) {
                    object = { type: "outside" };
                } else {
                    if (!noDrawing) {
                        var drawing = this.drawingAt(x, y, pane);
                        if (drawing) {
                            return {
                                type: "drawing",
                                drawing: drawing.drawing,
                                drx: drawing.drx,
                                dry: drawing.dry,
                                pane: pane,
                                startX: x,
                                startY: y
                            };
                        }
                    }

                    var row = pane._grid.rows.indexVisible(y, this.scroller.scrollTop);
                    var column = pane._grid.columns.indexVisible(x, this.scroller.scrollLeft);

                    var type = "cell";
                    var ref = new CellRef(row, column);
                    var selecting = this._sheet.selectionInProgress();

                    if (this.isAutoFill(x, y, pane)) {
                        type = "autofill";
                    } else if (this.isFilterIcon(x, y, pane, ref)) {
                        type = "filtericon";
                    } else if (!selecting && x < grid._headerWidth) {
                        type = "rowheader";
                        if ((row = this.isRowResizer(y, pane, row)) !== null) {
                            ref = new CellRef(row, -Infinity);
                            type = "rowresizehandle";
                        }
                    } else if (!selecting && y < grid._headerHeight) {
                        type = "columnheader";
                        if ((column = this.isColumnResizer(x, pane, column)) !== null) {
                            ref = new CellRef(-Infinity, column);
                            type = "columnresizehandle";
                        }
                    } else if (this.isEditButton(x, y, pane)) {
                        type = "editor";
                    }

                    object = { type: type, ref: ref };
                }
            }

            object.pane = pane;
            object.x = x;
            object.y = y;
            return object;
        },

        paneAt: function(x, y) {
            return this.panes.filter(function paneLocationWithin(pane) {
                var grid = pane._grid;
                return within(y, grid.top, grid.bottom) && within(x, grid.left, grid.right);
            })[0];
        },

        containingPane: function(cell) {
            return this.panes.filter(function(pane) {
                if (pane._grid.contains(cell)) {
                    return true;
                }
                return false;
            })[0];
        },

        cellRectangle: function(cell) {
            var theGrid = this.containingPane(cell)._grid;
            var rectangle = this._sheet._grid.rectangle(cell);

            return rectangle.offset(
                theGrid.headerWidth - (theGrid.columns.frozen ? 0 : this.scroller.scrollLeft),
                theGrid.headerHeight - (theGrid.rows.frozen ? 0 : this.scroller.scrollTop)
            );
        },

        refresh: function(reason) {
            var sheet = this._sheet;

            if (this.tabstrip) {
                this.tabstrip.refreshTools(sheet.range(sheet.activeCell()));
            }

            if (reason.sheetSelection && this.sheetsbar) {
                this.sheetsbar.renderSheets(this._workbook.sheets(), this._workbook.sheetIndex(this._sheet));
            }

            this._resize();

            //TODO: refresh sheets list on sheetSelection
            this.viewSize[0].style.height = sheet._grid.totalHeight() + "px";
            this.viewSize[0].style.width = sheet._grid.totalWidth() + "px";

            if (reason.layout) {
                var frozenColumns = sheet.frozenColumns();
                var frozenRows = sheet.frozenRows();

                // main or bottom or right pane
                this.panes = [ this._pane(frozenRows, frozenColumns) ];

                // left pane
                if (frozenColumns > 0) {
                    this.panes.push(this._pane(frozenRows, 0, null, frozenColumns));
                }

                // top pane
                if (frozenRows > 0) {
                    this.panes.push(this._pane(0, frozenColumns, frozenRows, null));
                }

                // left-top "fixed" pane
                if (frozenRows > 0 && frozenColumns > 0) {
                    this.panes.push(this._pane(0, 0, frozenRows, frozenColumns));
                }
            }

            if (reason.filter) {
                this._destroyFilterMenu();
            }

            if (reason.activeCell) {
                this._focus = sheet.activeCell().toRangeRef();
            }
        },

        createFilterMenu: function(column) {
            this._destroyFilterMenu();

            var sheet = this._sheet;
            var ref = sheet.filter().ref;
            var range = new kendo.spreadsheet.Range(ref, sheet);
            var element = $("<div />").appendTo(this.element);
            var options = { column: column, range: range };
            var filterMenu = new kendo.spreadsheet.FilterMenu(element, options);

            this._filterMenu = filterMenu;

            return filterMenu;
        },

        selectClipboardContents: function() {
            if (!this.isClipboardDeactivated) {
                this.clipboard.focus();
                selectElementContents(this.clipboard[0]);
            }
        },

        scrollIntoView: function(cell) {
            var willScroll = false;
            var theGrid = this.containingPane(cell)._grid;

            var boundaries = theGrid.scrollBoundaries(cell);

            var scroller = this.scroller;
            var scrollTop = theGrid.rows.frozen ? 0 : scroller.scrollTop;
            var scrollLeft = theGrid.columns.frozen ? 0 : scroller.scrollLeft;

            if (boundaries.top < scrollTop) {
                willScroll = true;
                scroller.scrollTop = boundaries.scrollTop;
            }

            if (boundaries.bottom > scrollTop) {
                willScroll = true;
                scroller.scrollTop = boundaries.scrollBottom;
            }

            if (boundaries.left < scrollLeft) {
                willScroll = true;
                scroller.scrollLeft = boundaries.scrollLeft;
            }

            if (boundaries.right > scrollLeft) {
                willScroll = true;
                scroller.scrollLeft = boundaries.scrollRight;
            }

            return willScroll;
        },

        _destroyDialog: function() {
            this._dialogs.pop();
        },

        openCustomEditor: function() {
            var self = this;
            var cell = self._sheet.activeCell().first();
            var editor = self._sheet.activeCellCustomEditor();
            var range = self._sheet.range(cell);
            editor.edit({
                range      : range,
                rect       : self.activeCellRectangle(),
                view       : this,
                validation : this._sheet.validation(cell),
                callback   : function(value, parse){
                    self._executeCommand({
                        command: "EditCommand",
                        options: {
                            operatingRange: range,
                            editRange: range,
                            property: parse ? "input" : "value",
                            value: value
                        }
                    });
                }
            });
        },

        openDialog: function(name, options) {
            var sheet = this._sheet;
            return sheet.withCultureDecimals(function(){
                var dialog = kendo.spreadsheet.dialogs.create(name, options);

                if (dialog) {
                    dialog.bind("action", this._executeCommand.bind(this));
                    dialog.bind("deactivate", this._destroyDialog.bind(this));
                    this._dialogs.push(dialog);

                    var ref = sheet.activeCell();
                    var range = new kendo.spreadsheet.Range(ref, sheet);

                    dialog.open(range);
                    return dialog;
                }
            }.bind(this));
        },

        showError: function(options, reopenEditor) {
            var currentDialogs = this._dialogs;
            var errorMessages = this.options.messages.errors;
            var hasOpenedError = false;

            if (currentDialogs.length > 0) {
                currentDialogs.forEach(function(dialog) {
                    if (dialog.options && dialog.options.title === ERROR) {
                        hasOpenedError = true;
                    }
                });
            }
            if (hasOpenedError) {
                return;
            }

            var focusButton = function(e) {
                var cont = e.sender.dialog().element;
                cont.find(".k-button").first().trigger("focus");
                cont.find(".k-button, input").on("keydown", function(ev){
                    if (ev.keyCode == kendo.keys.ESC) {
                        e.sender.close();
                    }
                });
            };

            var onClose = function(e) {
                var dlg = e.sender;
                this.selectClipboardContents();
                if (dlg._retry && reopenEditor) {
                    reopenEditor();
                }
            }.bind(this);

            if (kendo.spreadsheet.dialogs.registered(options.type)) {
                var dialogOptions = {
                    close: onClose
                };

                if (options.type === "validationError") {
                    dialogOptions = $.extend(dialogOptions, {
                        title: options.title || "Error",
                        text: options.body ? options.body : errorMessages[options.type],
                        activate: focusButton
                    });
                }

                this.openDialog(options.type, dialogOptions);
            } else {
                this.openDialog("message", {
                    title : options.title || "Error",
                    text  : options.body ? options.body : errorMessages[options.type],
                    activate: focusButton,
                    close: onClose
                });
            }
        },

        destroy: function() {
            this._dialogs.forEach(function(dialog) {
                dialog.destroy();
            });

            if (this.cellContextMenu) {
                this.cellContextMenu.destroy();
            }

            this.rowHeaderContextMenu.destroy();
            this.colHeaderContextMenu.destroy();
            this.drawingContextMenu.destroy();

            this.cellContextMenu = this.rowHeaderContextMenu =
                                   this.colHeaderContextMenu =
                                   this.drawingContextMenu = null;

            if (this.tabstrip) {
                this.tabstrip.destroy();
                this.tabstrip = null;
            }

            this._destroyFilterMenu();
        },

        _destroyFilterMenu: function() {
            if (this._filterMenu) {
                this._filterMenu.destroy();
                this._filterMenu = undefined;
                this._filterMenuColumn = undefined;
            }
        },

        render: function(reason) {
            if (!this.element.is(":visible")) {
                return;
            }
            var sheet = this._sheet;
            var focus = sheet.focus();
            var scrollbarSize = kendo.support.scrollbar();
            var contentWidth = this.wrapper[0].clientWidth - scrollbarSize;
            var contentHeight = this.wrapper[0].clientHeight - scrollbarSize;

            if (focus && this.scrollIntoView(focus)) {
                return;
            }

            var resizeDirection =
                !sheet.resizingInProgress() ? "none" :
                sheet.resizeHandlePosition().col === -Infinity ? "column" :
                "row";

            this.wrapper
                .toggleClass(viewClassNames.editContainer, this.editor.isActive())
                .toggleClass(viewClassNames.horizontalResize, resizeDirection == "row")
                .toggleClass(viewClassNames.verticalResize, resizeDirection == "column");

            var grid = sheet._grid;
            var content = [];
            var args = {
                scroller: this.scroller,
                toplevelElements: content,
                contentWidth: contentWidth,
                contentHeight: contentHeight
            };
            this.panes.forEach(function(pane) {
                content.push(pane.render(args));
            });

            var topCorner = kendo.dom.element("div", {
                style: { width: grid._headerWidth + "px", height: grid._headerHeight + "px" },
                className: View.classNames.topCorner
            });

            content.push(topCorner);

            if (sheet.resizeHandlePosition() && sheet.resizeHintPosition()) {
                content.push(this.renderResizeHint());
            }

            this.tree.render(content);

            $(this.container).css({
                width: contentWidth,
                height: contentHeight
            });

            if (this.editor.isActive()) {
                this.editor.toggleTooltip(this.activeCellRectangle());
            } else if (!(reason.resize ||
                         reason.comment ||
                         sheet.selectionInProgress() ||
                         sheet.resizingInProgress() ||
                         sheet.draggingInProgress() ||
                         sheet.isInEditMode())) {
                this.renderClipboardContents();
            }
        },

        // this renders the big blue line during resizing
        renderResizeHint: function() {
            var sheet = this._sheet;
            var ref = sheet.resizeHandlePosition();

            var horizontal = ref.col !== -Infinity;

            var style;
            if (horizontal) {
                style = {
                    height: this.scroller.clientHeight + "px",
                    width: RESIZE_HANDLE_WIDTH + "px",
                    left: sheet.resizeHintPosition().x + "px",
                    top: "0px"
                };
            } else {
                style = {
                    height: RESIZE_HANDLE_WIDTH + "px",
                    width: this.scroller.clientWidth + "px",
                    top: sheet.resizeHintPosition().y + "px",
                    left: "0px"
                };
            }

            var classNames = Pane.classNames;

            return kendo.dom.element("div", {
                className: classNames.resizeHint + (!horizontal ? " " + classNames.resizeHintVertical : ""),
                style: style
            },[
                kendo.dom.element("div", { className: classNames.resizeHintHandle }),
                kendo.dom.element("div", { className: classNames.resizeHintMarker })
            ]);
        },

        renderClipboardContents: function() {
            var sheet = this._sheet;
            var grid = sheet._grid;

            // if (sheet._activeDrawing && sheet._activeDrawing.image) {
            //     var url = this._workbook.imageUrl(sheet._activeDrawing.image);
            //     var img = kendo.dom.element("img", {
            //         src: url,
            //         style: {
            //             width: sheet._activeDrawing.width + "px",
            //             height: sheet._activeDrawing.height + "px"
            //         }
            //     });
            //     this.clipboardContents.render([ img ]);
            //     this.selectClipboardContents();
            //     return;
            // }

            var selection = grid.normalize(sheet.select().toRangeRef());
            var status = this._workbook.clipboard().canCopy();
            if (status.canCopy === false && status.multiSelection) {
                this.clipboardContents.render([]);
                this.selectClipboardContents();
                return;
            }

            selection = sheet.trim(selection);

            var table = new HtmlTable();

            var selectionView = grid.rangeDimensions(selection);

            selectionView.rows.forEach(function(height) {
                table.addRow(height);
            });

            selectionView.columns.forEach(function(width) {
                table.addColumn(width);
            });

            var tmp = sheet._getMergedCells(selection);
            var primaryMergedCells = tmp.primary;
            var secondaryMergedCells = tmp.secondary;

            sheet.forEach(selection, function(row, col, cell) {
                var location = new CellRef(row, col).print();

                if (!secondaryMergedCells[location]) {
                    var td = addCell(table, row - selection.topLeft.row, cell);

                    var mergedCell = primaryMergedCells[location];

                    if (mergedCell) {
                        td.attr.colspan = mergedCell.width();
                        td.attr.rowspan = mergedCell.height();
                    }
                }
            });

            if (kendo.support.browser.msie) {
                this.clipboard.empty();
            }

            this.clipboardContents.render([ table.toDomTree(0, 0, "kendo-clipboard-" + this._workbook.clipboard()._uid) ]);

            this.selectClipboardContents();
        },

        _pane: function(row, column, rowCount, columnCount) {
            var pane = new Pane(this._sheet, this._sheet._grid.pane({ row: row, column: column, rowCount: rowCount, columnCount: columnCount }));
            pane.refresh(this.scroller.clientWidth, this.scroller.clientHeight);
            return pane;
        }
    });

    var paneClassNames = {
        cell: "k-spreadsheet-cell",
        vaxis: "k-spreadsheet-vaxis",
        haxis: "k-spreadsheet-haxis",
        vborder: "k-spreadsheet-vborder",
        hborder: "k-spreadsheet-hborder",
        rowHeader: "k-spreadsheet-row-header",
        columnHeader: "k-spreadsheet-column-header",
        pane: "k-spreadsheet-pane",
        data: "k-spreadsheet-data",
        mergedCell: "k-spreadsheet-merged-cell",
        mergedCellsWrapper: "k-merged-cells-wrapper",
        activeCell: "k-spreadsheet-active-cell",
        selection: "k-spreadsheet-selection",
        selectionWrapper: "k-selection-wrapper",
        autoFillWrapper: "k-auto-fill-wrapper",
        single: "k-single",
        top: "k-top",
        right: "k-right",
        bottom: "k-bottom",
        left: "k-left",
        resizeHandle: "k-resize-handle",
        columnResizeHandle: "k-column-resize-handle",
        rowResizeHandle: "k-row-resize-handle",
        resizeHint: "k-resize-hint",
        resizeHintHandle: "k-resize-hint-handle",
        resizeHintMarker: "k-resize-hint-marker",
        resizeHintVertical: "k-resize-hint-vertical",
        selectionHighlight: "k-spreadsheet-selection-highlight",
        series: [
            "k-series-a",
            "k-series-b",
            "k-series-c",
            "k-series-d",
            "k-series-e",
            "k-series-f"
        ]
    };

    var Pane = kendo.Class.extend({
        init: function(sheet, grid) {
            this._sheet = sheet;
            this._grid = grid;
        },

        refresh: function(width, height) {
            this._grid.refresh(width, height);
        },

        isVisible: function(scrollLeft, scrollTop, ref) {
            return this._grid.view(scrollLeft, scrollTop).ref.intersects(ref);
        },

        render: function(args) {
            var scroller = args.scroller;
            var scrollLeft = scroller.scrollLeft;
            var scrollTop = scroller.scrollTop;

            if (scrollTop < 0) {
                scrollTop = 0;
            }

            if (scrollLeft < 0) {
                scrollLeft = 0;
            }

            var classNames = Pane.classNames;
            var sheet = this._sheet;
            var grid = this._grid;
            var view = grid.view(scrollLeft, scrollTop);
            this._currentView = view;
            this._currentRect = this._rectangle(view.ref);
            this._selectedHeaders = sheet.selectedHeaders();

            var children = [];

            children.push(this.renderData(args));

            if (!sheet._activeDrawing) {
                children.push(this.renderSelection(scroller));
            }

            children.push(this.renderAutoFill());

            children.push(this.renderEditorSelection());

            children.push(this.renderFilterHeaders());

            if (grid.hasRowHeader) {
                var rowHeader = kendo.dom.element("div", {
                    className: classNames.rowHeader,
                    style: {
                        width: grid.headerWidth + "px",
                        top: view.rowOffset + "px"
                    }
                });
                children.push(rowHeader);
                sheet.forEach(view.ref.leftColumn(), function(row){
                    if (!sheet.isHiddenRow(row)) {
                        var text = row + 1, height = sheet.rowHeight(row);
                        rowHeader.children.push(kendo.dom.element("div", {
                            className: this.headerClassName(row, "row"),
                            style: {
                                width: grid.headerWidth + "px",
                                height: height + "px"
                            }
                        }, [ kendo.dom.element("div", {
                            className: "k-vertical-align-center"
                        }, [ kendo.dom.text(text+"") ])]));
                    }
                }.bind(this));
            }

            if (grid.hasColumnHeader) {
                var columnHeader = kendo.dom.element("div", {
                    className: classNames.columnHeader,
                    style: {
                        top: "0px",
                        left: view.columnOffset + "px",
                        width: this._currentRect.width + "px",
                        height: grid.headerHeight + "px"
                    }
                });
                children.push(columnHeader);
                var left = 0;
                sheet.forEach(view.ref.topRow(), function(row, col){
                    if (!sheet.isHiddenColumn(col)) {
                        var text = kendo.spreadsheet.Ref.display(null, Infinity, col),
                            width = sheet.columnWidth(col);
                        columnHeader.children.push(kendo.dom.element("div", {
                            className: this.headerClassName(col, "col"),
                            style: {
                                position: "absolute",
                                left: left + "px",
                                width: width + "px",
                                height: grid.headerHeight + "px"
                            }
                        }, [ kendo.dom.element("div", {
                            className: "k-vertical-align-center"
                        }, [ kendo.dom.text(text+"") ])]));
                        left += width;
                    }
                }.bind(this));
            }

            if (sheet.resizeHandlePosition() && (grid.hasColumnHeader || grid.hasRowHeader)) {
                if (!sheet.resizeHintPosition()) {
                    this.renderResizeHandle(children);
                }
            }

            var paneClasses = [classNames.pane];

            if (grid.hasColumnHeader) {
                paneClasses.push(classNames.top);
            }

            if (grid.hasRowHeader) {
                paneClasses.push(classNames.left);
            }

            return kendo.dom.element("div", {
                style: grid.style,
                className: paneClasses.join(" ")
            }, children);
        },

        headerClassName: function(index, type) {
            var selectedHeaders = this._selectedHeaders;

            var itemSelection;
            var allHeaders;

            if (type === "row") {
                itemSelection = selectedHeaders.rows[index];
                allHeaders = selectedHeaders.allRows;
            } else {
                itemSelection = selectedHeaders.cols[index];
                allHeaders = selectedHeaders.allCols;
            }

            var className = itemSelection || (selectedHeaders.all ? "full" : (allHeaders ? "partial" : "none"));

            if (className) {
                className = "k-selection-" + className;
            }

            return className;
        },

        renderData: function(args) {
            var sheet = this._sheet;
            var view = this._currentView;
            var cont = kendo.dom.element("div", {
                className: Pane.classNames.data,
                style: {
                    position: "relative",
                    left: view.columnOffset + "px",
                    top: view.rowOffset + "px"
                }
            });
            var rect = this._currentRect;
            var layout = kendo.spreadsheet.draw.doLayout(sheet, view.ref, { forScreen: true }), prev;
            var grid = this._grid;
            var showGridLines = sheet._showGridLines;
            if (showGridLines) {
                // draw axis first
                prev = null;
                layout.xCoords.forEach(function(x){
                    if (x !== prev) {
                        prev = x;
                        cont.children.push(kendo.dom.element("div", {
                            className: paneClassNames.vaxis,
                            style: {
                                left: x + "px",
                                height: rect.height + "px",
                                borderColor: sheet.gridLinesColor()
                            }
                        }));
                    }
                });
                prev = null;
                layout.yCoords.forEach(function(y){
                    if (y !== prev) {
                        prev = y;
                        cont.children.push(kendo.dom.element("div", {
                            className: paneClassNames.haxis,
                            style: {
                                top: y + "px",
                                width: rect.width + "px",
                                borderColor: sheet.gridLinesColor()
                            }
                        }));
                    }
                });
            }
            var borders = kendo.spreadsheet.draw.Borders();
            var activeCellRange = sheet.activeCell().toRangeRef();
            var activeCell = activeCellRange.topLeft;

            layout.cells.forEach(function(cell){
                var cls = null;
                var absRow = cell.row + view.ref.topLeft.row;
                var absCol = cell.col + view.ref.topLeft.col;
                if (sheet._activeDrawing) {
                    var ref = sheet._activeDrawing.topLeftCell;
                    if (ref && ref.row == absRow && ref.col == absCol) {
                        cls = "k-spreadsheet-drawing-anchor-cell";
                    }
                } else if (absRow == activeCell.row && absCol == activeCell.col) {
                    // active cell.  normally we enter here only once.
                    cls = [
                        Pane.classNames.activeCell
                    ].concat(this._activeFormulaColor(),
                             this._directionClasses(activeCellRange));
                    if (sheet.singleCellSelection()) {
                        cls.push(Pane.classNames.single);
                    }
                    cls = cls.join(" ");
                }
                borders.add(cell);
                drawCell(cont.children, cell, cls, showGridLines);
                if (cell.comment && sheet._commentRef &&
                    absRow == sheet._commentRef.row && absCol == sheet._commentRef.col) {
                    var ttOffset = 4;
                    var left = cell.right + grid.left + view.columnOffset + ttOffset;
                    var style = { top: (cell.top + grid.top + view.rowOffset) + "px" };
                    if (left + 200 > args.contentWidth) {
                        style.right = (args.contentWidth - grid.left - cell.left - view.columnOffset + ttOffset) + "px";
                    } else {
                        style.left = left + "px";
                    }
                    var div = kendo.dom.element("div", {
                        className: "k-tooltip k-spreadsheet-cell-comment",
                        style: style
                    }, [ kendo.dom.text(cell.comment) ]);
                    args.toplevelElements.push(div);
                }
            }, this);
            borders.vert.forEach(function(a){
                a.forEach(function(b){
                    if (!b.rendered) {
                        b.rendered = true;
                        var style = {
                            left        : b.x + "px",
                            top         : b.top + "px",
                            height      : (b.bottom - b.top + 1) + "px",
                            borderWidth : b.size + "px",
                            borderColor : b.color
                        };
                        if (b.size != 1) {
                            style.transform = "translateX(-" + (b.size-1)/2 + "px)";
                        }
                        cont.children.push(kendo.dom.element("div", {
                            className: paneClassNames.vborder,
                            style: style
                        }));
                    }
                });
            });
            borders.horiz.forEach(function(a){
                a.forEach(function(b){
                    if (!b.rendered) {
                        b.rendered = true;
                        var style = {
                            top         : b.y + "px",
                            left        : b.left + "px",
                            width       : (b.right - b.left) + "px",
                            borderWidth : b.size + "px",
                            borderColor : b.color
                        };
                        if (b.size != 1) {
                            style.transform = "translateY(-" + (b.size-1)/2 + "px)";
                        }
                        cont.children.push(kendo.dom.element("div", {
                            className: paneClassNames.hborder,
                            style: style
                        }));
                    }
                });
            });
            this.renderDrawings(layout, cont.children);
            return cont;
        },

        renderDrawings: function(layout, container) {
            var sheet = this._sheet;
            var workbook = sheet._workbook;
            layout.drawings.forEach(function(d){
                var drawing = d.drawing;
                var box = d.box;
                var div = box.toDiv("k-spreadsheet-drawing");
                if (drawing.image) {
                    div.children.push(kendo.dom.element("div", {
                        className: "k-spreadsheet-drawing-image",
                        style: {
                            backgroundImage: "url('" + workbook.imageUrl(drawing.image) + "')",
                            opacity: drawing.opacity
                        }
                    }));
                }
                if (drawing === sheet._activeDrawing) {
                    div.attr.className += " k-spreadsheet-active-drawing";
                    drawingResizeHandles(div.children);
                }
                container.push(div);
            });
        },

        renderResizeHandle: function(container) {
            var sheet = this._sheet;
            var ref = sheet.resizeHandlePosition();
            var rectangle = this._rectangle(ref);
            var classNames = [ Pane.classNames.resizeHandle ];

            var style;
            if (ref.col !== -Infinity) {
                if (this._grid.rows._start > 0) {
                    return;
                }
                style = {
                    height: this._grid.headerHeight + "px",
                    width: RESIZE_HANDLE_WIDTH + "px",
                    left: rectangle.right - RESIZE_HANDLE_WIDTH/2  + "px",
                    top: "0px"
                };
                classNames.push(viewClassNames.horizontalResize);
            } else {
                if (this._grid.columns._start > 0) {
                    return;
                }
                style = {
                    height: RESIZE_HANDLE_WIDTH + "px",
                    width:  this._grid.headerWidth + "px",
                    top: rectangle.bottom - RESIZE_HANDLE_WIDTH/2  + "px",
                    left: "0px"
                };
                classNames.push(viewClassNames.verticalResize);
            }

            container.push(kendo.dom.element("div", {
                className: classNames.join(" "),
                style: style
            }));
        },

        filterIconRect: function(rect) {
            var BUTTON_SIZE = 16;
            var BUTTON_OFFSET = 3;

            return new kendo.spreadsheet.Rectangle(
                rect.right - BUTTON_SIZE - BUTTON_OFFSET,
                rect.top + BUTTON_OFFSET,
                BUTTON_SIZE,
                BUTTON_SIZE
            );
        },

        renderFilterHeaders: function() {
            var sheet = this._sheet;
            var children = [];
            var classNames = View.classNames;
            var filter = sheet.filter();

            function icon(className) {
                return kendo.dom.element("span", {
                    className: classNames.icon + " " + className
                });
            }

            function filterButton(classNames, position, index) {
                var style = {
                    left: position.left + "px",
                    top: position.top + "px"
                };
                var filtered = filter && filter.columns.some(function(c) {
                    return c.index === index;
                });
                var classes = classNames.filterButton;

                if (filtered) {
                    classes += " " + classNames.filterButtonSelected;
                }

                var button = kendo.dom.element(
                    "span",
                    { className: classes, style: style },
                    [ icon(classNames.iconFilterDefault) ]
                );

                return button;
            }

            if (filter) {
                this._addDiv(children, filter.ref, classNames.filterRange);
            }

            sheet.forEachFilterHeader(this._currentView.ref, function(ref) {
                var rect = this._rectangle(ref);
                var position = this.filterIconRect(rect);
                var column = this._sheet.filterColumn(ref);
                var button = filterButton(classNames, position, column);

                children.push(button);
            }.bind(this));

            return kendo.dom.element("div", {
                className: classNames.filterHeadersWrapper
            }, children);

        },

        renderEditorSelection: function() {
            var classNames = Pane.classNames;
            var sheet = this._sheet;
            var selections = [];

            sheet._formulaSelections.forEach(function(range) {
                var ref = range.ref;

                if (ref === kendo.spreadsheet.NULLREF) {
                    return;
                }

                this._addDiv(selections, ref, classNames.selectionHighlight + " " + range.colorClass);
            }.bind(this));

            return kendo.dom.element("div", { className: classNames.selectionWrapper }, selections);

        },

        renderSelection: function(scroller) {
            var classNames = Pane.classNames;
            var selections = [];
            var selectionClasses = [classNames.selection];
            var sheet = this._sheet;
            var activeCell = sheet.activeCell().toRangeRef();
            var selection = sheet.select();

            selectionClasses = selectionClasses.concat(this._activeFormulaColor());

            if (selection.size() === 1) {
                selectionClasses.push("k-single-selection");
            }

            if (this._sheet.autoFillPunch()) {
                selectionClasses.push("k-dim-auto-fill-handle");
            }

            selection.forEach(function(ref) {
                if (ref !== kendo.spreadsheet.NULLREF) {
                    this._addDiv(selections, ref, selectionClasses.join(" "));
                }
            }.bind(this));

            this._renderCustomEditorButton(selections, activeCell, scroller);

            return kendo.dom.element("div", { className: classNames.selectionWrapper }, selections);
        },

        renderAutoFill: function() {
            var autoFillRectangle = [];

            if (this._sheet.autoFillInProgress()) {
                var autoFillRef = this._sheet.autoFillRef();
                var punch = this._sheet.autoFillPunch();
                var direction = this._sheet._autoFillDirection;

                this._addDiv(autoFillRectangle, autoFillRef, "k-auto-fill");

                if (punch) { // collapsing, add overlay
                    this._addDiv(autoFillRectangle, punch, "k-auto-fill-punch");
                } else if (direction !== undefined) { // expanding - add hint
                    var ref, cssClass;

                    switch(direction) {
                        case 0:
                            ref = autoFillRef.bottomRight;
                            cssClass = "k-auto-fill-br-hint";
                            break;
                        case 1:
                            ref = autoFillRef.bottomRight;
                            cssClass = "k-auto-fill-br-hint";
                            break;
                        case 2:
                            ref = new CellRef(autoFillRef.topLeft.row, autoFillRef.bottomRight.col);
                            cssClass = "k-auto-fill-tr-hint";
                            break;
                        case 3:
                            ref = new CellRef(autoFillRef.bottomRight.row, autoFillRef.topLeft.col);
                            cssClass = "k-auto-fill-bl-hint";
                            break;
                    }

                    var rectangle = this._addDiv(autoFillRectangle, ref, cssClass);
                    if (rectangle) {
                        var hint = kendo.dom.element("span", { className: "k-tooltip" }, [ kendo.dom.text(this._sheet._autoFillHint) ]);
                        rectangle.children.push(hint);
                    }
                }
            }

            return kendo.dom.element("div", { className: Pane.classNames.autoFillWrapper }, autoFillRectangle);
        },

        _addDiv: function(collection, ref, className) {
            var view = this._currentView, div;

            if (view.ref.intersects(ref)) {
                div = this._rectangle(ref).resize(1, 1).toDiv(className);
                collection.push(div);
            }
            return div;
        },

        _renderCustomEditorButton: function(collection, ref, scroller) {
            var self = this;
            var sheet = self._sheet;
            var view = self._currentView;
            var columnCount = self._grid.columns._axis._count;
            var ed = sheet.activeCellCustomEditor();

            if (ed && view.ref.intersects(ref)) {
                var rectangle = self._rectangle(ref);
                sheet.forEach(ref.collapse(), function(row, col, cell) {
                    cell.left = rectangle.left;
                    cell.top = rectangle.top;
                    cell.width = rectangle.width;
                    cell.height = rectangle.height;

                    var btnClass = "k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-spreadsheet-editor-button";
                    var isLastColumn = col == columnCount - 1 || self._buttonOutOfVisiblePane(row, col, scroller);
                    if (isLastColumn) {
                        btnClass += " k-spreadsheet-last-column";
                    }
                    self._editorInLastColumn = isLastColumn;
                    var btn = kendo.dom.element("div", {
                        className: btnClass,
                        style: {
                            left   : (cell.left + (isLastColumn ? 0 : cell.width)) + "px",
                            top    : cell.top + "px",
                            height : cell.height + "px"
                        }
                    });
                    if (ed.icon) {
                        btn.children.push(kendo.dom.element("span", {
                            className: "k-icon " + ed.icon
                        }));
                    }
                    collection.push(btn);
                });
            }
        },

        _activeFormulaColor: function() {
            var activeFormulaSelection;
            var colorClasses = [];

            if (this._sheet.isInEditMode()) {
                activeFormulaSelection = this._sheet._formulaSelections.filter(function(sel) { return sel.active && sel.type == "ref"; })[0];

                if (activeFormulaSelection) {
                    colorClasses.push(activeFormulaSelection.colorClass);
                }
            }

            return colorClasses;
        },

        _directionClasses: function(cell) {
            var cellClasses = [];
            var classNames = Pane.classNames;
            var view = this._currentView.ref;

            if (!cell.move(0, -1).intersects(view)) {
                cellClasses.push(classNames.left);
            }

            if (!cell.move(-1, 0).intersects(view)) {
                cellClasses.push(classNames.top);
            }

            if (!cell.move(0, 1).intersects(view)) {
                cellClasses.push(classNames.right);
            }

            if (!cell.move(1, 0).intersects(view)) {
                cellClasses.push(classNames.bottom);
            }

            return cellClasses;
        },

        _rectangle: function(ref) {
            return this._grid.boundingRectangle(ref.toRangeRef()).offset(-this._currentView.mergedCellLeft, -this._currentView.mergedCellTop);
        },

        _buttonOutOfVisiblePane: function(row, col, scroller) {
            var self = this;
            var theGrid = self._grid;
            var sheet = self._sheet;
            var ref = sheet.range(row, col)._ref;
            var boundaries = theGrid.scrollBoundaries(ref);
            var scrollLeft = theGrid.columns.frozen ? 0 : scroller.scrollLeft;

            if (boundaries.right + EDIT_BUTTON_WIDTH > scrollLeft || col + 1 === sheet.frozenColumns()) {
                return true;
            }
        }
    });

    function drawingResizeHandles(container) {
        [ "N", "NE", "E", "SE", "S", "SW", "W", "NW" ].forEach(function(direction) {
            container.push(kendo.dom.element("div", {
                "className": "k-spreadsheet-drawing-handle " + direction,
                "data-direction": direction
            }));
        });
    }

    kendo.spreadsheet.View = View;
    kendo.spreadsheet.Pane = Pane;
    kendo.spreadsheet.drawCell = drawCell;

    $.extend(true, View, { classNames: viewClassNames });
    $.extend(true, Pane, { classNames: paneClassNames });

})(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/customeditors',[ "../kendo.core", "../kendo.popup", "../kendo.calendar", "../kendo.listview", "./sheet" ], f);
})(function(){

(function(kendo) {

    "use strict";

    // jshint eqnull:true

    var $ = kendo.jQuery;

    var EDITORS = {};

    var registerEditor = kendo.spreadsheet.registerEditor = function(name, editor) {
        EDITORS[name] = editor;
    };

    kendo.spreadsheet.Sheet.prototype.activeCellCustomEditor = function() {
        var cell = this.activeCell().first();

        if (this.range(cell).enable()) {
            var val = this.validation(cell);
            var key = this._properties.get("editor", this._grid.cellRefIndex(cell));
            var editor;

            if (key != null) {
                editor = EDITORS[key];
            }
            else if (val && val.showButton) {
                key = "_validation_" + val.dataType;
                editor = EDITORS[key];
            }

            if (typeof editor == "function") {
                editor = EDITORS[key] = editor();
            }

            return editor;
        }
    };

    registerEditor("_validation_date", function(){
        var context, calendar, popup;

        function create() {
            if (!calendar) {
                calendar = $("<div>").kendoCalendar();
                popup = $("<div>").kendoPopup();
                calendar.appendTo(popup);
                calendar = calendar.getKendoCalendar();
                popup = popup.getKendoPopup();

                calendar.bind("change", function(){
                    popup.close();
                    var date = calendar.value();
                    if (!context.range.format()) {
                        context.range.format("yyyy-mm-dd");
                    }
                    context.callback(kendo.spreadsheet.dateToNumber(date));
                });
            }
            popup.setOptions({
                anchor: context.view.element.find(".k-spreadsheet-editor-button")
            });
        }

        function open() {
            create();

            var date = context.range.value();
            var sheet = context.range.sheet();
            if (date != null) {
                calendar.value(kendo.spreadsheet.numberToDate(date));
            } else {
                calendar.value(null);
            }
            var val = context.validation;
            if (val) {
                var min = kendo.ui.Calendar.fn.options.min;
                var max = kendo.ui.Calendar.fn.options.max;
                var fromValidation = val.from;
                var toValidation = val.to;
                var formula = kendo.spreadsheet.calc.runtime.Formula;

                if (/^(?:greaterThan|between)/.test(val.comparerType)) {
                    if(fromValidation instanceof formula && _rowAndColPresent(fromValidation.value)) {
                        min = kendo.spreadsheet.numberToDate(sheet.range(fromValidation.value.row, fromValidation.value.col).value());
                    } else {
                        min = kendo.spreadsheet.numberToDate(fromValidation.value);
                    }
                }
                if (val.comparerType == "between") {
                    if(toValidation instanceof formula && _rowAndColPresent(toValidation.value)) {
                        max = kendo.spreadsheet.numberToDate(sheet.range(toValidation.value.row, toValidation.value.col).value());
                    } else {
                        max = kendo.spreadsheet.numberToDate(val.to.value);
                    }
                }
                if (val.comparerType == "lessThan" || val.comparerType == "lessThanOrEqualTo") {
                    if(fromValidation instanceof formula && _rowAndColPresent(fromValidation.value)) {
                        max = kendo.spreadsheet.numberToDate(sheet.range(fromValidation.value.row, fromValidation.value.col).value());
                    } else {
                        max = kendo.spreadsheet.numberToDate(val.from.value);
                    }
                }
                calendar.setOptions({
                    disableDates: function(date) {
                        var from, to;

                        if(fromValidation && fromValidation instanceof formula && _rowAndColPresent(fromValidation.value)) {
                            from = sheet.range(fromValidation.value.row, fromValidation.value.col).value();
                        } else {
                            from = fromValidation ? fromValidation.value|0 : 0;
                        }

                        if(toValidation && toValidation instanceof formula && _rowAndColPresent(toValidation.value)) {
                            to = sheet.range(toValidation.value.row, toValidation.value.col).value();
                        } else {
                            to = toValidation ? toValidation.value|0 : 0;
                        }

                        date = kendo.spreadsheet.dateToNumber(date) | 0;
                        return !kendo.spreadsheet.validation
                            .validationComparers[val.comparerType](date, from, to);
                    },
                    min: min,
                    max: max
                });
            } else {
                calendar.setOptions({ disableDates: null, min: null, max: null });
            }
            popup.open();
        }

        function _rowAndColPresent(value) {
            return (value && value.row !== null && value.col !== null && value.row > -1 && value.col > -1);
        }

        return {
            edit: function(options) {
                context = options;
                open();
            },
            icon: "k-i-calendar"
        };
    });

    registerEditor("_validation_list", function(){
        var context, list, popup;
        function create() {
            if (!list) {
                list = $("<ul class='k-list k-reset'/>").kendoStaticList({
                    template   : "#:value#",
                    selectable : true,
                    autoBind   : false
                });
                popup = $("<div class='k-spreadsheet-list-popup'>").kendoPopup();
                list.appendTo(popup);
                popup = popup.getKendoPopup();
                list = list.getKendoStaticList();

                list.bind("change", function(){
                    popup.close();
                    var item = list.value()[0];
                    if (item) {
                        context.callback(item.value);
                    }
                });
            }
            popup.setOptions({
                anchor: context.view.element.find(".k-spreadsheet-editor-button")
            });
        }
        function open() {
            create();
            var items = context.validation.from.value;
            var data = [], add = function(el){ data.push({ value: el }); };
            if (items instanceof kendo.spreadsheet.calc.runtime.Matrix) {
                items.each(add);
            } else {
                // actually Excel expects a simple string for list
                // validation (comma-separated labels).
                (items+"").split(/\s*,\s*/).forEach(add);
            }
            var dataSource = new kendo.data.DataSource({ data: data });
            list.setDataSource(dataSource);
            dataSource.read();
            popup.open();
        }
        return {
            edit: function(options) {
                context = options;
                open();
            },
            icon: "k-i-arrow-60-down"
        };
    });

})(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/grid',[ "../kendo.core", "./references" ], f);
})(function(){

(function(kendo) {

    // jshint laxbreak: true

    var CellRef = kendo.spreadsheet.CellRef;
    var RangeRef = kendo.spreadsheet.RangeRef;
    var UnionRef = kendo.spreadsheet.UnionRef;

    var Rectangle = kendo.Class.extend({
        init: function Rectangle(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
            this.right = this.left + this.width;
            this.bottom = this.top + this.height;
        },

        offset: function(left, top) {
            return new Rectangle(this.left + left, this.top + top, this.width, this.height);
        },

        resize: function(width, height) {
            return new Rectangle(this.left, this.top, this.width + width, this.height + height);
        },

        intersects: function(x, y) {
            if (x instanceof Rectangle) {
                return this.intersectsRect(x);
            }
            return this.left < x && x < this.left + this.width &&
                   this.top < y && y < this.top + this.height;
        },

        intersectsRect: function(b) {
            var a = this;
            return a.left <= b.right
                && b.left <= a.right
                && a.top <= b.bottom
                && b.top <= a.bottom;
        },

        toDiv: function(className) {
            return kendo.dom.element("div", {
                className: className,
                style: {
                    width:  this.width + "px",
                    height: this.height + "px",
                    top:    this.top + "px",
                    left:   this.left + "px"
                }
            });
        }
    });

    // XXX: can we use ES5 yet? :-/
    //
    // Object.defineProperty(Rectangle.prototype, "right", {
    //     get() {
    //         return this.left + this.width;
    //     }
    // });
    // Object.defineProperty(Rectangle.prototype, "bottom", {
    //     get() {
    //         return this.top + this.height;
    //     }
    // });

    var Grid = kendo.Class.extend({
        init: function(rows, columns, rowCount, columnCount, headerHeight, headerWidth) {
            this.rowCount = rowCount;
            this.columnCount = columnCount;
            this._columns = columns;
            this._rows = rows;
            this._headerHeight = headerHeight;
            this._headerWidth = headerWidth;
        },

        _resize: function(new_rows, new_cols) {
            this.rowCount = new_rows;
            this.columnCount = new_cols;
        },

        isAxis: function(ref) {
            ref = ref.toRangeRef();
            var topLeft = ref.topLeft;
            var bottomRight = ref.bottomRight;
            return (topLeft.row === 0 && bottomRight.row === this.rowCount - 1) || (topLeft.col === 0 && bottomRight.col === this.columnCount - 1);
        },

        width: function(start, end) {
            return this._columns.sum(start, end);
        },

        height: function(start, end) {
            return this._rows.sum(start, end);
        },

        totalHeight: function() {
            return this._rows.total + this._headerHeight;
        },

        totalWidth: function() {
            return this._columns.total + this._headerWidth;
        },

        index: function(row, column) {
            return column * this.rowCount + row;
        },

        cellRef: function(index) {
            return new CellRef(index % this.rowCount, (index / this.rowCount) >> 0);
        },

        rowRef: function(row) {
            return new RangeRef(new CellRef(row, 0), new CellRef(row, this.columnCount - 1));
        },

        colRef: function(col) {
            return new RangeRef(new CellRef(0, col), new CellRef(this.rowCount - 1, col));
        },

        cellRefIndex: function(ref) {
            return this.index(ref.row, ref.col);
        },

        normalize: function(ref) {
            if (ref instanceof RangeRef) {
                return new RangeRef(
                    this.normalize(ref.topLeft),
                    this.normalize(ref.bottomRight)
                ).setSheet(ref.sheet, ref.hasSheet());
            }

            if (ref instanceof UnionRef) {
                return ref.map(function(ref) {
                    return this.normalize(ref);
                }, this);
            }

            if (ref instanceof CellRef) {
                ref = ref.clone();
                ref.col = Math.max(0, Math.min(this.columnCount - 1, ref.col));
                ref.row = Math.max(0, Math.min(this.rowCount - 1, ref.row));
            }

            return ref;
        },

        rectangle: function(ref) {
            var topLeft = this.normalize(ref.topLeft);
            var bottomRight = this.normalize(ref.bottomRight);
            return new Rectangle(
                this.width(0, topLeft.col - 1),
                this.height(0, topLeft.row - 1),
                this.width(topLeft.col, bottomRight.col),
                this.height(topLeft.row, bottomRight.row)
            );
        },

        pane: function(options) {
            return new PaneGrid(
                new kendo.spreadsheet.PaneAxis(this._rows, options.row, options.rowCount, this._headerHeight),
                new kendo.spreadsheet.PaneAxis(this._columns, options.column, options.columnCount, this._headerWidth),
                this
            );
        },

        rangeDimensions: function(rangeRef) {
            return {
                rows: this._rows.values.iterator(rangeRef.topLeft.row, rangeRef.bottomRight.row),
                columns: this._columns.values.iterator(rangeRef.topLeft.col, rangeRef.bottomRight.col)
            };
        },

        forEach: function(ref, callback) {
            var topLeft = this.normalize(ref.topLeft);
            var bottomRight = this.normalize(ref.bottomRight);

            for (var ci = topLeft.col; ci <= bottomRight.col; ci ++) {
                for (var ri = topLeft.row; ri <= bottomRight.row; ri ++) {
                    callback(new CellRef(ri, ci));
                }
            }
        },

        trim: function(ref, property) {
            var topLeft = this.normalize(ref.topLeft);
            var bottomRight = this.normalize(ref.bottomRight);
            var bottomRightRow = topLeft.row;
            var bottomRightCol = topLeft.col;

            for (var ci = topLeft.col; ci <= bottomRight.col; ci ++) {
                var start = this.index(topLeft.row, ci);
                var end = this.index(bottomRight.row, ci);
                var values = property.tree.intersecting(start, end);
                if(values.length) {
                    var cell = this.cellRef(values[values.length - 1].end);
                    bottomRightRow = Math.max(bottomRightRow, cell.row);
                    bottomRightCol = ci;
                }
            }
            return new RangeRef(ref.topLeft, new CellRef(Math.min(bottomRightRow, ref.bottomRight.row), bottomRightCol));
        }
    });

    var PaneGrid = kendo.Class.extend({
        init: function(rows, columns, grid) {
            this.rows = rows;
            this.columns = columns;
            this._grid = grid;

            this.headerHeight = rows.headerSize;
            this.headerWidth = columns.headerSize;
            this.hasRowHeader = columns.hasHeader;
            this.hasColumnHeader = rows.hasHeader;
        },

        refresh: function(width, height) {
            this.columns.viewSize(width);
            this.rows.viewSize(height);

            var x = this.columns.paneSegment();
            var y = this.rows.paneSegment();

            this.left = x.offset;
            this.top = y.offset;
            this.right = x.offset + x.length;
            this.bottom = y.offset + y.length;

            this.style = {
                top: y.offset  + "px",
                left: x.offset + "px",
                height: y.length + "px",
                width: x.length + "px"
            };
        },

        view: function(left, top) {
            var rows = this.rows.visible(top);
            var columns = this.columns.visible(left);

            return {
                rows: rows,
                columns: columns,

                rowOffset: rows.offset,
                columnOffset: columns.offset,

                mergedCellLeft: columns.start,
                mergedCellTop: rows.start,

                ref: new RangeRef(
                    new CellRef(rows.values.start, columns.values.start),
                    new CellRef(rows.values.end, columns.values.end)
                )
            };
        },

        contains: function(ref) {
            return this.rows.contains(ref.topLeft.row, ref.bottomRight.row) &&
                this.columns.contains(ref.topLeft.col, ref.bottomRight.col);
        },

        index: function(row, column) {
            return this._grid.index(row, column);
        },

        boundingRectangle: function(ref) {
            return this._grid.rectangle(ref);
        },

        cellRefIndex: function(ref) {
            return this._grid.cellRefIndex(ref);
        },

        scrollBoundaries: function(cell) {
            var position = this.boundingRectangle(cell);

            var boundaries = {
                top: Math.max(0, position.top - this.top + (this.hasColumnHeader ? 0 : this.headerHeight)),
                left: Math.max(0, position.left - this.left + (this.hasRowHeader ? 0 : this.headerWidth)),
                right: position.right - this.columns._viewSize + this.headerWidth,
                bottom: position.bottom - this.rows._viewSize + this.headerHeight
            };

            var widthCompensation = this.columns.defaultValue / 2;
            var heightCompensation = this.rows.defaultValue / 2;

            boundaries.scrollTop = boundaries.top - heightCompensation;
            boundaries.scrollBottom = boundaries.bottom + heightCompensation;

            boundaries.scrollLeft = boundaries.left - widthCompensation;
            boundaries.scrollRight = boundaries.right + widthCompensation;
            return boundaries;
        }
    });

    kendo.spreadsheet.Grid = Grid;
    kendo.spreadsheet.PaneGrid = PaneGrid;
    kendo.spreadsheet.Rectangle = Rectangle;
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/axis',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var Axis = kendo.Class.extend({
        init: function(count, value) {
            this._value = value;
            this._count = count;
            this.values = new kendo.spreadsheet.RangeList(0, count - 1, value);
            this._hidden = new kendo.spreadsheet.RangeList(0, count - 1, 0);

            this.scrollBarSize = kendo.support.scrollbar();
            this._refresh();
        },

        _resize: function(count) {
            if (count > this._count) {
                this.values.value(this._count, count - 1, this._value);
                this._hidden.value(this._count, count - 1, 0);
            } else if (count < this._count) {
                this.values.value(count, this._count - 1, 0);
                this._hidden.value(count, this._count - 1, 0);
            }
            this._count = count;
            this._refresh();
        },

        adjust: function(start, delta) {
            // adjust this axis for insert/remove rows/cols operation
            if (delta < 0) {
                // removing -- copy from start+|delta| to start
                this.values.copy(start - delta, this._count - 1, start);
                this._hidden.copy(start - delta, this._count - 1, start);
            } else {
                // adding -- copy from start to start+delta, and set
                // values for inserted things to default.
                this.values.copy(start, this._count, start + delta);
                this._hidden.copy(start, this._count, start + delta);
                this.values.value(start, start + delta - 1, this._value);
                this._hidden.value(start, start + delta - 1, 0);
            }
            this._refresh();
        },

        toJSON: function(field, positions) {
            var values = [];

            var iterator = this.values.iterator(0, this._count - 1);

            for (var idx = 0; idx < this._count; idx++) {
                var value = iterator.at(idx);
                var hidden = this._hidden.value(idx, idx);

                if (value === this._value && !hidden) {
                    continue;
                }

                var position = positions[idx];

                if (position === undefined) {
                    position = values.length;

                    var item = { index: idx };

                    item[field] = value;
                    if (hidden) {
                        item.hidden = hidden;
                    }

                    values.push(item);

                    positions[idx] = position;
                }
            }

            return values;
        },

        fromJSON: function(field, values) {
            for (var idx = 0; idx < values.length; idx++) {
                var el = values[idx];

                var index = el.index;
                if (index === undefined) {
                    index = idx;
                }

                // when this particular axis is hidden, the value for
                // the field ("height" or "width") will be zero, and
                // in the "hidden" field we'll have the actual value
                // before it was hidden.
                // https://github.com/telerik/kendo-ui-core/issues/3523
                var value = el[field];

                if (value === 0) {
                    this._hidden.value(index, index, el.hidden || this._value);
                    this.value(index, index, 0);
                } else {
                    this.value(index, index, value);
                }
            }
        },

        hide: function(index) {
            if (!this.hidden(index)) {
                var value = this.value(index, index);
                this._hidden.value(index, index, value);
                this.value(index, index, 0);
            }
        },

        hidden: function(index) {
            return this._hidden.value(index, index) !== 0;
        },

        includesHidden: function(start, end) {
             return this._hidden.intersecting(start, end).length > 1;
        },

        nextVisible: function(index) {
            var end = this._count - 1, i = index;
            while (++i <= end) {
                if (!this.hidden(i)) {
                    return i;
                }
            }
            return index;
        },

        nextUntil: function(index, pred) {
            var end = this._count - 1, i = index, advanced = false;
            while (++i <= end) {
                var val = pred(i, advanced, this.hidden(i));
                if (typeof val == "number") {
                    return val;
                } else if (val) {
                    break;
                }
                advanced = true;
            }
            return i - 1;
        },

        nextPage: function(index, pageSize) {
            return this.index(this.sum(0, index - 1) + pageSize);
        },

        prevPage: function(index, pageSize) {
            return this.index(this.sum(0, index) - pageSize);
        },

        firstVisible: function() {
            var firstHidden = this._hidden.first();
            if (firstHidden.value === 0) {
                return 0;
            } else {
                return firstHidden.end + 1;
            }
        },

        lastVisible: function() {
            var lastHidden = this._hidden.last();
            if (lastHidden.value === 0) {
                return this._count - 1;
            } else {
                return lastHidden.start - 1;
            }
        },

        prevVisible: function(index) {
            var i = index;
            while (--i >= 0) {
                if (!this.hidden(i)) {
                    return i;
                }
            }
            return index;
        },

        prevUntil: function(index, pred) {
            var i = index, advanced = false;
            while (--i >= 0) {
                var val = pred(i, advanced, this.hidden(i));
                if (typeof val == "number") {
                    return val;
                } else if (val) {
                    break;
                }
                advanced = true;
            }
            return i + 1;
        },

        unhide: function(index) {
            if (this.hidden(index)) {
                var value = this._hidden.value(index, index);
                this._hidden.value(index, index, 0);
                this.value(index, index, value);
            }
        },

        value: function(start, end, value) {
            if (value !== undefined) {
                this.values.value(start, end, value);
                this._refresh();
            } else {
                return this.values.iterator(start, end).at(0);
            }
        },

        sum: function(start, end) {
            var values = this.values.iterator(start, end);

            var sum = 0;

            for (var idx = start; idx <= end; idx ++) {
                sum += values.at(idx);
            }

            return sum;
        },

        locate: function(start, end, predicate) {
            var values = this.values.iterator(start, end);
            var sum = 0;
            for (var idx = start; idx <= end; idx++) {
                sum += values.at(idx);
                var val = predicate(sum);
                if (val) {
                    return idx;
                }
            }
            return null;
        },

        visible: function(start, end) {
            var startSegment = null;
            var endSegment = null;
            var lastPage = false;

            if (end >= this.total + this.scrollBarSize) {
                lastPage = true;
            }

            var ranges = this._pixelValues.intersecting(start, end);

            startSegment = ranges[0];
            endSegment = ranges[ranges.length - 1];

            if (!startSegment) {
                return { values: this.values.iterator(0, 0), offset: 0 };
            }

            var startOffset = start - startSegment.start;

            var startIndex = ((startOffset / startSegment.value.value) >> 0) + startSegment.value.start;

            var offset = startOffset - (startIndex - startSegment.value.start) * startSegment.value.value;

            var endOffset = end - endSegment.start;
            var endIndex = ((endOffset / endSegment.value.value) >> 0) + endSegment.value.start;

            if (endIndex > endSegment.value.end) {
                endIndex = endSegment.value.end;
            }

            if (lastPage) {
                offset += endSegment.value.value - (endOffset - (endIndex - endSegment.value.start) * endSegment.value.value);
            }

            offset = Math.min(-offset, 0);

            return {
                values: this.values.iterator(startIndex, endIndex),
                offset: offset
            };
        },

        index: function(value) {
            var index = 0;
            var iterator = this.values.iterator(0, this._count - 1);
            var current = iterator.at(0);

            while (current < value && index < this._count - 1) {
                current += iterator.at(++index);
            }

            return index;
        },

        indexVisible: function(value) {
            var index = this.index(value);
            if (this.hidden(index)) {
                index = this.prevVisible(index);
            }
            return index;
        },

        _refresh: function() {
            var current = 0;
            this._pixelValues = this.values.map(function(range) {
                var start = current;
                current += (range.end - range.start + 1) * range.value;
                var end = current - 1;
                return new kendo.spreadsheet.ValueRange(start, end, range);
            });
            this.total = current;
        },

        getState: function() {
            return {
                values: this.values.getState(),
                hidden: this._hidden.getState(),
                count: this._count
            };
        },

        setState: function(state) {
            this.values.setState(state.values);
            this._hidden.setState(state.hidden);
            var nowCount = this._count;
            if (nowCount > state.count) {
                this._count = state.count;
                this._resize(nowCount); // calls _refresh too
            } else {
                this._refresh();
            }
        }
    });

    var PaneAxis = kendo.Class.extend({
        init: function(axis, start, count, headerSize) {
           this._axis = axis;
           this._start = start;
           this._count = count;
           this.hasHeader = start === 0;
           this.headerSize = headerSize;
           this.defaultValue = axis._value;
           this.frozen = count > 0;
        },

        viewSize: function(viewSize) {
            this._viewSize = viewSize;
        },

        sum: function(start, end) {
            return this._axis.sum(start, end - 1);
        },

        start: function() {
            return this.sum(0, this._start);
        },

        size: function() {
            return this.sum(this._start, this._start + this._count);
        },

        index: function(value, offset) {
            return this._axis.index(value + (this.frozen ? 0 : offset) - this.headerSize);
        },

        indexVisible: function(value, offset) {
            return this._axis.indexVisible(value + (this.frozen ? 0 : offset) - this.headerSize);
        },

        //XXX: rename this method
        paneSegment: function() {
            var offset = this.start();
            var length;

            if (!this.hasHeader) {
                offset += this.headerSize;
            }

            if (this.frozen) {
                length = this.size();
                if (this.hasHeader) {
                    length += this.headerSize;
                } else {
                    length -= this.headerSize;
                }
            } else {
                length = this._viewSize - offset;
            }

            return {
                offset: offset,
                length: length
            };
        },

        visible: function(offset) {
            var start = this.start();
            var size;

            if (this.frozen) {
                size = this.size();
                if (!this.hasHeader) {
                    size -= this.headerSize;
                }
            } else {
                size = this._viewSize - start - this.headerSize;
                start += offset;
            }

            var result = this._axis.visible(start, start + size - 1);

            if (this.frozen) {
                result.offset = 0;
            }

            result.start = start;

            if (this.hasHeader) {
                result.offset += this.headerSize;
                result.start -= this.headerSize;
            }

            return result;
        },

        contains: function(start, end) {
            if (this.frozen) {
                if (start > this._start + this._count) {
                    return false;
                }
                if (end < this._start) {
                    return false;
                }
                return true;
            } else {
                return end >= this._start;
            }
        }
    });

    kendo.spreadsheet.Axis = Axis;
    kendo.spreadsheet.PaneAxis = PaneAxis;

})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/filter',[ "../kendo.core", "../kendo.data" ], f);
})(function(){
(function(kendo) {

    /*jshint evil: true */
    var Filter = kendo.spreadsheet.Filter = kendo.Class.extend({
        prepare: function() {
        },
        value: function(cell) {
            return cell.value;
        },
        matches: function() {
            throw new Error("The 'matches' method is not implemented.");
        },
        toJSON: function() {
            throw new Error("The 'toJSON' method is not implemented.");
        }
    });

    Filter.create = function(options) {
        var filter = options.filter;

        if (!filter) {
            throw new Error("Filter type not specified.");
        }

        var constructor = kendo.spreadsheet[filter.charAt(0).toUpperCase() + filter.substring(1) + "Filter"];

        if (!constructor) {
            throw new Error("Filter type not recognized.");
        }

        return new constructor(options);
    };

    kendo.spreadsheet.ValueFilter = Filter.extend({
        _values: [],

        _dates: [],

        _blanks: false,

        init: function ValueFilter(options) {
            if (options.values !== undefined) {
                this._values = options.values;
            }

            if (options.blanks !== undefined) {
                this._blanks = options.blanks;
            }

            if (options.dates !== undefined) {
                this._dates = options.dates;
            }
        },

        value: function(cell) {
            var value = cell.value;

            if (this._dates.length > 0 && cell.format && typeof value === "number") {
                var type = kendo.spreadsheet.formatting.type(value, cell.format);

                if (type === "date") {
                    value = kendo.spreadsheet.numberToDate(value);
                }
            }

            return value;
        },

        matches: function(value) {
            if (value === null || value === undefined) {
                return this._blanks;
            }

            if (value instanceof Date) {
                return this._dates.some(function(date) {
                    return date.year === value.getFullYear() &&
                        (date.month === undefined || date.month === value.getMonth()) &&
                        (date.day === undefined || date.day === value.getDate()) &&
                        (date.hours === undefined || date.hours === value.getHours()) &&
                        (date.minutes === undefined || date.minutes === value.getMinutes()) &&
                        (date.seconds === undefined || date.seconds === value.getSeconds());
                });
            }

            return this._values.indexOf(value) >= 0;
        },
        toJSON: function() {
            return {
                filter: "value",
                blanks: this._blanks,
                values: this._values.slice(0)
            };
        }
    });

    kendo.spreadsheet.CustomFilter = Filter.extend({
        _logic: "and",
        init: function CustomFilter(options) {
            if (options.logic !== undefined) {
                this._logic = options.logic;
            }

            if (options.criteria === undefined) {
                throw new Error("Must specify criteria.");
            }

            this._criteria = options.criteria;

            var expression = kendo.data.Query.filterExpr({
                logic: this._logic,
                filters: this._criteria,
                accentFoldingFiltering: kendo.culture().name
            }).expression;

            this._matches = new Function("d", "return " + expression);
        },
        matches: function(value) {
            if (value === null) {
                return false;
            }

            return this._matches(value);
        },
        value: function(cell) {
            var value = cell.value;
            var criterionValue = this._criteria[0].value;
            var criterionType = criterionValue instanceof Date ? "date" : typeof criterionValue;
            var valueType = typeof value;

            if (cell.format) {
                valueType = kendo.spreadsheet.formatting.type(value, cell.format);
            }

            if (valueType != criterionType) {
                if (criterionType == "string") {
                    if (cell.format) {
                        value = kendo.spreadsheet.formatting.text(value, cell.format);
                    }
                    value = value + "";
                }
            } else if (valueType == "date") {
                value = kendo.spreadsheet.numberToDate(value);
            }

            return value;
        },
        toJSON: function() {
            return {
                filter: "custom",
                logic: this._logic,
                criteria: this._criteria
            };
        }
    });

    kendo.spreadsheet.TopFilter = Filter.extend({
        init: function TopFilter(options) {
            this._type = options.type;
            this._value = options.value;
            this._values = [];
        },

        prepare: function(cells) {
            var values = cells.map(this.value)
            .sort()
            .filter(function(value, index, array) {
                return index === 0 || value !== array[index - 1];
            });

            if (this._type === "topNumber" || this._type == "topPercent") {
                values.sort(function(x, y) {
                    return y - x;
                });
            } else {
                values.sort(function(x, y) {
                    return x - y;
                });
            }

            var count = this._value;

            if (this._type === "topPercent" || this._type === "bottomPercent") {
                count = (values.length * count / 100) >> 0;
            }

            this._values = values.slice(0, count);
        },
        matches: function(value) {
            return this._values.indexOf(value) >= 0;
        },
        toJSON: function() {
            return {
                filter: "top",
                type: this._type,
                value: this._value
            };
        }
    });

    kendo.spreadsheet.DynamicFilter = Filter.extend({
        init: function DynamicFilter(options) {
            this._type = options.type;

            this._predicate = this[options.type];

            if (typeof this._predicate !== "function") {
                throw new Error("DynamicFilter type '" + options.type + "' not recognized.");
            }
        },
        value: function(cell) {
            var value = cell.value;

            if (cell.format) {
                var type = kendo.spreadsheet.formatting.type(value, cell.format);

                if (type === "date") {
                    value = kendo.spreadsheet.numberToDate(value);
                }
            }

            return value;
        },
        prepare: function(cells) {
            var sum = 0;
            var count = 0;

            for (var ci = 0; ci < cells.length; ci++) {
                var value = this.value(cells[ci]);

                if (typeof value === "number") {
                    sum += value;
                    count ++;
                }
            }

            if (count > 0) {
                this._average = sum / count;
            } else {
                this._average = 0;
            }
        },
        matches: function(value) {
            return this._predicate(value);
        },
        aboveAverage: function(value) {
            if (value instanceof Date) {
                value = kendo.spreadsheet.dateToNumber(value);
            }

            if (typeof value !== "number") {
                return false;
            }

            return value > this._average;
        },
        belowAverage: function(value) {
            if (value instanceof Date) {
                value = kendo.spreadsheet.dateToNumber(value);
            }

            if (typeof value !== "number") {
                return false;
            }

            return value < this._average;
        },
        tomorrow: function(value) {
            if (value instanceof Date) {
                var tomorrow = kendo.date.addDays(kendo.date.today(), 1);

                return kendo.date.getDate(value).getTime() === tomorrow.getTime();
            }

            return false;
        },
        today: function(value) {
            if (value instanceof Date) {
                return kendo.date.isToday(value);
            }

            return false;
        },
        yesterday: function(value) {
            if (value instanceof Date) {
                var yesterday = kendo.date.addDays(kendo.date.today(), -1);

                return kendo.date.getDate(value).getTime() === yesterday.getTime();
            }

            return false;
        },
        nextWeek: function(value) {
            return sameWeek(kendo.date.addDays(kendo.date.today(), 7), value);
        },
        thisWeek: function(value) {
            return sameWeek(kendo.date.today(), value);
        },
        lastWeek: function(value) {
            return sameWeek(kendo.date.addDays(kendo.date.today(), -7), value);
        },
        nextMonth: function(value) {
            return sameMonth(value, 1);
        },
        thisMonth: function(value) {
            return sameMonth(value, 0);
        },
        lastMonth: function(value) {
            return sameMonth(value, -1);
        },
        nextQuarter: function(value) {
            if (value instanceof Date) {
                var today = kendo.date.today();

                var diff = quarter(value) - quarter(today);

                return (diff === 1 && today.getFullYear() === value.getFullYear()) ||
                       (diff == -3 && today.getFullYear() + 1 === value.getFullYear());
            }

            return false;
        },
        thisQuarter: function(value) {
            if (value instanceof Date) {
                var today = kendo.date.today();

                var diff = quarter(value) - quarter(today);

                return diff === 0 && today.getFullYear() === value.getFullYear();
            }

            return false;
        },
        lastQuarter: function(value) {
            if (value instanceof Date) {
                var today = kendo.date.today();

                var diff = quarter(today) - quarter(value);

                return (diff === 1 && today.getFullYear() === value.getFullYear()) ||
                       (diff == -3 && today.getFullYear() - 1 === value.getFullYear());
            }

            return false;
        },
        nextYear: function(value) {
            return sameYear(value, 1);
        },
        thisYear: function(value) {
            return sameYear(value, 0);
        },
        lastYear: function(value) {
            return sameYear(value, -1);
        },
        yearToDate: function(value) {
            if (value instanceof Date) {
                var today = kendo.date.today();

                return value.getFullYear() === today.getFullYear() && value <= today;
            }

            return false;
        },
        toJSON: function() {
            return {
                filter: "dynamic",
                type: this._type
            };
        }
    });

    [1, 2, 3, 4].forEach(function(target) {
        kendo.spreadsheet.DynamicFilter.prototype["quarter" + target] = function(value) {
           if (value instanceof Date) {
              return quarter(value) === target;
           }

           return false;
        };
    });

    kendo.cultures["en-US"].calendar.months.names.forEach(function(month, index) {
        kendo.spreadsheet.DynamicFilter.prototype[month.toLowerCase()] = function(value) {
           if (value instanceof Date) {
               return value.getMonth() === index;
           }

           return false;
        };
    });

    function quarter(value) {
        var month = value.getMonth() + 1;

        if (month >= 1 && month <= 3) {
            return 1;
        } else if(month >= 4 && month <= 6) {
            return 2;
        } else if (month >= 7 && month <= 9) {
            return 3;
        } else {
            return 4;
        }
    }

    function sameYear(value, offset) {
        if (value instanceof Date) {
            var today = kendo.date.today();

            today.setFullYear(today.getFullYear() + offset);

            return today.getFullYear() === value.getFullYear();
        }

        return false;
    }

    function sameMonth(value, offset) {
        if (value instanceof Date) {
            var today = kendo.date.firstDayOfMonth(kendo.date.today());

            today.setMonth(today.getMonth() + offset, 1);

            return today.getTime() === kendo.date.firstDayOfMonth(value).getTime();
        }

        return false;
    }

    function sameWeek(a, b) {
        if (b instanceof Date) {
            var firstWeek = kendo.date.dayOfWeek(kendo.date.getDate(a), 1);

            var secondWeek = kendo.date.dayOfWeek(kendo.date.getDate(b), 1);

            return firstWeek.getTime() === secondWeek.getTime();
        }

        return false;
    }

})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/sorter',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var Sorter = kendo.Class.extend({
        init: function(grid, lists) {
            this._grid = grid;
            this._lists = lists;
        },

        indices: function(rangeRef, list, ascending, indices) {
            var comparer = Sorter.ascendingComparer;

            if (ascending === false) {
                comparer = Sorter.descendingComparer;
            }

            return list.sortedIndices(this._grid.cellRefIndex(rangeRef.topLeft),
                this._grid.cellRefIndex(rangeRef.bottomRight), comparer, indices);
        },

        sortBy: function(ref, column, list, ascending, indices) {
            var sortedIndices = this.indices(ref.toColumn(column), list, ascending, indices);

            for (var ci = ref.topLeft.col; ci <= ref.bottomRight.col; ci++) {
                var start = this._grid.index(ref.topLeft.row, ci);
                var end = this._grid.index(ref.bottomRight.row, ci);

                for (var li = 0; li < this._lists.length; li++) {
                    if (start < this._lists[li].lastRangeStart()) {
                        this._lists[li].sort(start, end, sortedIndices);
                    }
                }
            }

            return sortedIndices;
        }
    });

    Sorter.ascendingComparer = function(a, b) {
        if (a === null && b === null) {
            return 0;
        }

        if (a === null) {
            return 1;
        }

        if (b === null) {
            return -1;
        }

        var typeA = typeof a;
        var typeB = typeof b;

        if (typeA === "number") {
            if (typeB === "number") {
                return a - b;
            } else {
               return -1;
            }
        }

        if (typeA === "string") {
            switch (typeB) {
                case "number":
                    return 1;
                case "string":
                    return a.localeCompare(b);
                default:
                    return -1;
            }
        }

        if (typeA === "boolean") {
            switch (typeB) {
                case "number":
                    return 1;
                case "string":
                    return 1;
                case "boolean":
                    return a - b;
                default:
                    return -1;
            }
        }

        if (a instanceof kendo.spreadsheet.calc.runtime.CalcError) {
            if (b instanceof kendo.spreadsheet.calc.runtime.CalcError) {
                return 0;
            } else {
                return 1;
            }
        }

        throw new Error("Cannot compare " + a + " and " + b);
    };

    Sorter.descendingComparer = function(a, b) {
        if (a === null && b === null) {
            return 0;
        }

        if (a === null) {
            return 1;
        }

        if (b === null) {
            return -1;
        }

        return Sorter.ascendingComparer(b, a);
    };

    kendo.spreadsheet.Sorter = Sorter;
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

// -*- fill-column: 100 -*-

(function(f, define){
    define('spreadsheet/numformat',[ "./calc", "../kendo.dom", "../util/main" ], f);
})(function(){
    "use strict";

    // WARNING: removing the following jshint declaration and turning
    // == into === to make JSHint happy will break functionality.
    /* jshint eqnull:true, newcap:false, laxbreak:true, shadow:true, -W054 */
    /* jshint latedef: nofunc */

    var util = kendo.util;
    var calc = kendo.spreadsheet.calc;
    var dom = kendo.dom;

    var RX_COLORS = /^\[(black|green|white|blue|magenta|yellow|cyan|red)\]/i;
    var RX_CONDITION = /^\[(<=|>=|<>|<|>|=)(-?[0-9.]+)\]/;

    /* The proper amount of suffering for whoever designed the Excel
       Custom Number Format would be to have him implement the
       formatter himself. */

    function parse(input) {
        input = calc.InputStream(input);
        var sections = [], haveConditional = false, decimalPart;

        while (!input.eof()) {
            var sec = readSection();
            sections.push(sec);
            if (sec.cond) {
                haveConditional = true;
            }
        }

        // From https://support.office.com/en-us/article/Create-or-delete-a-custom-number-format-78f2a361-936b-4c03-8772-09fab54be7f4:
        //
        //    A number format can have up to four sections of code, separated by semicolons. These
        //    code sections define the format for positive numbers, negative numbers, zero values,
        //    and text, in that order.
        //
        //    You do not have to include all code sections in your custom number format. If you
        //    specify only two code sections for your custom number format, the first section is
        //    used for positive numbers and zeros, and the second section is used for negative
        //    numbers. If you specify only one code section, it is used for all numbers. If you want
        //    to skip a code section and include a code section that follows it, you must include
        //    the ending semicolon for the section that you skip.
        //
        // However, if sections have conditionals, it is not clear if:
        //
        //    - still at most four are allowed
        //    - is the last section still for text
        //
        // We will assume that if no sections have conditionals, then there must be at most 4, and
        // they will be interpreted in the order above.  If the first section contains a
        // conditional, then there can be any number of them; if the last one is not conditional
        // then it will be interpreted as text format.

        if (!haveConditional) {
            if (sections.length == 1) {
                sections[0].cond = "num";
            }
            else if (sections.length == 2) {
                sections[0].cond = { op: ">=", value: 0 };
                sections[1].cond = { op: "<", value: 0 };
            }
            else if (sections.length >= 3) {
                sections[0].cond = { op: ">", value: 0 };
                sections[1].cond = { op: "<", value: 0 };
                sections[2].cond = { op: "=", value: 0 };
                if (sections.length > 3) {
                    sections[3].cond = "text";
                    sections = sections.slice(0, 4);
                }
            }
        }

        return sections;

        function maybeColor() {
            var m = input.skip(RX_COLORS);
            if (m) {
                return m[1].toLowerCase();
            }
        }

        function maybeCondition() {
            var m = input.skip(RX_CONDITION);
            if (m) {
                var val = parseFloat(m[2]);
                if (!isNaN(val)) {
                    return { op: m[1], value: val, custom: true };
                }
            }
        }

        function readFormat() {
            var format = [], tok, prev = null;
            while (!input.eof() && (tok = readNext())) {
                // disambiguate: m/mm might mean month or minutes depending on surrounding context.
                if (tok.type == "date") {
                    if (prev && /^(el)?time$/.test(prev.type) && prev.part == "h"
                        && tok.part == "m" && tok.format < 3) {
                        // m or mm that follows hours should display minutes
                        tok.type = "time";
                    }
                } else if (/^(el)?time$/.test(tok.type) && tok.part == "s") {
                    if (prev && prev.type == "date" && prev.part == "m"
                        && prev.format < 3) {
                        // m or mm followed by seconds should display minutes
                        prev.type = "time";
                    }
                }
                if (!(/^(?:str|space|fill)$/.test(tok.type))) {
                    prev = tok;
                }
                format.push(tok);
            }
            return format;
        }

        function maybeFraction(tok) {
            if (tok.type != "date" || (tok.part == "m" && tok.format < 3)) {
                var m = input.skip(/^\.(0+)/);
                if (m) {
                    tok.fraction = m[1].length;
                    if (tok.type == "date") {
                        tok.type = "time";
                    }
                }
            }
            return tok;
        }

        function readNext() {
            var ch, m;
            // numbers
            if ((m = input.skip(/^([#0?]+)(?:,([#0?]+))+/))) {
                // thousands separator.  seems convenient to treat
                // this as a single token.
                return { type: "digit", sep: true, format: m[1] + m[2], decimal: decimalPart };
            }
            if ((m = input.skip(/^[#0?]+/))) {
                return { type: "digit", sep: false, format: m[0], decimal: decimalPart };
            }
            // XXX: handle this one!
            if ((m = input.skip(/^(e)([+-])/i))) {
                return { type: "exp", ch: m[1], sign: m[2] };
            }
            // dates
            if ((m = input.skip(/^(d{1,4}|m{1,5}|yyyy|yy)/i))) {
                m = m[1].toLowerCase();
                return maybeFraction({ type: "date", part: m.charAt(0), format: m.length });
            }
            // time (interpret as a date)
            if ((m = input.skip(/^(hh?|ss?)/i))) { // m and mm are handled above
                m = m[1].toLowerCase();
                return maybeFraction({ type: "time", part: m.charAt(0), format: m.length });
            }
            // elapsed time (interpret as interval of days)
            if ((m = input.skip(/^\[(hh?|mm?|ss?)\]/i))) {
                m = m[1].toLowerCase();
                return maybeFraction({ type: "eltime", part: m.charAt(0), format: m.length });
            }
            if ((m = input.skip(/^(a[.]?m[.]?\/p[.]?m[.]?|a\/p)/i))) {
                m = m[1].split("/");
                return { type: "ampm", am: m[0], pm: m[1] };
            }
            switch ((ch = input.next())) { // JSHint sadness
              case ";":
                return null;
              case "\\":
                // quotes next character
                return { type: "str", value: input.next() };
              case '"':
                return { type: "str", value: input.readEscaped(ch) };
              case "@":
                return { type: "text" };
              case "_":
                // whitespace of the width of following character
                return { type: "space", value: input.next() };
              case "*":
                // fills cell width with the following character
                return { type: "fill", value: input.next() };
              case ".":
                if (input.lookingAt(/^\s*[#0?]/)) {
                    decimalPart = true;
                    return { type: "dec" };
                }
                return { type: "str", value: "." };
              case "%":
                return { type: "percent" };
              case ",":
                return { type: "comma" };
            }

            // whatever we can't make sense of, output literally.
            return { type: "str", value: ch };
        }

        function readSection() {
            decimalPart = false;
            var color = maybeColor(), cond = maybeCondition();
            if (!color && cond) {
                color = maybeColor();
            }
            return {
                color : color,
                cond  : cond,
                body  : readFormat()
            };
        }
    }

    function print(sections) {
        return sections.map(printSection).join(";");

        function printSection(sec) {
            var out = "";
            if (sec.color) {
                out += "[" + sec.color + "]";
            }
            if (sec.cond) {
                if (!(sec.cond == "text" || sec.cond == "num")) {
                    out += "[" + sec.cond.op + sec.cond.value + "]";
                }
            }
            out += sec.body.map(printToken).join("");
            return out;
        }

        function maybeFraction(fmt, tok) {
            if (tok.fraction) {
                fmt += "." + padLeft("", tok.fraction, "0");
            }
            return fmt;
        }

        function printToken(tok) {
            if (tok.type == "digit") {
                if (tok.sep) {
                    return tok.format.charAt(0) + "," + tok.format.substr(1);
                } else {
                    return tok.format;
                }
            }
            else if (tok.type == "exp") {
                return tok.ch + tok.sign;
            }
            else if (tok.type == "date" || tok.type == "time") {
                return maybeFraction(padLeft("", tok.format, tok.part), tok);
            }
            else if (tok.type == "eltime") {
                return maybeFraction("[" + padLeft("", tok.format, tok.part) + "]", tok);
            }
            else if (tok.type == "ampm") {
                return tok.am + "/" + tok.pm;
            }
            else if (tok.type == "str") {
                return JSON.stringify(tok.value);
            }
            else if (tok.type == "text") {
                return "@";
            }
            else if (tok.type == "space") {
                return "_" + tok.value;
            }
            else if (tok.type == "fill") {
                return "*" + tok.value;
            }
            else if (tok.type == "dec") {
                return ".";
            }
            else if (tok.type == "percent") {
                return "%";
            }
            else if (tok.type == "comma") {
                return ",";
            }
        }
    }

    function adjustDecimals(sections, x) {
        sections.forEach(function(sec) {
            var diff = x;
            if (sec.cond == "text") {
                return;
            }
            var body = sec.body, adjusted = false, i = body.length;
            while (diff !== 0 && --i >= 0) {
                var tok = body[i];
                if (tok.type == "digit") {
                    if (tok.decimal) {
                        adjusted = true;
                        if (diff > 0) {
                            tok.format += padLeft("", diff, "0");
                        } else if (diff < 0) {
                            var tmp = tok.format.length;
                            tok.format = tok.format.substr(0, tmp + diff);
                            diff += tmp - tok.format.length;
                        }
                        if (tok.format.length === 0) {
                            body.splice(i, 1);
                            while (--i >= 0) {
                                tok = body[i];
                                if (tok.type == "digit" && tok.decimal) {
                                    ++i;
                                    break;
                                }
                                if (tok.type == "dec") {
                                    body.splice(i, 1);
                                    break;
                                }
                            }
                        }
                    }
                    if (diff > 0) {
                        break;
                    }
                }
            }
            if (!adjusted && diff > 0) {
                // no decimal part was found, insert one after the last digit token.
                body.splice(
                    i + 1, 0, {
                        type    : "dec"
                    }, {
                        type    : "digit",
                        sep     : false,
                        decimal : true,
                        format  : padLeft("", diff, "0")
                    }
                );
            }
        });
    }

    function TokenStream(parts) {
        var index = 0;
        return {
            next: function() {
                return parts[index++];
            },
            eof: function() {
                return index >= parts.length;
            },
            ahead: function(n, f) {
                if (index + n <= parts.length) {
                    var val = f.apply(null, parts.slice(index, index + n));
                    if (val) {
                        index += n;
                    }
                    return val;
                }
            },
            restart: function() {
                index = 0;
            }
        };
    }

    function compileFormatPart(format) {
        var input = TokenStream(format.body);
        var hasDate = false;
        var hasTime = false;
        var hasAmpm = false;
        var percentCount = 0;
        var currency = /[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6]/;
        var scaleCount = 0;
        var code = "var intPart, decPart, isNegative, date, time; ";
        var separeThousands = false;
        var declen = 0;
        var intFormat = [], decFormat = [];
        var condition = format.cond;
        var preamble = "";

        if (condition == "text") {
            preamble = "if (typeof value == 'string' || value instanceof kendo.spreadsheet.CalcError) { ";
        }
        else if (condition == "num") {
            preamble = "if (typeof value == 'number') { ";
        }
        else if (condition) {
            var op = condition.op == "=" ? "==" : condition.op;
            preamble = "if (typeof value == 'number' && value "
                + op + " " + condition.value + ") { ";
            if (!condition.custom) {
                code += "value = Math.abs(value); ";
            }
        }

        if (format.color) {
            code += "result.color = " + JSON.stringify(format.color) + "; ";
        }

        function checkComma(a, b) {
            if ((a.type == "digit" && b.type == "comma") ||
                (a.type == "comma" && a.hidden && b.type == "comma"))
            {
                b.hidden = true;
                scaleCount++;
            }
        }

        while (!input.eof()) {
            input.ahead(2, checkComma);
            var tok = input.next();
            if (tok.type == "percent") {
                percentCount++;
            }
            else if (tok.type == "digit") {
                if (tok.decimal) {
                    declen += tok.format.length;
                    decFormat.push(tok.format);
                } else {
                    intFormat.push(tok.format);
                    if (tok.sep) {
                        separeThousands = true;
                    }
                }
            }
            else if (tok.type == "time") {
                hasTime = true;
            }
            else if (tok.type == "date") {
                hasDate = true;
            }
            else if (tok.type == "ampm") {
                hasAmpm = hasTime = true;
            }
        }

        if (percentCount > 0) {
            code += "value *= " + Math.pow(100, percentCount) + "; ";
        }
        if (scaleCount > 0) {
            code += "value /= " + Math.pow(1000, scaleCount) + "; ";
        }
        if (intFormat.length) {
            code += "intPart = runtime.formatInt(culture, value, " + JSON.stringify(intFormat) + ", " + declen + ", " + separeThousands + "); ";
            code += "isNegative = parseInt(intPart[0]) < 0;";
        }
        if (decFormat.length) {
            code += "decPart = runtime.formatDec(value, " + JSON.stringify(decFormat) + ", " + declen + "); ";
        }
        if (intFormat.length || decFormat.length) {
            code += "type = 'number'; ";
        }
        if (hasDate) {
            code += "date = runtime.unpackDate(value); ";
        }
        if (hasTime) {
            code += "time = runtime.unpackTime(value); ";
        }
        if (hasDate || hasTime) {
            code += "type = 'date'; ";
        }

        if (percentCount > 0 || scaleCount > 0 || intFormat.length || decFormat.length || hasDate || hasTime) {
            if (!preamble) {
                preamble = "if (typeof value == 'number') { ";
            }
        }

        input.restart();
        code += "var matchedCurrency = false;";
        while (!input.eof()) {
            var tok = input.next();
            if (tok.type == "dec") {
                code += "output += culture.numberFormat['.']; ";
            }
            else if (tok.type == "comma" && !tok.hidden) {
                code += "output += ','; ";
            }
            else if (tok.type == "percent") {
                code += "type = 'percent'; ";
                code += "output += culture.numberFormat.percent.symbol; ";
            }
            else if (tok.type == "str") {
                if (currency.test(tok.value)) {
                    code += "type = 'currency'; ";
                    code += "if (isNegative) { output += '-'; matchedCurrency = true; }";
                }
                code += "output += " + JSON.stringify(tok.value) + "; ";
            }
            else if (tok.type == "text") {
                code += "type = 'text'; ";
                code += "output += value; ";
            }
            else if (tok.type == "space") {
                code += "if (output) result.body.push(output); ";
                code += "output = ''; ";
                code += "result.body.push({ type: 'space', value: " + JSON.stringify(tok.value) + " }); ";
            }
            else if (tok.type == "fill") {
                code += "output += runtime.fill(" + JSON.stringify(tok.value) + "); ";
            }
            else if (tok.type == "digit") {
                code += "if (isNegative && intPart[0] && matchedCurrency) {intPart[0] = intPart[0].replace('-', '');}";
                code += "output += " + (tok.decimal ? "decPart" : "intPart") + ".shift(); ";
            }
            else if (tok.type == "date") {
                code += "output += runtime.date(culture, date, "
                    + JSON.stringify(tok.part) + ", " + tok.format + "); ";
            }
            else if (tok.type == "time") {
                code += "output += runtime.time(time, "
                    + JSON.stringify(tok.part) + ", " + tok.format + ", " + hasAmpm + ", " + tok.fraction + "); ";
            }
            else if (tok.type == "eltime") {
                code += "output += runtime.eltime(value, "
                    + JSON.stringify(tok.part) + ", " + tok.format + ", " + tok.fraction + "); ";
            }
            else if (tok.type == "ampm") {
                // XXX: should use culture?  As per the "spec", Excel
                // displays whatever the token was (AM/PM, a/p etc.)
                code += "output += time.hours < 12 ? " + JSON.stringify(tok.am) + " : " + JSON.stringify(tok.pm) + "; ";
            }
        }

        code += "if (output) result.body.push(output); ";
        code += "result.type = type; ";
        code += "return result; ";

        if (preamble) {
            code = preamble + code + "}";
        }

        return code;
    }

    var TEXT = compileFormatPart({ cond: "text", body: [ { type: "text" } ] });

    var compile = util.memoize(function(format) {
        var tree = parse(format);
        var code = tree.map(compileFormatPart);
        code.push(TEXT);
        code = code.join("\n");
        code = "'use strict'; return function(value, culture){ "
            + "if (!culture) culture = kendo.culture(); "
            + "var output = '', type = null, result = { body: [] }; " + code + "; return result; };";
        return new Function("runtime", code)(runtime);
    });

    // Attempts to produce a format compatible with kendo.parseDate from our Excel format.  Needed
    // in runtime.parseDate (passing Excel format to kendo.parseDate will mess up the month or
    // minutes).  https://github.com/telerik/kendo-ui-core/issues/3797
    var makeDateFormat = util.memoize(function(format){
        var tree = parse(format);
        var section, found = false, hasAmpm = false;

        // locate a section that contains date/time formatting.  only the first will be converted.
        for (var i = 0; i < tree.length; ++i) {
            section = tree[i];
            for (var j = 0; j < section.body.length; ++j) {
                if (/^(?:date|time|ampm)$/.test(section.body[j].type)) {
                    found = true;
                    if (section.body[j].type == "ampm") {
                        hasAmpm = true;
                    }
                }
            }
            if (found) {
                break;
            }
        }
        if (!found) {
            return null;
        }

        return section.body.map(printToken).join("");

        // a little copy/paste goes a long way

        function maybeFraction(fmt, tok) {
            if (tok.fraction) {
                fmt += padLeft("", Math.max(tok.fraction, 3), "f");
            }
            return fmt;
        }

        function printToken(tok) {
            if (tok.type == "digit") {
                if (tok.sep) {
                    return tok.format.charAt(0) + "," + tok.format.substr(1);
                } else {
                    return tok.format;
                }
            }
            else if (tok.type == "exp") {
                return tok.ch + tok.sign;
            }
            else if (tok.type == "date" || tok.type == "time") {
                var part = tok.part;
                if (tok.type == "date" && /^m/.test(part)) {
                    part = "M"; // month, not minutes
                }
                else if (tok.type == "time" && /^h/.test(part)) {
                    if (!hasAmpm) {
                        // 24-hours clock is H or HH
                        part = part.toUpperCase();
                    }
                }
                return maybeFraction(padLeft("", tok.format, part), tok);
            }
            else if (tok.type == "ampm") {
                return "tt";
            }
            else if (tok.type == "str") {
                // XXX: this is a bit wrong.  it doesn't look like kendo.toString / kendo.parseDate
                // support arbitrary text (in Excel formats that's quoted), for example:
                //    kendo.toString(new Date(), "here's the day dude: dd")
                //   "3ere'8 t3e 19ay 19u19e: 19"   (it's 19th June, 3 o'clock, probably 8 seconds)
                return tok.value;
            }
            else if (tok.type == "space") {
                return " ";
            }
            else if (tok.type == "dec") {
                return ".";
            }
            else if (tok.type == "percent") {
                return "%";
            }
            else if (tok.type == "comma") {
                return ",";
            }
            else {
                return "";
            }
        }
    });

    var runtime = {

        unpackDate: calc.runtime.unpackDate,
        unpackTime: calc.runtime.unpackTime,

        date: function(culture, d, part, length) {
            switch (part) {
              case "d":
                switch (length) {
                  case 1: return d.date;
                  case 2: return padLeft(d.date, 2, "0");
                  case 3: return culture.calendars.standard.days.namesAbbr[d.day];
                  case 4: return culture.calendars.standard.days.names[d.day];
                }
                break;
              case "m":
                switch (length) {
                  case 1: return d.month + 1;
                  case 2: return padLeft(d.month + 1, 2, "0");
                  case 3: return culture.calendars.standard.months.namesAbbr[d.month];
                  case 4: return culture.calendars.standard.months.names[d.month];
                  case 5: return culture.calendars.standard.months.names[d.month].charAt(0);
                }
                break;
              case "y":
                switch (length) {
                  case 2: return d.year % 100;
                  case 4: return d.year;
                }
                break;
            }
            return "##";
        },

        time: function(t, part, length, ampm, fraclen) {
            var ret, fraction;
            switch (part) {
              case "h":
                ret = padLeft(ampm ? t.hours % 12 || 12 : t.hours, length, "0");
                if (fraclen) {
                    fraction = (t.minutes + (t.seconds + t.milliseconds / 1000) / 60) / 60;
                }
                break;
              case "m":
                ret = padLeft(t.minutes, length, "0");
                if (fraclen) {
                    fraction = (t.seconds + t.milliseconds / 1000) / 60;
                }
                break;
              case "s":
                ret = padLeft(t.seconds, length, "0");
                if (fraclen) {
                    fraction = t.milliseconds / 1000;
                }
                break;
            }
            if (fraction) {
                ret += runtime.toFixed(fraction, fraclen).replace(/^0+/, "");
            }
            return ret;
        },

        eltime: function(value, part, length, fraclen) {
            var ret, fraction;
            switch (part) {
              case "h":
                ret = value * 24;
                break;
              case "m":
                ret = value * 24 * 60;
                break;
              case "s":
                ret = value * 24 * 60 * 60;
                break;
            }
            if (fraclen) {
                fraction = ret - (ret | 0);
            }
            ret = padLeft(ret | 0, length, "0");
            if (fraction) {
                ret += runtime.toFixed(fraction, fraclen).replace(/^0+/, "");
            }
            return ret;
        },

        fill: function(ch) {
            // XXX: how to implement this?
            return ch;
        },

        // formatting integer part is slightly different than decimal
        // part, so they're implemented in two functions.  For the
        // integer part we need to walk the value and the format
        // backwards (right-to-left).

        formatInt: function(culture, value, parts, declen, sep) {
            // toFixed is perfect for rounding our value; if there is
            // no format for decimals, for example, we want the number
            // rounded up.
            value = runtime.toFixed(value, declen).replace(/\..*$/, "");
            var lastPart = parts[parts.length - 1];

            if (declen > 0 && lastPart[parts.length - 1] != "0") {
                // if the rounded number is zero and we have decimal
                // format, consider it a non-significant digit (Excel
                // won't display the leading zero for 0.2 in format #.#).
                // the zero won't e omitted if using 0.0 format
                if (value === "0") { value = ""; }
                else if (value === "-0") { value = "-"; }
            }

            var shouldInsertMinus = false;
            var iv = value.length - 1;
            var result = [];
            var len = 0, str;

            function add(ch, skipMinus) {
                if (sep && len && len % 3 === 0 && /^[0-9]$/.test(ch)) {
                    str = culture.numberFormat[","] + str;
                }
                if(skipMinus && ch === "-") {
                    shouldInsertMinus = true;
                    ch = "0";
                }
                str = ch + str;
                len++;
            }

            for (var j = parts.length; --j >= 0;) {
                var format = parts[j];
                str = "";
                for (var k = format.length; --k >= 0;) {
                    var chf = format.charAt(k);
                    if (iv < 0) {
                        if (chf == "0") {
                            add("0");
                        } else if (chf == "?") {
                            add(" ");
                        }
                    } else {
                        if (value == "0" && chf == "?") {
                            add(" ");
                        } else if (chf == "0") {
                            add(value.charAt(iv), true);
                        } else {
                            add(value.charAt(iv));
                        }
                        iv--;
                    }
                }
                if (j === 0) {
                    while (iv >= 0) {
                        add(value.charAt(iv--));
                    }
                }
                result.unshift(str);
            }

            if(shouldInsertMinus) {
                result[0] = "-" + result[0];
            }

            return result;
        },

        // for decimal part we walk in normal direction and pad on the
        // right if required (for '0' or '?' chars).

        formatDec: function(value, parts, declen) {
            value = runtime.toFixed(value, declen);
            var pos = value.indexOf(".");
            if (pos >= 0) {
                value = value.substr(pos + 1).replace(/0+$/, "");
            } else {
                value = "";
            }

            var iv = 0;
            var result = [];

            for (var j = 0; j < parts.length; ++j) {
                var format = parts[j];
                var str = "";
                for (var k = 0; k < format.length; ++k) {
                    var chf = format.charAt(k);
                    if (iv < value.length) {
                        str += value.charAt(iv++);
                    } else if (chf == "0") {
                        str += "0";
                    } else if (chf == "?") {
                        str += " ";
                    }
                }
                result.push(str);
            }

            return result;
        },

        // JS's toFixed is broken, it's only OK to use it on integers.
        toFixed: function(value, decimals) {
            return (function toFixed(value, last) {
                if (!isFinite(value)) {
                    return "#NUM!";
                }

                // deal early with the trivial cases
                if (value < 0) {    // JS's Math.round is broken with negative numbers
                    return "-" + toFixed(-value);
                }

                if (decimals === 0) { // no decimals
                    return String(Math.round(value));
                }

                if (value === Math.round(value) && !/e/i.test(String(value))) { // value is integer and not too big
                    return value.toFixed(decimals);
                }

                // this handles cases like 0.3.toFixed(20) == "0.29999999999999998890", or
                // 2.1825.toFixed(20) = "2.18250000000000010658".
                // https://github.com/telerik/kendo-ui-core/issues/3520#issuecomment-333768221
                // https://twitter.com/mcbazon/status/1035828655652593665
                var num = digNumber(value);
                var intpart = num.intpart;
                var decpart = num.decpart;
                if (decpart.length <= decimals) {
                    while (decpart.length < decimals) {
                        decpart += "0";
                    }
                    return intpart + "." + decpart;
                }

                if (last) {
                    // "we should definitely not get here" (famous last words).  Let's MAKE SURE
                    // there's no more recursion.
                    return intpart + "." + decpart.substr(0, decimals);
                }

                // if there are more decimals than wanted, round and try again.
                // it should not recurse more than once.
                var f = Math.pow(10, decimals);
                return toFixed(Math.round(value * f) / f, true);

            })(Number(value.toFixed(14))); /* restrict to 14 decimals, because 0.1 + 0.2 ===
                                                 * 0.30000000000000004 */
        }

    };

    function padLeft(val, width, ch) {
        val += "";
        while (val.length < width) {
            val = ch + val;
        }
        return val;
    }

    function padRight(val, width, ch) {
        val += "";
        while (val.length < width) {
            val += ch;
        }
        return val;
    }

    // given a number, return { intpart, decpart } as strings.  the main difficulty here is that JS
    // will stringify really large values in scientific notation (e.g. 1.23e+30, which is actually
    // the integer 1230000000000000000000000000000).
    function digNumber(num) {
        var str = String(num).toLowerCase();
        var intpart, decpart, m;
        var pos = str.indexOf(".");
        if (pos < 0) {
            pos = str.indexOf("e");
            if (pos < 0) {
                intpart = str;
                decpart = "";
            } else {
                intpart = str.substr(0, pos);
                decpart = str.substr(pos);
            }
        } else {
            intpart = str.substr(0, pos);
            decpart = str.substr(pos + 1);
        }
        if ((m = /(\d*)e([-+]?\d+)/.exec(decpart))) {
            var exp = parseInt(m[2], 10);
            if (exp >= 0) {
                decpart = padRight(m[1], exp, "0");
                intpart += decpart.substr(0, exp);
                decpart = decpart.substr(exp);
            } else {
                intpart = padLeft(intpart, -exp, "0");
                decpart = intpart.substr(exp) + m[1];
                intpart = intpart.substr(0, intpart.length + exp);
            }
        }
        return { intpart: intpart || "0", decpart: decpart };
    }

    /* -----[ exports ]----- */

    function text(f) {
        var a = f.body;
        var text = "";
        for (var i = 0; i < a.length; ++i) {
            var el = a[i];
            if (typeof el == "string") {
                text += el;
            } else if (el.type == "space") {
                text += " ";
            }
        }
        return text;
    }

    kendo.spreadsheet.formatting = {
        compile : compile,
        parse: parse,
        format: function(value, format, culture) {
            var f = compile(format)(value, culture);
            var span = dom.element("span");
            span.__dataType = f.type;
            var a = f.body;
            if (f.color) {
                span.attr.style = { color: f.color };
            }
            for (var i = 0; i < a.length; ++i) {
                var el = a[i];
                if (typeof el == "string") {
                    span.children.push(dom.text(el));
                } else if (el.type == "space") {
                    span.children.push(dom.element("span", {
                        style: { visibility: "hidden" }
                    }, [ dom.text(el.value) ]));
                }
            }
            return span;
        },
        text: function(value, format, culture) {
            var f = compile(format)(value, culture);
            return text(f);
        },
        textAndColor: function(value, format, culture) {
            var f = compile(format)(value, culture);
            return { text: text(f), color: f.color, type: f.type };
        },
        type: function(value, format) {
            return compile(format)(value).type;
        },
        adjustDecimals: function(format, diff) {
            var ast = parse(format);
            adjustDecimals(ast, diff);
            return print(ast);
        },
        makeDateFormat: makeDateFormat
    };

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

// -*- fill-column: 100 -*-

(function(f, define){
    define('spreadsheet/runtime.functions',[ "./runtime", "../util/main" ], f);
})(function(){
    "use strict";

    // WARNING: removing the following jshint declaration and turning
    // == into === to make JSHint happy will break functionality.
    /* jshint eqnull:true, newcap:false, laxbreak:true, validthis:true */
    /* jshint latedef:false */

    var util = kendo.util;
    var spreadsheet = kendo.spreadsheet;
    var calc = spreadsheet.calc;
    var runtime = calc.runtime;
    var defineFunction = runtime.defineFunction;
    var defineAlias = runtime.defineAlias;
    var CalcError = runtime.CalcError;
    var RangeRef = spreadsheet.RangeRef;
    var CellRef = spreadsheet.CellRef;
    var UnionRef = spreadsheet.UnionRef;
    var Matrix = runtime.Matrix;
    var Ref = spreadsheet.Ref;
    var NameRef = spreadsheet.NameRef;
    var daysInMonth = runtime.daysInMonth;
    var packDate = runtime.packDate;
    var unpackDate = runtime.unpackDate;
    var daysInYear = runtime.daysInYear;
    var limitPrecision = runtime.limitPrecision;

    /* -----[ Math functions ]----- */

    [ "abs", "cos", "sin", "acos", "asin", "tan", "atan", "exp", "sqrt" ].forEach(function(name){
        defineFunction(name, Math[name]).args([
            [ "*n", "number" ]
        ]);
    });

    defineFunction("ln", Math.log).args([
        [ "*n", "number" ]
    ]);

    defineFunction("log", function(num, base){
        return Math.log(num) / Math.log(base);
    }).args([
        [ "*num", "number++" ],
        [ "*base", [ "or", "number++", [ "null", 10 ] ] ],
        [ "?", [ "assert", "$base != 1", "DIV/0" ] ]
    ]);

    defineFunction("log10", function(num){
        return Math.log(num) / Math.log(10);
    }).args([
        [ "*num", "number++" ]
    ]);

    defineFunction("pi", function(){
        return Math.PI;
    }).args([]);

    defineFunction("sqrtpi", function(n){
        return Math.sqrt(n * Math.PI);
    }).args([
        [ "*num", "number+" ]
    ]);

    defineFunction("degrees", function(rad){
        return ((180 * rad) / Math.PI) % 360;
    }).args([
        [ "*radians", "number" ]
    ]);

    defineFunction("radians", function(deg){
        return Math.PI * deg / 180;
    }).args([
        [ "*degrees", "number" ]
    ]);

    function _cosh(n){
        return (Math.exp(n) + Math.exp(-n)) / 2;
    }

    defineFunction("cosh", _cosh).args([
        [ "*num", "number" ]
    ]);

    defineFunction("acosh", function(n){
        return Math.log(n + Math.sqrt(n - 1) * Math.sqrt(n + 1));
    }).args([
        [ "*num", "number" ],
        [ "?", [ "assert", "$num >= 1" ] ]
    ]);

    function _sinh(n){
        return (Math.exp(n) - Math.exp(-n)) / 2;
    }

    defineFunction("sinh", _sinh).args([
        [ "*num", "number" ]
    ]);

    defineFunction("asinh", function(n){
        return Math.log(n + Math.sqrt(n * n + 1));
    }).args([
        [ "*num", "number" ]
    ]);

    defineFunction("sec", function(n){
        return 1 / Math.cos(n);
    }).args([
        [ "*num", "number" ]
    ]);

    defineFunction("sech", function(n){
        return 1 / _cosh(n);
    }).args([
        [ "*num", "number" ]
    ]);

    defineFunction("csc", function(n){
        return 1 / Math.sin(n);
    }).args([
        [ "*num", "number" ]
    ]);

    defineFunction("csch", function(n){
        return 1 / _sinh(n);
    }).args([
        [ "*num", "number" ]
    ]);

    defineFunction("atan2", function(x, y){
        return Math.atan(y / x);
    }).args([
        [ "*x", "divisor" ],
        [ "*y", "number" ]
    ]);

    function _tanh(n) {
        return _sinh(n) / _cosh(n);
    }

    defineFunction("tanh", _tanh).args([
        [ "*num", "number" ]
    ]);

    defineFunction("atanh", function(n){
        return Math.log(Math.sqrt(1 - n*n) / (1 - n));
    }).args([
        [ "*num", [ "and", "number", [ "(between)", -1, 1 ] ] ]
    ]);

    defineFunction("cot", function(n){
        return 1 / Math.tan(n);
    }).args([
        [ "*num", "divisor" ]
    ]);

    defineFunction("coth", function(n){
        return 1 / _tanh(n);
    }).args([
        [ "*num", "divisor" ]
    ]);

    defineFunction("acot", function(n){
        return Math.PI / 2 - Math.atan(n);
    }).args([
        [ "*num", "number" ]
    ]);

    defineFunction("acoth", function(n){
        return Math.log((n + 1) / (n - 1)) / 2;
    }).args([
        [ "*num", "number" ],
        [ "?", [ "or",
                 [ "assert", "$num < -1"],
                 [ "assert", "$num > 1" ] ] ]
    ]);

    defineFunction("power", function(a, b){
        return Math.pow(a, b);
    }).args([
        [ "*a", "number" ],
        [ "*b", "number" ]
    ]);

    defineFunction("mod", function(a, b){
        return a % b;
    }).args([
        [ "*a", "number" ],
        [ "*b", "divisor" ]
    ]);

    defineFunction("quotient", function(a, b){
        return Math.floor(a / b);
    }).args([
        [ "*a", "number" ],
        [ "*b", "divisor" ]
    ]);

    defineFunction("ceiling", function(num, s){
        return s ? s * Math.ceil(num / s) : 0;
    }).args([
        [ "*number", "number" ],
        [ "*significance", "number" ],
        [ "?", [ "assert", "$significance >= 0 || $number < 0" ] ]
    ]);

    defineFunction("ceiling.precise", function(num, s){
        s = Math.abs(s);
        return s ? s * Math.ceil(num / s) : 0;
    }).args([
        [ "*number", "number" ],
        [ "*significance", [ "or", "number", [ "null", 1 ] ] ]
    ]);

    defineAlias("iso.ceiling", "ceiling.precise");

    // XXX: how do we know if this function is correct?
    //
    // https://support.office.com/en-gb/article/CEILING-MATH-function-80f95d2f-b499-4eee-9f16-f795a8e306c8
    //
    // There are many combinations of Significance and Mode values that affect rounding of negative
    // numbers in different ways.  right, thanks for the info. :-\
    defineFunction("ceiling.math", function(num, s, mode){
        if (!s || !num) {
            return 0;
        }
        if (num < 0 && ((!mode && s < 0) || (mode && s > 0))) {
            s = -s;
        }
        return s ? s * Math.ceil(num / s) : 0;
    }).args([
        [ "*number", "number" ],
        [ "*significance", [ "or", "number", [ "null", "$number < 0 ? -1 : 1" ] ] ],
        [ "*mode", [ "or", "logical", [ "null", 0 ] ] ]
    ]);

    defineFunction("floor", function(num, s){
        return s ? s * Math.floor(num / s) : 0;
    }).args([
        [ "*number", "number" ],
        [ "*significance", "number" ],
        [ "?", [ "assert", "$significance >= 0 || $number < 0" ] ]
    ]);

    defineFunction("floor.precise", function(num, s){
        s = Math.abs(s);
        return s ? s * Math.floor(num / s) : 0;
    }).args([
        [ "*number", "number" ],
        [ "*significance", [ "or", "number", [ "null", 1 ] ] ]
    ]);

    // XXX: check this
    defineFunction("floor.math", function(num, s, mode){
        if (!s || !num) {
            return 0;
        }
        if (num < 0 && ((!mode && s < 0) || (mode && s > 0))) {
            s = -s;
        }
        return s ? s * Math.floor(num / s) : 0;
    }).args([
        [ "*number", "number" ],
        [ "*significance", [ "or", "number", [ "null", "$number < 0 ? -1 : 1" ] ] ],
        [ "*mode", [ "or", "logical", [ "null", 0 ] ] ]
    ]);

    defineFunction("int", Math.floor).args([
        [ "*number", "number" ]
    ]);

    defineFunction("mround", function(num, mult){
        return mult ? mult * Math.round(num / mult) : 0;
    }).args([
        [ "*number", "number" ],
        [ "*multiple", "number" ]
    ]);

    defineFunction("round", function(num, digits){
        var sign = num < 0 ? -1 : 1;
        if (sign < 0) { num = -num; }
        digits = Math.pow(10, digits);
        num = limitPrecision(num * digits);
        num = Math.round(num);
        return sign * num / digits;
    }).args([
        [ "*number", "number" ],
        [ "*digits", "number" ]
    ]);

    defineFunction("roundup", function(num, digits){
        digits = Math.pow(10, digits);
        num = limitPrecision(num * digits);
        num = num < 0 ? Math.floor(num) : Math.ceil(num);
        return num / digits;
    }).args([
        [ "*number", "number" ],
        [ "*digits", "number" ]
    ]);

    defineFunction("rounddown", function(num, digits){
        digits = Math.pow(10, digits);
        num = limitPrecision(num * digits);
        num = num < 0 ? Math.ceil(num) : Math.floor(num);
        return num / digits;
    }).args([
        [ "*number", "number" ],
        [ "*digits", "number" ]
    ]);

    defineFunction("even", function(num){
        var n = num < 0 ? Math.floor(num) : Math.ceil(num);
        return n % 2 ? n + (n < 0 ? -1 : 1) : n;
    }).args([
        [ "*number", "number" ]
    ]);

    defineFunction("odd", function(num){
        var n = num < 0 ? Math.floor(num) : Math.ceil(num);
        return n % 2 ? n : n + (n < 0 ? -1 : 1);
    }).args([
        [ "*number", "number" ]
    ]);

    defineFunction("sign", function(num){
        return num < 0 ? -1 : num > 0 ? 1 : 0;
    }).args([
        [ "*number", "number" ]
    ]);

    function _gcd(a, b) {
        while (b) {
            var r = a % b;
            a = b;
            b = r;
        }
        return a;
    }

    function _lcm(a, b) {
        return Math.abs(a * b) / _gcd(a, b);
    }

    defineFunction("gcd", function(args){
        var a = args[0];
        for (var i = 1; i < args.length; ++i) {
            a = _gcd(a, args[i]);
        }
        return a;
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("lcm", function(args){
        var a = args[0];
        for (var i = 1; i < args.length; ++i) {
            a = _lcm(a, args[i]);
        }
        return a;
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("sum", function(numbers){
        return numbers.reduce(function(sum, num){
            return sum + num;
        }, 0);
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("product", function(numbers){
        return numbers.reduce(function(prod, num){
            return prod * num;
        }, 1);
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("sumproduct", function(first, rest) {
        var sum = 0;
        first.each(function(p, row, col){
            if (typeof p == "number") {
                for (var i = 0; i < rest.length; ++i) {
                    var v = rest[i].get(row, col);
                    if (typeof v != "number") {
                        return;
                    }
                    p *= v;
                }
                sum += p;
            }
        });
        return sum;
    }).args([
        [ "a1", "matrix" ],
        [ "+",
          [ "a2", [ "and", "matrix",
                    [ "assert", "$a2.width == $a1.width" ],
                    [ "assert", "$a2.height == $a1.height" ] ] ] ]
    ]);

    defineFunction("sumsq", function(numbers){
        return numbers.reduce(function(sum, num){
            return sum + num * num;
        }, 0);
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("sumx2my2", function(a, b){
        var sum = 0;
        a.each(function(x, row, col){
            var y = b.get(row, col);
            if (typeof x == "number" && typeof y == "number") {
                sum += x*x - y*y;
            }
        });
        return sum;
    }).args([
        [ "a", "matrix" ],
        [ "b", [ "and", "matrix",
                 [ "assert", "$b.width == $a.width" ],
                 [ "assert", "$b.height == $a.height" ] ] ]
    ]);

    defineFunction("sumx2py2", function(a, b){
        var sum = 0;
        a.each(function(x, row, col){
            var y = b.get(row, col);
            if (typeof x == "number" && typeof y == "number") {
                sum += x*x + y*y;
            }
        });
        return sum;
    }).args([
        [ "a", "matrix" ],
        [ "b", [ "and", "matrix",
                 [ "assert", "$b.width == $a.width" ],
                 [ "assert", "$b.height == $a.height" ] ] ]
    ]);

    defineFunction("sumxmy2", function(a, b){
        var sum = 0;
        a.each(function(x, row, col){
            var y = b.get(row, col);
            if (typeof x == "number" && typeof y == "number") {
                sum += (x - y) * (x - y);
            }
        });
        return sum;
    }).args([
        [ "a", "matrix" ],
        [ "b", [ "and", "matrix",
                 [ "assert", "$b.width == $a.width" ],
                 [ "assert", "$b.height == $a.height" ] ] ]
    ]);

    defineFunction("seriessum", function(x, n, m, a){
        var sum = 0;
        a.each(function(coef){
            if (typeof coef != "number") {
                throw new CalcError("VALUE");
            }
            sum += coef * Math.pow(x, n);
            n += m;
        });
        return sum;
    }).args([
        [ "x", "number" ],
        [ "y", "number" ],
        [ "m", "number" ],
        [ "a", "matrix" ]
    ]);

    defineFunction("min", function(numbers){
        return numbers.length ? Math.min.apply(Math, numbers) : 0;
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("max", function(numbers){
        return numbers.length ? Math.max.apply(Math, numbers) : 0;
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("counta", function(values){
        return values.length;
    }).args([
        [ "values", [ "#collect", "anyvalue" ] ]
    ]);

    defineFunction("count", function(numbers){
        return numbers.length;
    }).args([
        [ "numbers", [ "#collect", "number" ] ]
    ]);

    defineFunction("countunique", function(values){
        var count = 0, seen = [];
        values.forEach(function(val){
            if (seen.indexOf(val) < 0) {
                count++;
                seen.push(val);
            }
        });
        return count;
    }).args([
        [ "values", [ "#collect", "anyvalue" ] ]
    ]);

    defineFunction("countblank", function(a){
        var count = 0;
        function add(val) {
            if (val == null || val === "") {
                count++;
            }
        }
        function loop(args){
            for (var i = 0; i < args.length; ++i) {
                var x = args[i];
                if (x instanceof Matrix) {
                    x.each(add, true);
                } else {
                    add(x);
                }
            }
        }
        loop(a);
        return count;
    }).args([
        [ "+", [ "args", [ "or", "matrix", "anyvalue" ] ] ]
    ]);

    defineFunction("iseven", function(num){
        return num % 2 === 0;
    }).args([
        [ "*number", "number" ]
    ]);

    defineFunction("isodd", function(num){
        return num % 2 !== 0;
    }).args([
        [ "*number", "number" ]
    ]);

    defineFunction("n", function(val){
        if (typeof val == "boolean") {
            return val ? 1 : 0;
        }
        if (typeof val == "number") {
            return val;
        }
        return 0;
    }).args([
        [ "*value", "anyvalue" ]
    ]);

    defineFunction("na", function(){
        return new CalcError("N/A");
    }).args([]);

    /* -----[ the "*IFS" functions ]----- */

    // helper function: take `args` like COUNTIFS (see Excel docs) and
    // calls `f` for each cell matching all criteria.  `f` receives
    // `chunks` (parsed args containing matrix and predicate) and
    // row,col of matching cells.
    function forIFS(args, f) {
        var chunks = [], i = 0, matrix = args[0];
        while (i < args.length) {
            chunks.push({
                matrix: args[i++],
                pred: parseCriteria(args[i++])
            });
        }
        ROW: for (var row = 0; row < matrix.height; ++row) {
            COL: for (var col = 0; col < matrix.width; ++col) {
                for (i = 0; i < chunks.length; ++i) {
                    var val = chunks[i].matrix.get(row, col);
                    if (!chunks[i].pred(val == null || val === "" ? 0 : val)) {
                        continue COL;
                    }
                }
                f(row, col);
            }
        }
    }

    var ARGS_COUNTIFS = [
        [ "m1", "matrix" ],
        [ "c1", "anyvalue" ],
        [ [ "m2", "matrix" ],
          [ "c2", "anyvalue" ] ]
    ];

    defineFunction("countifs", function(m1, c1, rest){
        var count = 0;
        rest.unshift(m1, c1);
        forIFS(rest, function(){ count++; });
        return count;
    }).args(ARGS_COUNTIFS);

    var ARGS_SUMIFS = [
        [ "range", "matrix" ]
    ].concat(ARGS_COUNTIFS);

    defineFunction("sumifs", function(range, m1, c1, args){
        // hack: insert a predicate that filters out non-numeric
        // values; should also accept blank cells.  it's safe to
        // modify args.
        args.unshift(range, numericPredicate, m1, c1);
        var sum = 0;
        forIFS(args, function(row, col){
            var val = range.get(row, col);
            if (val) {
                sum += val;
            }
        });
        return sum;
    }).args(ARGS_SUMIFS);

    // similar to sumifs, but compute average of matching cells
    defineFunction("averageifs", function(range, m1, c1, args){
        args.unshift(range, numericPredicate, m1, c1);
        var sum = 0, count = 0;
        forIFS(args, function(row, col){
            var val = range.get(row, col);
            if (val == null || val === "") {
                val = 0;
            }
            sum += val;
            count++;
        });
        return count ? sum / count : new CalcError("DIV/0");
    }).args(ARGS_SUMIFS);

    defineFunction("countif", function(matrix, criteria){
        criteria = parseCriteria(criteria);
        var count = 0;
        matrix.each(function(val){
            if (criteria(val)) {
                count++;
            }
        });
        return count;
    }).args([
        [ "range", "matrix" ],
        [ "*criteria", "anyvalue" ]
    ]);

    var ARGS_SUMIF = [
        [ "range", "matrix" ],
        [ "*criteria", "anyvalue" ],
        [ "sumRange", [ "or", "area", "#matrix", [ "null", "$range" ] ] ]
    ];

    function fetchSumRange(continuation) {
        return function(callback, range, criteria, sumRange) {
            var self = this;
            if (sumRange instanceof Ref) {
                // make sure it covers the same area as `range`, as the spec mentions:
                //
                //     The sum_range argument does not have to be the same size and shape as the
                //     range argument. The actual cells that are added are determined by using the
                //     upper leftmost cell in the sum_range argument as the beginning cell, and then
                //     including cells that correspond in size and shape to the range argument.
                //
                // It does make one wonder, since only the top-left cell in `sumRange` matters, why
                // should it be a range at all?  Oh well, Excel.
                var r = sumRange.clone().toRangeRef();
                if (r.width() != range.width || r.height() != range.height) {
                    if (!isFinite(r.topLeft.row)) {
                        r.topLeft.row = 0;
                    }
                    if (!isFinite(r.topLeft.col)) {
                        r.topLeft.col = 0;
                    }
                    r.bottomRight.row = r.topLeft.row + range.height - 1;
                    r.bottomRight.col = r.topLeft.col + range.width - 1;
                    return self.resolveCells([ r ], function(){
                        callback(continuation(range, criteria, self.asMatrix(r)));
                    });
                }
            }
            callback(continuation(range, criteria, self.asMatrix(sumRange)));
        };
    }

    defineFunction("sumif", fetchSumRange(function(range, criteria, sumRange){
        var sum = 0;
        criteria = parseCriteria(criteria);
        range.each(function(val, row, col){
            if (criteria(val)) {
                var v = sumRange.get(row, col);
                if (numericPredicate(v)) {
                    sum += v || 0;
                }
            }
        });
        return sum;
    })).argsAsync(ARGS_SUMIF);

    defineFunction("averageif", fetchSumRange(function(range, criteria, sumRange){
        var sum = 0, count = 0;
        criteria = parseCriteria(criteria);
        range.each(function(val, row, col){
            if (criteria(val)) {
                var v = sumRange.get(row, col);
                if (numericPredicate(v)) {
                    sum += v || 0;
                    count++;
                }
            }
        });
        return count ? sum / count : new CalcError("DIV/0");
    })).argsAsync(ARGS_SUMIF);

    (function(def){
        def("large", function(numbers, nth){
            return numbers.sort(descending)[nth];
        });
        def("small", function(numbers, nth){
            return numbers.sort(ascending)[nth];
        });
    })(function(name, handler){
        defineFunction(name, function(matrix, nth){
            var numbers = [];
            var error = matrix.each(function(val){
                if (val instanceof CalcError) {
                    return val;
                }
                if (typeof val == "number") {
                    numbers.push(val);
                }
            });
            if (error) {
                return error;
            }
            if (nth > numbers.length) {
                return new CalcError("NUM");
            }
            return handler(numbers, nth - 1);
        }).args([
            [ "array", "matrix" ],
            [ "*nth", "number++" ]
        ]);
    });

    function _avg(numbers) {
        return numbers.reduce(function(sum, num){
            return sum + num;
        }, 0) / numbers.length;
    }

    function _var_sp(numbers, divisor, avg) {
        if (avg == null) {
            avg = _avg(numbers);
        }
        return numbers.reduce(function(sum, num){
            return sum + Math.pow(num - avg, 2);
        }, 0) / divisor;
    }

    function _stdev_sp(numbers, divisor) {
        return Math.sqrt(_var_sp(numbers, divisor));
    }

    // https://support.office.com/en-sg/article/STDEV-S-function-7d69cf97-0c1f-4acf-be27-f3e83904cc23
    defineFunction("stdev.s", function(numbers){
        return _stdev_sp(numbers, numbers.length - 1);
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]
    ]);

    // https://support.office.com/en-sg/article/STDEV-P-function-6e917c05-31a0-496f-ade7-4f4e7462f285
    defineFunction("stdev.p", function(numbers){
        return _stdev_sp(numbers, numbers.length);
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]
    ]);

    defineFunction("var.s", function(numbers){
        return _var_sp(numbers, numbers.length - 1);
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]
    ]);

    defineFunction("var.p", function(numbers){
        return _var_sp(numbers, numbers.length);
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]
    ]);

    defineFunction("median", function(numbers){
        var n = numbers.length;
        numbers.sort(ascending);
        if (n % 2) {
            // when length is odd, the median is the number in the middle
            return numbers[n >> 1];
        }
        // that's the average of the two middle numbers, written in in a fancy way
        return (numbers[n >>= 1] + numbers[n - 1]) / 2;
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length > 0", "N/A" ] ]
    ]);

    defineFunction("mode.sngl", function(numbers){
        numbers.sort(ascending);
        var prev = null, count = 0, max = 1, mode = null;
        for (var i = 0; i < numbers.length; ++i) {
            var n = numbers[i];
            if (n != prev) {
                count = 1;
                prev = n;
            } else {
                count++;
            }
            if (count > max) {
                max = count;
                mode = n;
            }
        }
        return mode == null ? new CalcError("N/A") : mode;
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("mode.mult", function(numbers){
        var seen = Object.create(null), max = 2, res = [];
        numbers.forEach(function(num){
            var s = seen[num] || 0;
            seen[num] = ++s;
            if (s == max) {
                res.push(num);
            } else if (s > max) {
                max = s;
                res = [ num ];
            }
        });
        var m = new Matrix(this);
        res.forEach(function(num, i){
            m.set(i, 0, num);
        });
        return m;
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    defineFunction("geomean", function(numbers){
        var n = numbers.length;
        var p = numbers.reduce(function(p, num){
            if (num < 0) {
                throw new CalcError("NUM");
            }
            return p * num;
        }, 1);
        return Math.pow(p, 1/n);
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length > 0", "NUM" ] ]
    ]);

    defineFunction("harmean", function(numbers){
        var n = numbers.length;
        var s = numbers.reduce(function(s, num){
            if (!num) {
                throw new CalcError("DIV/0");
            }
            return s + 1 / num;
        }, 0);
        return n / s;
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length > 0", "NUM" ] ]
    ]);

    defineFunction("trimmean", function(numbers, p){
        var n = numbers.length;
        numbers.sort(ascending);
        var discard = Math.floor(n * p);
        if (discard % 2) {
            --discard;
        }
        discard /= 2;
        var sum = 0;
        for (var i = discard; i < n-discard; ++i) {
            sum += numbers[i];
        }
        return sum / (n - discard * 2);
    }).args([
        [ "numbers", [ "collect", "number", 1 ] ],
        [ "percent", [ "and", "number", [ "[between)", 0, 1 ] ] ],
        [ "?", [ "assert", "$numbers.length > 0", "NUM" ] ]
    ]);

    defineFunction("frequency", function(data, bins){
        // apparently this always returns a vertical matrix in Excel, so we collect all numbers in
        // bins instead of receiving it as a Matrix and try to mimic its shape.
        data.sort(ascending);
        bins.sort(ascending);
        var prev = -Infinity;
        var i = 0;
        function count(max) {
            var n = 0;
            while (i < data.length && data[i] > prev && data[i] <= max) {
                ++n; ++i;
            }
            return n;
        }
        var m = new Matrix(this);
        bins.forEach(function(val, i){
            var n = count(val);
            prev = val;
            m.set(i, 0, n);
        });
        m.set(m.height, 0, data.length - i);
        return m;
    }).args([
        [ "data", [ "collect", "number", 1 ] ],
        [ "bins", [ "collect", "number", 1 ] ]
    ]);

    defineFunction("rank.eq", function(val, numbers, asc) {
        numbers.sort(asc ? ascending : descending);
        var pos = numbers.indexOf(val);
        return pos < 0 ? new CalcError("N/A") : pos + 1;
    }).args([
        [ "value", "number" ],
        [ "numbers", [ "collect", "number" ] ],
        [ "order", [ "or", "logical", [ "null", false ] ] ]
    ]);

    defineAlias("rank", "rank.eq");

    defineFunction("rank.avg", function(val, numbers, asc) {
        numbers.sort(asc ? ascending : descending);
        var pos = numbers.indexOf(val);
        if (pos < 0) {
            return new CalcError("N/A");
        }
        for (var i = pos; numbers[i] == val; ++i){}
        return (pos + i + 1) / 2;
    }).args([
        [ "value", "number" ],
        [ "numbers", [ "collect", "number" ] ],
        [ "order", [ "or", "logical", [ "null", false ] ] ]
    ]);

    // formula available at https://support.office.microsoft.com/en-us/article/KURT-function-cbbc2312-dfa6-4cc4-b5c0-1b3c59cc9377
    defineFunction("kurt", function(numbers){
        var n = numbers.length;
        var avg = _avg(numbers);
        var variance = _var_sp(numbers, n-1, avg);
        var stddev = Math.sqrt(variance);
        var sum = numbers.reduce(function(sum, num){
            return sum + Math.pow((num - avg) / stddev, 4);
        }, 0);
        return n*(n+1)/((n-1)*(n-2)*(n-3)) * sum
            - 3*Math.pow(n-1, 2)/((n-2)*(n-3));
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length >= 4", "NUM" ] ]
    ]);

    function _percentrank(numbers, x, exc) {
        var nlt = 0, ngt = 0, left = null, right = null, found = false;
        numbers.forEach(function(num){
            if (num < x) {
                nlt++;
                left = left == null ? num : Math.max(left, num);
            } else if (num > x) {
                ngt++;
                right = right == null ? num : Math.min(right, num);
            } else {
                found = true;
            }
        });
        if (!nlt && !ngt) {
            return new CalcError("N/A");
        }
        if (found) {
            if (exc) {
                return (nlt + 1) / (numbers.length + 1);
            }
            return nlt / (nlt + ngt);
        }
        return ((right - x) * _percentrank(numbers, left, exc) +
                (x - left) * _percentrank(numbers, right, exc)) / (right - left);
    }

    var ARGS_PERCENTRANK = [
        [ "array", [ "collect", "number", 1 ] ],
        [ "x", "number" ],
        [ "significance", [ "or", [ "null", 3 ], "integer++" ] ],
        [ "?", [ "assert", "$array.length > 0", "NUM" ] ]
    ];

    defineFunction("percentrank.inc", function(numbers, x, significance) {
        var p = _percentrank(numbers, x, 0);
        p = p.toFixed(significance + 1);
        return parseFloat(p.substr(0, p.length - 1));
    }).args(ARGS_PERCENTRANK);

    defineFunction("percentrank.exc", function(numbers, x, significance) {
        var p = _percentrank(numbers, x, 1);
        p = p.toFixed(significance + 1);
        return parseFloat(p.substr(0, p.length - 1));
    }).args(ARGS_PERCENTRANK);

    defineAlias("percentrank", "percentrank.inc");

    function _covariance(x, y, divisor) {
        var sum = 0;
        var ax = _avg(x);
        var ay = _avg(y);
        var n = x.length;
        for (var i = 0; i < n; ++i) {
            sum += (x[i] - ax) * (y[i] - ay);
        }
        return sum / divisor;
    }

    defineFunction("covariance.p", function(x, y){
        return _covariance(x, y, x.length);
    }).args([
        [ "array1", [ "collect", "number", 1 ] ],
        [ "array2", [ "collect", "number", 1 ] ],
        [ "?", [ "assert", "$array1.length == $array2.length", "N/A" ] ],
        [ "?", [ "assert", "$array1.length > 0", "DIV/0" ] ]
    ]);

    defineFunction("covariance.s", function(x, y){
        return _covariance(x, y, x.length - 1);
    }).args([
        [ "array1", [ "collect", "number", 1 ] ],
        [ "array2", [ "collect", "number", 1 ] ],
        [ "?", [ "assert", "$array1.length == $array2.length", "N/A" ] ],
        [ "?", [ "assert", "$array1.length > 1", "DIV/0" ] ]
    ]);

    defineAlias("covar", "covariance.p");

    /* -----[ Factorials ]----- */

    var _fact = util.memoize(function(n){
        for (var i = 2, fact = 1; i <= n; ++i) {
            fact *= i;
        }
        return fact;
    });

    defineFunction("fact", _fact).args([
        [ "*n", "integer+" ]
    ]);

    defineFunction("factdouble", function(n){
        for (var i = 2 + (n&1), fact = 1; i <= n; i += 2) {
            fact *= i;
        }
        return fact;
    }).args([
        [ "*n", "integer+" ]
    ]);

    defineFunction("multinomial", function(numbers){
        var div = 1, sum = 0;
        numbers.forEach(function(n){
            if (n < 0) {
                throw new CalcError("NUM");
            }
            sum += n;
            div *= _fact(n);
        });
        return _fact(sum) / div;
    }).args([
        [ "numbers", [ "collect", "number" ] ]
    ]);

    var _combinations = util.memoize(function (n, k){
        for (var f1 = k + 1, f2 = 1, p1 = 1, p2 = 1; f2 <= n - k; ++f1, ++f2) {
            p1 *= f1;
            p2 *= f2;
        }
        return p1/p2;
    });

    defineFunction("combin", _combinations).args([
        [ "*n", "integer++" ],
        [ "*k", [ "and", "integer", [ "[between]", 0, "$n" ] ] ]
    ]);

    defineFunction("combina", function(n, k){
        return _combinations(n + k - 1, n - 1);
    }).args([
        [ "*n", "integer++" ],
        [ "*k", [ "and", "integer", [ "[between]", 1, "$n" ] ] ]
    ]);

    /* -----[ Statistical functions ]----- */

    defineFunction("average", function(numbers){
        var sum = numbers.reduce(function(sum, num){
            return sum + num;
        }, 0);
        return sum / numbers.length;
    }).args([
        // most numeric functions must treat booleans as numbers (1 for TRUE
        // and 0 for FALSE), but AVERAGE shouldn't.
        [ "numbers", [ "collect", "number!" ] ],
        [ "?", [ "assert", "$numbers.length > 0", "DIV/0" ] ]
    ]);

    defineFunction("averagea", function(values){
        var sum = 0, count = 0;
        values.forEach(function(num){
            if (typeof num != "string") {
                sum += num;
            }
            ++count;
        });
        return count ? sum / count : new CalcError("DIV/0");
    }).args([
        [ "values", [ "collect", "anyvalue" ] ]
    ]);

    function _percentile(numbers, rank) {
        numbers.sort(ascending);
        var n = numbers.length;
        var k = rank | 0, d = rank - k;
        if (k === 0) {
            return numbers[0];
        }
        if (k >= n) {
            return numbers[n - 1];
        }
        --k;
        return numbers[k] + d * (numbers[k + 1] - numbers[k]);
    }

    function _percentile_inc(numbers, p){
        // algorithm from https://en.wikipedia.org/wiki/Percentile#Microsoft_Excel_method
        var rank = p * (numbers.length - 1) + 1;
        return _percentile(numbers, rank);
    }

    function _percentile_exc(numbers, p){
        // https://en.wikipedia.org/wiki/Percentile#NIST_method
        var rank = p * (numbers.length + 1);
        return _percentile(numbers, rank);
    }

    defineFunction("percentile.inc", _percentile_inc).args([
        [ "numbers", [ "collect", "number", 1 ] ],
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ]
    ]);

    defineFunction("percentile.exc", _percentile_exc).args([
        [ "numbers", [ "collect", "number", 1 ] ],
        [ "p", [ "and", "number", [ "(between)", 0, 1 ] ] ]
    ]);

    defineFunction("quartile.inc", function(numbers, quarter){
        return _percentile_inc(numbers, quarter / 4);
    }).args([
        [ "numbers", [ "collect", "number", 1 ] ],
        [ "quarter", [ "values", 0, 1, 2, 3, 4 ] ]
    ]);

    defineFunction("quartile.exc", function(numbers, quarter){
        return _percentile_exc(numbers, quarter / 4);
    }).args([
        [ "numbers", [ "collect", "number", 1 ] ],
        [ "quarter", [ "values", 0, 1, 2, 3, 4 ] ]
    ]);

    defineAlias("quartile", "quartile.inc");
    defineAlias("percentile", "percentile.inc");

    var AGGREGATE_FUNCS = [
        "AVERAGE", "COUNT", "COUNTA", "MAX", "MIN", "PRODUCT",
        "STDEV.S", "STDEV.P", "SUM", "VAR.S", "VAR.P", "MEDIAN",
        "MODE.SNGL", "LARGE", "SMALL", "PERCENTILE.INC",
        "QUARTILE.INC", "PERCENTILE.EXC", "QUARTILE.EXC"
    ];

    function fetchValuesForAggregate(self, args, options) {
        var values = [];
        var opt_ignore_hidden_rows = 1;
        var opt_ignore_errors = 2;
        var opt_use_aggregates = 4;
        (function fetchValues(args) {
            if (args instanceof Ref) {
                self.getRefCells(args, true).forEach(function(cell){
                    var value = cell.value;
                    if ((options & opt_ignore_hidden_rows) && cell.hidden) {
                        return;
                    }
                    if (cell.formula) {
                        // XXX: formula.print is fast, but still, can't we do any better here?
                        //      perhaps access the input string directly somehow?
                        var str = cell.formula.print(cell.row, cell.col);
                        if (/^\s*(?:aggregate|subtotal)\s*\(/i.test(str)) {
                            if (!(options & opt_use_aggregates)) {
                                return;
                            }
                        }
                    }
                    if ((options & opt_ignore_errors) && value instanceof CalcError) {
                        return;
                    }
                    if (typeof value == "number" || value instanceof CalcError) {
                        values.push(value);
                    }
                });
            } else if (Array.isArray(args)) {
                for (var i = 0; i < args.length; ++i) {
                    fetchValues(args[i]);
                }
            } else if (args instanceof Matrix) {
                args.each(fetchValues);
            } else if (typeof args == "number") {
                values.push(args);
            } else if (args instanceof CalcError && !(options & opt_ignore_errors)) {
                values.push(args);
            }
        })(args);
        return values;
    }

    // AGGREGATE function
    //
    // https://support.office.com/en-SG/article/aggregate-function-c8caed56-07df-4aeb-9741-23693ffbe525
    //
    // we can only partially type-check this function.  also, we need to use the async version in
    // order to resolve references and delegate values to the function to aggregate.
    defineFunction("aggregate", function(callback, funcId, options, args){
        // options is a bit field.  that makes sense; it's the documentation which doesn't.
        var self = this;
        self.resolveCells(args, function(){
            var values;
            if (funcId > 12) {
                // "array form"
                values = fetchValuesForAggregate(self, args[0], options);
                var k = args[1];
                if (k instanceof CellRef) {
                    k = self.getRefData(k);
                }
                if (typeof k != "number") {
                    return callback(new CalcError("VALUE"));
                }
            } else {
                values = fetchValuesForAggregate(self, args, options);
            }
            self.func(AGGREGATE_FUNCS[funcId - 1], callback, values);
        });
    }).argsAsync([
        [ "funcId", [ "values", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                      11, 12, 13, 14, 15, 16, 17, 18, 19 ] ],
        [ "options", [ "or",
                       [ "null", 0 ],
                       [ "values", 0, 1, 2, 3, 4, 5, 6, 7  ] ] ],
        [ "args", "rest" ]
    ]);

    defineFunction("subtotal", function(callback, funcId){
        var self = this;
        var ignoreHidden = funcId > 100;
        if (ignoreHidden) {
            funcId -= 100;
        }
        var args = [];
        for (var i = 2; i < arguments.length; ++i) {
            args.push(arguments[i]);
        }
        self.resolveCells(args, function(){
            var values = fetchValuesForAggregate(self, args, ignoreHidden ? 1 : 0);
            self.func(AGGREGATE_FUNCS[funcId - 1], callback, values);
        });
    }).argsAsync([
        [ "funcId", [ "values", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                      101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111 ] ],
        [ "+", [ "ref", [ "or", "ref", "#matrix" ] ] ]
    ]);

    // https://support.office.com/en-sg/article/AVEDEV-function-ec78fa01-4755-466c-9a2b-0c4f9eacaf6d
    defineFunction("avedev", function(numbers){
        var avg = numbers.reduce(function(sum, num){
            return sum + num;
        }, 0) / numbers.length;
        return numbers.reduce(function(sum, num){
            return sum + Math.abs(num - avg);
        }, 0) / numbers.length;
    }).args([
        [ "numbers", [ "collect", "number" ] ],
        [ "?", [ "assert", "$numbers.length >= 2", "NUM" ] ]
    ]);

    function _binom_dist(x, n, p, cumulative) {
        if (!cumulative) {
            return _combinations(n, x) * Math.pow(p, x) * Math.pow(1-p, n-x);
        } else {
            var sum = 0;
            for (var j = 0; j <= x; ++j) {
                sum += _combinations(n, j) * Math.pow(p, j) * Math.pow(1-p, n-j);
            }
            return sum;
        }
    }

    defineFunction("binom.dist", _binom_dist).args([
        [ "successes", "integer+" ],
        [ "trials", [ "and", "integer", [ "assert", "$trials >= $successes" ] ] ],
        [ "probability", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "cumulative", "logical" ]
    ]);

    defineAlias("binomdist", "binom.dist");

    defineFunction("binom.inv", function(n, p, alpha){
        // XXX: could a binary search be faster?
        for (var x = 0; x <= n; ++x) {
            if (_binom_dist(x, n, p, true) >= alpha) {
                return x;
            }
        }
        return new CalcError("N/A"); // XXX: is this right?
    }).args([
        [ "trials", "integer+" ],
        [ "probability", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "alpha", [ "and", "number", [ "[between]", 0, 1 ] ] ]
    ]);

    defineAlias("critbinom", "binom.inv");

    defineFunction("binom.dist.range", function(n, p, s, s2){
        var sum = 0;
        for (var k = s; k <= s2; ++k) {
            sum += _combinations(n, k) * Math.pow(p, k) * Math.pow(1-p, n-k);
        }
        return sum;
    }).args([
        [ "trials", "integer+" ],
        [ "probability", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "successes_min", [ "and", "integer", [ "[between]", 0, "$trials" ] ] ],
        [ "successes_max", [ "or",
                             [ "and", "integer",
                               [ "[between]", "$successes_min", "$trials" ] ],
                             [ "null", "$successes_min" ] ] ]
    ]);

    defineFunction("negbinom.dist", function(x, k, p, cumulative){
        if (cumulative) {
            var sum = 0;
            while (x >= 0) {
                sum += _combinations(x+k-1, x) * Math.pow(p, k) * Math.pow(1-p, x);
                x--;
            }
            return sum;
        }
        return _combinations(x+k-1, x) * Math.pow(p, k) * Math.pow(1-p, x);
    }).args([
        [ "number_f", "integer+" ],
        [ "number_s", "integer+" ],
        [ "probability_s", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "cumulative", "logical" ]
    ]);

    defineAlias("negbinomdist", "negbinom.dist");

    /* -----[ lookup functions ]----- */

    defineFunction("address", function(row, col, abs, a1, sheet){
        // by some lucky coincidence, we get the corret `rel` value by just subtracting 1 from the
        // abs argument
        var cell = new CellRef(row - 1, col - 1, abs - 1);
        if (sheet) {
            cell.setSheet(sheet, true);
        }
        return a1 ? cell.print(0, 0) : cell.print();
    }).args([
        [ "row", "integer++" ],
        [ "col", "integer++" ],
        [ "abs", [ "or", [ "null", 1 ], [ "values", 1, 2, 3, 4 ]]],
        [ "a1", [ "or", [ "null", true ], "logical" ]],
        [ "sheet", [ "or", "null", "string" ]]
    ]);

    defineFunction("areas", function(ref){
        var count = 0;
        (function loop(x){
            if (x instanceof CellRef || x instanceof RangeRef) {
                count++;
            } else if (x instanceof UnionRef) {
                x.refs.forEach(loop);
            }
            // XXX: NameRef if we add support
        })(ref);
        return count;
    }).args([
        [ "ref", "ref" ]
    ]);

    defineFunction("choose", function(index, args){
        if (index > args.length) {
            return new CalcError("N/A");
        } else {
            return args[index - 1];
        }
    }).args([
        [ "*index", "integer" ],
        [ "+", [ "value", "anything" ] ]
    ]);

    defineFunction("column", function(ref){
        if (!ref) {
            return this.formula.col + 1;
        }
        if (ref instanceof CellRef) {
            return ref.col + 1;
        }
        return this.asMatrix(ref).mapCol(function(col){
            return col + ref.topLeft.col + 1;
        });
    }).args([
        [ "ref", [ "or", "area", "null" ]]
    ]);

    defineFunction("columns", function(m){
        return m instanceof Ref ? m.width() : m.width;
    }).args([
        [ "ref", [ "or", "area", "#matrix" ] ]
    ]);

    defineFunction("formulatext", function(ref){
        var cell = this.getRefCells(ref)[0]; // XXX: overkill, but oh well.
        if (!cell.formula) {
            return new CalcError("N/A");
        }
        return cell.formula.print(cell.row, cell.col);
    }).args([
        [ "ref", "ref" ]
    ]);

    defineFunction("hlookup", function(value, m, row, approx){
        var resultCol = null;
        m.eachCol(function(col){
            var data = m.get(0, col);
            if (approx) {
                if (data > value) {
                    return true;
                }
                resultCol = col;
            } else if (data === value) {
                resultCol = col;
                return true;
            }
        });
        if (resultCol == null) {
            return new CalcError("N/A");
        }
        return m.get(row - 1, resultCol);
    }).args([
        [ "value", "anyvalue" ],
        [ "range", "matrix" ],
        [ "row", "integer++" ],
        [ "approx", [ "or", "logical", [ "null", true ]]]
    ]);

    defineFunction("index", function(callback, ref, row, col, areanum){
        var self = this;
        if (ref instanceof UnionRef) {
            ref = ref.refs[areanum - 1];
        }
        if ((!row && !col) || !ref) {
            return callback(new CalcError("N/A"));
        }
        if (ref instanceof CellRef) {
            ref = ref.toRangeRef();
        }
        if (ref instanceof RangeRef) {
            if (row && col) {
                if (col > ref.width() || row > ref.height()) {
                    return callback(new CalcError("REF"));
                }
                // fetching a single cell
                var cell = ref.toCell(row - 1, col - 1);
                self.resolveCells([ cell ], function(){
                    callback(self.getRefData(cell));
                });
                return;
            }
            if (!row) {
                // fetch a full column
                var colRange = ref.toColumn(col - 1);
                self.resolveCells([ colRange ], function(){
                    callback(self.asMatrix(colRange));
                });
                return;
            }
            if (!col) {
                // fetch a full row
                var rowRange = ref.toRow(row - 1);
                self.resolveCells([ rowRange ], function(){
                    callback(self.asMatrix(rowRange));
                });
                return;
            }
        }
        else if (ref instanceof Matrix) {
            if (ref.width > 1 && ref.height > 1) {
                if (row && col) {
                    return callback(ref.get(row - 1, col - 1));
                }
                if (!row) {
                    return callback(ref.mapRow(function(row){
                        return ref.get(row, col - 1);
                    }));
                }
                if (!col) {
                    return callback(ref.mapCol(function(col){
                        return ref.get(row - 1, col);
                    }));
                }
            }
            if (ref.width == 1) {
                return callback(ref.get(row - 1, 0));
            }
            if (ref.height == 1) {
                return callback(ref.get(0, col - 1));
            }
        }
        else {
            callback(new CalcError("REF"));
        }
    }).argsAsync([
        [ "range", [ "or", "ref", "matrix" ] ],
        [ "row", [ "or", "integer+", "null" ] ],
        [ "col", [ "or", "integer+", "null" ] ],
        [ "areanum", [ "or", "integer++", [ "null", 1 ] ] ]
    ]);

    defineFunction("indirect", function(thing){
        try {
            // XXX: does more work than needed.  we could go for parseReference, but that one
            // doesn't (yet?) support "SheetName!" prefix.
            var f = this.formula;
            var exp = calc.parseFormula(f.sheet, f.row, f.col, thing);
            var ref = exp.ast;
            if (ref instanceof NameRef) {
                ref = this.ss.nameValue(ref, f.sheet, f.row, f.col);
            }
            if (!(ref instanceof Ref)) {
                throw 1;
            }
            return ref.absolute(f.row, f.col);
        } catch(ex) {
            return new CalcError("REF");
        }
    }).args([
        [ "thing", "string" ]
    ]);

    // XXX: LOOKUP.  seems to be deprecated in favor of HLOOKUP/VLOOKUP

    // XXX: double-check this one.
    defineFunction("match", function(val, m, type){
        var index = 1, cmp;
        if (type === 0) {
            cmp = parseCriteria(val);
        } else if (type === -1) {
            cmp = parseCriteria("<=" + val);
        } else if (type === 1) {
            cmp = parseCriteria(">=" + val);
        }
        if (m.each(function(el){
            if (el != null && cmp(el)) {
                if (type !== 0 && val != el) {
                    --index;
                }
                return true;
            }
            index++;
        }, true) && index > 0) {
            return index;
        } else {
            return new CalcError("N/A");
        }
    }).args([
        [ "value", "anyvalue" ],
        [ "range", "matrix" ],
        [ "type", [ "or",
                    [ "values", -1, 0, 1 ],
                    [ "null", 1 ]]]
    ]);

    defineFunction("offset", function(ref, rows, cols, height, width){
        var topLeft = (ref instanceof CellRef ? ref : ref.topLeft).clone();
        topLeft.row += rows;
        topLeft.col += cols;
        if (topLeft.row < 0 || topLeft.col < 0) {
            return new CalcError("VALUE");
        }
        if (height > 1 || width > 1) {
            return new RangeRef(topLeft, new CellRef(topLeft.row + height - 1,
                                                     topLeft.col + width - 1))
                .setSheet(ref.sheet, ref.hasSheet());
        }
        return topLeft;
    }).args([
        [ "ref", "area" ],
        [ "*rows", "integer" ],
        [ "*cols", "integer" ],
        [ "*height", [ "or", "integer++", [ "null", "$ref.height()" ]]],
        [ "*width", [ "or", "integer++", [ "null", "$ref.width()" ]]]
    ]);

    defineFunction("row", function(ref){
        if (!ref) {
            return this.formula.row + 1;
        }
        if (ref instanceof CellRef) {
            return ref.row + 1;
        }
        return this.asMatrix(ref).mapRow(function(row){
            return row + ref.topLeft.row + 1;
        });
    }).args([
        [ "ref", [ "or", "area", "null" ]]
    ]);

    defineFunction("rows", function(m){
        return m instanceof Ref ? m.height() : m.height;
    }).args([
        [ "ref", [ "or", "area", "#matrix" ] ]
    ]);

    defineFunction("vlookup", function(value, m, col, approx){
        var resultRow = null;
        if (typeof value != "number") {
            approx = false;
        }
        if (typeof value == "string") {
            value = value.toLowerCase();
        }
        m.eachRow(function(row){
            var data = m.get(row, 0);
            if (approx) {
                if (data > value) {
                    return true;
                }
                resultRow = row;
            } else {
                if (typeof data == "string") {
                    data = data.toLowerCase();
                }
                if (data === value) {
                    resultRow = row;
                    return true;
                }
            }
        });
        if (resultRow == null) {
            return new CalcError("N/A");
        }
        return m.get(resultRow, col - 1);
    }).args([
        [ "value", "anyvalue" ],
        [ "range", "matrix" ],
        [ "col", "integer++" ],
        [ "approx", [ "or", "logical", [ "null", true ]]]
    ]);

    /* -----[ Date and time functions ]----- */

    defineFunction("date", function(year, month, date){
        return packDate(year, month-1, date);
    }).args([
        [ "*year", "integer" ],
        [ "*month", "integer" ],
        [ "*date", "integer" ]
    ]);

    defineFunction("day", function(date){
        return unpackDate(date).date;
    }).args([
        [ "*date", "date" ]
    ]);

    defineFunction("month", function(date){
        return unpackDate(date).month + 1;
    }).args([
        [ "*date", "date" ]
    ]);

    defineFunction("year", function(date){
        return unpackDate(date).year;
    }).args([
        [ "*date", "date" ]
    ]);

    defineFunction("weekday", function(date){
        // XXX: TODO type
        return unpackDate(date).day + 1;
    }).args([
        [ "*date", "date" ]
    ]);

    // https://support.office.com/en-GB/article/WEEKNUM-function-e5c43a03-b4ab-426c-b411-b18c13c75340
    // XXX: this is a mess.
    defineFunction("weeknum", function(date, type){
        var fw = packDate(unpackDate(date).year, 0, 1);
        var sy = unpackDate(fw);
        var diff;
        if (type == 21) {
            // Monday-based weeks, first week is the one containing the first Thursday of the year
            // we want to place in fw and sy the first Thursday
            diff = 3 - (sy.day + 6) % 7;
            if (diff < 0) {
                diff += 7;
            }
            fw += diff;
            sy.date += diff;
            sy.day = 4;         // Thursday.
            type = 1;
        } else {
            if (type == 1) {
                type = 0;
            } else if (type == 2) {
                type = 1;
            } else {
                type = (type - 10) % 7;
            }
            // finally compatible with what we got:
            // type == 0 means week starts on Sunday
            //         1                      Monday
            //         2                      Tuesday
            // ...
        }
        diff = sy.day - type;
        if (diff < 0) {
            diff += 7;
        }
        fw -= diff;
        return Math.ceil((date + 1 - fw) / 7);
    }).args([
        [ "*date", "date" ],
        [ "*type", [ "or", [ "null", 1 ],
                     [ "values", 1, 2, 11, 12, 13, 14, 15, 16, 17, 21 ] ] ]
    ]);

    function weeksInYear(year) {
        var d = unpackDate(packDate(year, 0, 1));
        if ((d.day == 4) || (d.day == 3 && runtime.isLeapYear(year))) {
            // long year
            return 53;
        }
        return 52;
    }

    defineFunction("isoweeknum", function isoweeknum(date){
        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_of_a_given_date
        var d = unpackDate(date);
        var dow = d.day || 7;
        var wk = Math.floor((d.ord - dow + 10) / 7);
        if (wk < 1) {
            return weeksInYear(d.year - 1);
        } else if (wk == 53 && wk > weeksInYear(d.year)) {
            return 1;
        }
        return wk;
    }).args([
        [ "*date", "date" ]
    ]);

    defineFunction("now", function(){
        return runtime.dateToSerial(new Date());
    }).args([]);

    defineFunction("today", function(){
        return runtime.dateToSerial(new Date()) | 0;
    }).args([]);

    defineFunction("time", function(hh, mm, ss){
        return runtime.packTime(hh, mm, ss, 0);
    }).args([
        [ "*hours", "integer" ],
        [ "*minutes", "integer" ],
        [ "*seconds", "integer" ]
    ]);

    defineFunction("hour", function(time){
        return runtime.unpackTime(time).hours;
    }).args([
        [ "*time", "datetime" ]
    ]);

    defineFunction("minute", function(time){
        return runtime.unpackTime(time).minutes;
    }).args([
        [ "*time", "datetime" ]
    ]);

    defineFunction("second", function(time){
        return runtime.unpackTime(time).seconds;
    }).args([
        [ "*time", "datetime" ]
    ]);

    defineFunction("edate", function(base, months){
        var d = unpackDate(base);
        var m = d.month + months;
        var y = d.year + Math.floor(m/12);
        m %= 12;
        if (m < 0) {
            m += 12;
        }
        d = Math.min(d.date, daysInMonth(y, m));
        return packDate(y, m, d);
    }).args([
        [ "*start_date", "date" ],
        [ "*months", "integer" ]
    ]);

    defineFunction("eomonth", function(base, months){
        var d = unpackDate(base);
        var m = d.month + months;
        var y = d.year + Math.floor(m/12);
        m %= 12;
        if (m < 0) {
            m += 12;
        }
        d = daysInMonth(y, m);
        return packDate(y, m, d);
    }).args([
        [ "*start_date", "date" ],
        [ "*months", "integer" ]
    ]);

    defineFunction("workday", function(date, n, holidays){
        // XXX: the algorithm here is pretty dumb, can we do better?
        var inc = n > 0 ? 1 : -1;
        n = Math.abs(n);
        var dow = unpackDate(date).day;
        while (n > 0) {
            date += inc;
            dow = (dow + inc) % 7;
            if (dow > 0 && dow < 6 && holidays.indexOf(date) < 0) {
                --n;
            }
        }
        return date;
    }).args([
        [ "start_date", "date" ],
        [ "days", "integer" ],
        [ "holidays", [ "collect", "date" ] ]
    ]);

    defineFunction("networkdays", function(date, end, holidays){
        // XXX: the algorithm here is pretty dumb, can we do better?
        if (date > end) {
            var tmp = date;
            date = end;
            end = tmp;
        }
        var count = 0;
        var dow = unpackDate(date).day;
        while (date <= end) {
            if (dow > 0 && dow < 6 && holidays.indexOf(date) < 0) {
                count++;
            }
            date++;
            dow = (dow + 1) % 7;
        }
        return count;
    }).args([
        [ "start_date", "date" ],
        [ "end_date", "date" ],
        [ "holidays", [ "collect", "date" ] ]
    ]);

    defineFunction("days", function(end, start){
        return end - start;
    }).args([
        [ "*start_date", "date" ],
        [ "*end_date", "date" ]
    ]);

    function _days_360(start, end, method) {
        var d1 = unpackDate(start);
        var d2 = unpackDate(end);

        // https://en.wikipedia.org/wiki/360-day_calendar
        // humanity is a mess.
        if (method) {
            // EU method
            if (d1.date == 31) {
                d1.date = 30;
            }
            if (d2.date == 31) {
                d2.date = 30;
            }
        } else {
            // US method
            if (d1.month == 1 && d2.month == 1
                && d1.date == daysInMonth(d1.year, 1)
                && d2.date == daysInMonth(d2.year, 1)) {
                d2.date = 30;
            }
            if (d1.date == daysInMonth(d1.year, d1.month)) {
                d1.date = 30;
                if (d2.date == 31) {
                    d2.date = 30;
                }
            } else {
                if (d1.date == 30 && d2.date == 31) {
                    d2.date = 30;
                }
            }
        }

        return (360 * (d2.year - d1.year)
                + 30 * (d2.month - d1.month)
                + (d2.date - d1.date));
    }

    runtime._days_360 = _days_360;

    defineFunction("days360", _days_360).args([
        [ "*start_date", "date" ],
        [ "*end_date", "date" ],
        [ "*method", [ "or", "logical", [ "null", false ] ] ]
    ]);

    defineFunction("yearfrac", function(start, end, method){
        switch (method) {
          case 0:
            return _days_360(start, end, false) / 360;
          case 1:
            return (end - start) / daysInYear(unpackDate(start).year);
          case 2:
            return (end - start) / 360;
          case 3:
            return (end - start) / 365;
          case 4:
            return _days_360(start, end, true) / 360;
        }
    }).args([
        [ "*start_date", "date" ],
        [ "*end_date", "date" ],
        [ "*method", [ "or", [ "null", 0 ], [ "values", 0, 1, 2, 3, 4 ] ] ]
    ]);

    defineFunction("datevalue", function(text){
        var date = runtime.parseDate(text);
        if (date) {
            return runtime.dateToSerial(date);
        }
        return new CalcError("VALUE");
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("timevalue", function(text){
        var m = text.toLowerCase().match(/(\d+):(\d+)(:(\d+)(\.(\d+))?)?\s*(am?|pm?)?/);
        if (m) {
            var hh = parseFloat(m[1]);
            var mm = parseFloat(m[2]);
            var ss = m[3] ? parseFloat(m[4]) : 0;
            //var ms = m[5] ? parseFloat(m[6]) : 0;
            var ampm = m[7];
            if (ampm && (hh > 12 || hh < 1)) {
                return new CalcError("VALUE");
            }
            if (/^p/.test(ampm)) {
                hh += 12;
            }
            return runtime.packTime(hh, mm, ss, 0);
        }
        return new CalcError("VALUE");
    }).args([
        [ "*text", "string" ]
    ]);

    /* -----[ Matrix functions ]----- */

    defineFunction("mdeterm", function(m){
        var error = m.each(function(val){
            if (typeof val != "number") {
                return new CalcError("VALUE");
            }
        }, true);
        return error || m.determinant();
    }).args([
        [ "m", [ "and", "matrix",
                 [ "assert", "$m.width == $m.height" ] ] ]
    ]);

    defineFunction("transpose", function(m){
        return m.transpose();
    }).args([
        [ "range", "matrix" ]
    ]);

    defineFunction("mmult", function(a, b){
        return a.multiply(b);
    }).args([
        [ "a", "matrix" ],
        [ "b", [ "and", "matrix",
                 [ "assert", "$b.height == $a.width" ] ] ]
    ]);

    defineFunction("munit", function(n){
        return new Matrix(this).unit(n);
    }).args([
        [ "n", "integer+" ]
    ]);

    defineFunction("minverse", function(m){
        var error = m.each(function(val){
            if (typeof val != "number") {
                return new CalcError("VALUE");
            }
        }, true);
        return error || m.inverse() || new CalcError("VALUE");
    }).args([
        [ "m", [ "and", "matrix",
                 [ "assert", "$m.width == $m.height" ] ] ]
    ]);

    /* -----[ Other ]----- */

    defineFunction("rand", function() {
        return Math.random();
    }).args([]);

    defineFunction("randbetween", function(min, max){
        return min + Math.floor((max - min + 1) * Math.random());
    }).args([
        [ "min", "integer" ],
        [ "max", [ "and", "integer", [ "assert", "$max >= $min" ] ] ]
    ]);

    defineFunction("true", function(){
        return true;
    }).args([]);

    defineFunction("false", function(){
        return true;
    }).args([]);

    defineFunction("roman", function(num){
        return util.arabicToRoman(num).toUpperCase();
    }).args([
        [ "*number", "integer" ]
    ]);

    defineFunction("arabic", function(rom){
        var num = util.romanToArabic(rom);
        return num == null ? new CalcError("VALUE") : num;
    }).args([
        [ "*roman", "string" ]
    ]);

    defineFunction("base", function(number, radix, minLen){
        var str = number.toString(radix).toUpperCase();
        while (str.length < minLen) {
            str = "0" + str;
        }
        return str;
    }).args([
        [ "*number", "integer" ],
        [ "*radix", [ "and", "integer", [ "[between]", 2, 36 ] ] ],
        [ "*minLen", [ "or", "integer+", [ "null", 0 ] ] ]
    ]);

    defineFunction("decimal", function(text, radix){
        text = text.toUpperCase();
        var val = 0;
        for (var i = 0; i < text.length; ++i) {
            var d = text.charCodeAt(i);
            if (d >= 48 && d <= 57) {
                d -= 48;
            } else if (d >= 65 && d < (55 + radix)) {
                d -= 55;
            } else {
                return new CalcError("VALUE");
            }
            val = val * radix + d;
        }
        return val;
    }).args([
        [ "*text", "string" ],
        [ "*radix", [ "and", "integer", [ "[between]", 2, 36 ] ] ]
    ]);

    /* -----[ String functions ]----- */

    defineFunction("char", function(code){
        return String.fromCharCode(code);
    }).args([
        [ "*code", "integer+" ]
    ]);

    // From XRegExp
    var RX_NON_PRINTABLE = /[\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u037F-\u0383\u038B\u038D\u03A2\u0528-\u0530\u0557\u0558\u0560\u0588\u058B-\u058E\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08A1\u08AD-\u08E3\u08FF\u0978\u0980\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0C00\u0C04\u0C0D\u0C11\u0C29\u0C34\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5A-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C81\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D01\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5F\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F5-\u13FF\u169D-\u169F\u16F1-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191D-\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7-\u1CFF\u1DE7-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BB-\u20CF\u20F1-\u20FF\u218A-\u218F\u23F4-\u23FF\u2427-\u243F\u244B-\u245F\u2700\u2B4D-\u2B4F\u2B5A-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E3C-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FCD-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA698-\uA69E\uA6F8-\uA6FF\uA78F\uA794-\uA79F\uA7AB-\uA7F7\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FC-\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9E0-\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAA7C-\uAA7F\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F-\uABBF\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE27-\uFE2F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]/g;

    defineFunction("clean", function(text){
        return text.replace(RX_NON_PRINTABLE, "");
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("code", function(text){
        return text.charAt(0);
    }).args([
        [ "*text", "string" ]
    ]);

    defineAlias("unichar", "char");
    defineAlias("unicode", "code");

    defineFunction("concatenate", function(args){
        var out = "";
        for (var i = 0; i < args.length; ++i) {
            out += args[i];
        }
        return out;
    }).args([
        [ "+",
          [ "*text", "string" ] ]
    ]);

    defineFunction("dollar", function(number, decimals){
        var format = "$#,##0DECIMALS;($#,##0DECIMALS)";
        var dec = "";
        var denomitator = 1;

        while (decimals-- > 0) {
          dec += "0";
        }

        while (++decimals < 0) {
          denomitator *= 10;
        }

        if (dec !== "") {
          dec = "." + dec;
        } else if (denomitator !== 1) {
            number = Math.round(number / denomitator) * denomitator;
        }

        format = format.replace(/DECIMALS/g, dec);

        return spreadsheet.formatting.text(number, format);
    }).args([
        [ "*number", "number" ],
        [ "*decimals", [ "or", "integer", [ "null", 2 ] ] ]
    ]);

    defineFunction("exact", function(a, b){
        return a === b;
    }).args([
        [ "*text1", "string" ],
        [ "*text2", "string" ]
    ]);

    defineFunction("find", function(substring, string, start){
        var pos = string.indexOf(substring, start - 1);
        return pos < 0 ? new CalcError("VALUE") : pos + 1;
    }).args([
        [ "*substring", "string" ],
        [ "*string", "string" ],
        [ "*start", [ "or", "integer++", [ "null", 1 ] ] ]
    ]);

    defineFunction("fixed", function(number, decimals, noCommas){
        var scale = Math.pow(10, decimals);
        number = Math.round(number * scale) / scale;
        var format = noCommas ? "0" : "#,##0";
        if (decimals > 0) {
            format += ".";
            while (decimals-- > 0) { format += "0"; }
        }
        return spreadsheet.formatting.text(number, format);
    }).args([
        [ "*number", "number" ],
        [ "*decimals", [ "or", "integer", [ "null", 2 ] ] ],
        [ "*noCommas", [ "or", "boolean", [ "null", false ] ] ]
    ]);

    defineFunction("left", function(text, length){
        return text.substr(0, length);
    }).args([
        [ "*text", "string" ],
        [ "*length", [ "or", "integer+", [ "null", 1 ] ] ]
    ]);

    defineFunction("right", function(text, length){
        return text.substr(-length);
    }).args([
        [ "*text", "string" ],
        [ "*length", [ "or", "integer+", [ "null", 1 ] ] ]
    ]);

    defineFunction("len", function(text){
        return text.length;
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("lower", function(text){
        return text.toLowerCase();
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("upper", function(text){
        return text.toUpperCase();
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("ltrim", function(text){
        return text.replace(/^\s+/, "");
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("rtrim", function(text){
        return text.replace(/\s+$/, "");
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("trim", function(text){
        return text.replace(/^\s+|\s+$/, "");
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("mid", function(text, start, length){
        return text.substr(start - 1, length);
    }).args([
        [ "*text", "string" ],
        [ "*start", "integer++" ],
        [ "*length", "integer+" ]
    ]);

    defineFunction("proper", function(text){
        return text.toLowerCase().replace(/\b./g, function(s){
            return s.toUpperCase();
        });
    }).args([
        [ "*text", "string" ]
    ]);

    defineFunction("replace", function(text, start, length, newText){
        return text.substr(0, --start) + newText + text.substr(start + length);
    }).args([
        [ "*text", "string" ],
        [ "*start", "integer++" ],
        [ "*length", "integer+" ],
        [ "*newText", "string" ]
    ]);

    defineFunction("rept", function(text, number){
        var out = "";
        while (number-- > 0) { out += text; }
        return out;
    }).args([
        [ "*text", "string" ],
        [ "*number", "integer+" ]
    ]);

    defineFunction("search", function(substring, string, start){
        var pos = string.toLowerCase().indexOf(substring.toLowerCase(), start - 1);
        return pos < 0 ? new CalcError("VALUE") : pos + 1;
    }).args([
        [ "*substring", "string" ],
        [ "*string", "string" ],
        [ "*start", [ "or", "integer++", [ "null", 1 ] ] ]
    ]);

    defineFunction("substitute", function(text, oldText, newText, nth){
        if (oldText === newText) {
            return text;
        }
        var a = text.split(oldText);
        if (nth == null) {
            return a.join(newText);
        }
        text = "";
        nth--;
        for (var i = 0; i < a.length; ++i) {
            text += a[i];
            if (i < a.length - 1) {
                if (i === nth) {
                    text += newText;
                } else {
                    text += oldText;
                }
            }
        }
        return text;
    }).args([
        [ "*text", "string" ],
        [ "*oldText", "string" ],
        [ "*newText", "string" ],
        [ "*nth", [ "or", "integer++", "null" ] ]
    ]);

    defineFunction("t", function(value){
        return typeof value == "string" ? value : "";
    }).args([
        [ "*value", "anyvalue" ]
    ]);

    defineFunction("text", function(value, format){
        return spreadsheet.formatting.text(value, format);
    }).args([
        [ "*value", "anyvalue" ],
        [ "*format", "string" ]
    ]);

    defineFunction("value", function(value){
        if (typeof value == "number") {
            return value;
        }
        if (typeof value == "boolean") {
            return +value;
        }
        // XXX: this is dirty.  we need it so we can parse i.e. "$12,345.50"
        value = (value+"").replace(/[$,]/g, "");
        value = parseFloat(value);
        return isNaN(value) ? new CalcError("VALUE") : value;
    }).args([
        [ "*value", "anyvalue" ]
    ]);

    function Hyperlink(link, text) {
        this.link = link;
        this.text = text;
    }
    Hyperlink.prototype.toString = function() {
        return this.text;
    };

    defineFunction("hyperlink", function(link, text){
        return new Hyperlink(link, text);
    }).args([
        [ "*link", "string" ],
        [ "*text", [ "or", "string", [ "null", "$link" ] ] ]
    ]);

    //// other misc functions

    defineFunction("iferror", function(value, valueIfError){
        return value instanceof CalcError ? valueIfError : value;
    }).args([
        [ "*value", "forced!" ],
        [ "*value_if_error", "anyvalue!" ]
    ]);

    //// utils

    var parseCriteria = (function(){
        var RXCACHE = Object.create(null);

        function makeComparator(cmp, x) {
            if (typeof x == "string") {
                var num = parseFloat(x);
                if (!isNaN(num) && num == x) {
                    x = num;
                }
            }
            return function(a) {
                var b = x;
                if (typeof a == "string" && typeof b == "string") {
                    a = a.toLowerCase();
                    b = b.toLowerCase();
                }
                return cmp(a, b);
            };
        }

        function lc(a) {
            var num, str;
            if (typeof a == "string") {
                a = a.toLowerCase();
            }
            if (/^[0-9.]+%$/.test(a)) {
                str = a.substr(0, a.length - 1);
                num = parseFloat(str);
                if (!isNaN(num) && num == str) {
                    a = num / 100;
                }
            } else if (/^[0-9.]+$/.test(a)) {
                num = parseFloat(a);
                if (!isNaN(num) && num == a) {
                    a = num;
                }
            }
            return a;
        }

        function compLT(a, b) { return lc(a) < lc(b); }
        function compLTE(a, b) { return lc(a) <= lc(b); }
        function compGT(a, b) { return lc(a) > lc(b); }
        function compGTE(a, b) { return lc(a) >= lc(b); }
        function compNE(a, b) { return !compEQ(a, b); }
        function compEQ(a, b) {
            if (b instanceof RegExp) {
                return b.test(a);
            }
            if (typeof a == "string" || typeof b == "string") {
                // if either one is string, make sure both are strings
                a = String(a);
                b = String(b);
            }
            return lc(a) == lc(b);
        }

        return function(cmp) {
            if (typeof cmp == "function") {
                return cmp;
            }
            var m;
            if ((m = /^=(.*)$/.exec(cmp))) {
                return makeComparator(compEQ, m[1]);
            }
            if ((m = /^<>(.*)$/.exec(cmp))) {
                return makeComparator(compNE, m[1]);
            }
            if ((m = /^<=(.*)$/.exec(cmp))) {
                return makeComparator(compLTE, m[1]);
            }
            if ((m = /^<(.*)$/.exec(cmp))) {
                return makeComparator(compLT, m[1]);
            }
            if ((m = /^>=(.*)$/.exec(cmp))) {
                return makeComparator(compGTE, m[1]);
            }
            if ((m = /^>(.*)$/.exec(cmp))) {
                return makeComparator(compGT, m[1]);
            }
            if (/[?*]/.exec(cmp)) {
                // has wildchars
                var rx = RXCACHE[cmp];
                if (!rx) {
                    rx = cmp.replace(/(~\?|~\*|[\]({\+\.\|\^\$\\})\[]|[?*])/g, function(s){
                        switch (s) {
                          case "~?" : return "\\?";
                          case "~*" : return "\\*";
                          case "?"  : return ".";
                          case "*"  : return ".*";
                          default   : return "\\" + s;
                        }
                    });
                    rx = RXCACHE[cmp] = new RegExp("^" + rx + "$", "i");
                }
                return makeComparator(compEQ, rx);
            }
            return makeComparator(compEQ, cmp);
        };
    })();

    function numericPredicate(val) {
        return typeof val == "number"
            || typeof val == "boolean"
            || val == null
            || val === "";
    }

    function ascending(a, b) {
        return a === b ? 0 : a < b ? -1 : 1;
    }

    function descending(a, b) {
        return a === b ? 0 : a < b ? 1 : -1;
    }

    // var m = new Matrix();
    // m.data = [[1, 2, 3], [4, 1, 6], [7, 8, 9]];
    // //m.data = [[0, 2, 1], [2, 6, 1], [1, 1, 4]];
    // //m.data = [[1,4,1,1], [1,4,0,1], [2,3,1,2], [3,2,6,4]];
    // m.width = m.height = 3;
    // var x = m.inverse();
    // x.dump();

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

// -*- fill-column: 100 -*-

(function(f, define){
    define('spreadsheet/runtime.functions.2',[ "./runtime" ], f);
})(function(){
    "use strict";

    // WARNING: removing the following jshint declaration and turning
    // == into === to make JSHint happy will break functionality.
    /* jshint eqnull:true, newcap:false, laxbreak:true, validthis:true */
    /* jshint latedef: nofunc */

    var spreadsheet = kendo.spreadsheet;
    var calc = spreadsheet.calc;
    var runtime = calc.runtime;
    var defineFunction = runtime.defineFunction;
    var CalcError = runtime.CalcError;
    var packDate = runtime.packDate;
    var unpackDate = runtime.unpackDate;
    var isLeapYear = runtime.isLeapYear;
    var daysInMonth = runtime.daysInMonth;
    var _days_360 = runtime._days_360;

    /* -----[ Spreadsheet API ]----- */

    defineFunction("ERF", function(ll, ul) {
        if (ul == null) {
            return ERF(ll);
        }
        return ERF(ul) - ERF(ll);
    }).args([
        [ "lower_limit", "number" ],
        [ "upper_limit", [ "or", "number", "null" ] ]
    ]);

    defineFunction("ERFC", ERFC).args([
        [ "x", "number" ]
    ]);

    defineFunction("GAMMALN", GAMMALN).args([
        [ "x", "number++" ]
    ]);

    defineFunction("GAMMA", GAMMA).args([
        [ "x", "number" ]
    ]);

    defineFunction("GAMMA.DIST", GAMMA_DIST).args([
        [ "x", "number+" ],
        [ "alpha", "number++" ],
        [ "beta", "number++" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("GAMMA.INV", GAMMA_INV).args([
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "alpha", "number++" ],
        [ "beta", "number++" ]
    ]);

    defineFunction("NORM.S.DIST", NORM_S_DIST).args([
        [ "z", "number" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("NORM.S.INV", NORM_S_INV).args([
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ]
    ]);

    defineFunction("NORM.DIST", NORM_DIST).args([
        [ "x", "number" ],
        [ "mean", "number" ],
        [ "stddev", "number++" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("NORM.INV", NORM_INV).args([
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "mean", "number" ],
        [ "stddev", "number++" ]
    ]);

    defineFunction("BETADIST", BETADIST).args([
        [ "x", "number" ],
        [ "alpha", "number++" ],
        [ "beta", "number++" ],
        [ "A", [ "or", "number", [ "null", 0 ] ] ],
        [ "B", [ "or", "number", [ "null", 1 ] ] ],
        [ "?", [ "assert", "$x >= $A", "NUM" ] ],
        [ "?", [ "assert", "$x <= $B", "NUM" ] ],
        [ "?", [ "assert", "$A < $B", "NUM" ] ]
    ]);

    defineFunction("BETA.DIST", BETA_DIST).args([
        [ "x", "number" ],
        [ "alpha", "number++" ],
        [ "beta", "number++" ],
        [ "cumulative", "logical" ],
        [ "A", [ "or", "number", [ "null", 0 ] ] ],
        [ "B", [ "or", "number", [ "null", 1 ] ] ],
        [ "?", [ "assert", "$x >= $A", "NUM" ] ],
        [ "?", [ "assert", "$x <= $B", "NUM" ] ],
        [ "?", [ "assert", "$A < $B", "NUM" ] ]
    ]);

    defineFunction("BETA.INV", BETA_INV).args([
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "alpha", "number++" ],
        [ "beta", "number++" ],
        [ "A", [ "or", "number", [ "null", 0 ] ] ],
        [ "B", [ "or", "number", [ "null", 1 ] ] ]
    ]);

    defineFunction("CHISQ.DIST", chisq_left).args([
        [ "x", "number+" ],
        [ "deg_freedom", "integer++" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("CHISQ.DIST.RT", chisq_right).args([
        [ "x", "number+" ],
        [ "deg_freedom", "integer++" ]
    ]);

    defineFunction("CHISQ.INV", chisq_left_inv).args([
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "deg_freedom", "integer++" ]
    ]);

    defineFunction("CHISQ.INV.RT", chisq_right_inv).args([
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "deg_freedom", "integer++" ]
    ]);

    defineFunction("CHISQ.TEST", function(ac, ex){
        return chisq_test(ac.data, ex.data);
    }).args([
        [ "actual_range", "matrix" ],
        [ "expected_range", "matrix" ],
        [ "?", [ "assert", "$actual_range.width == $expected_range.width" ] ],
        [ "?", [ "assert", "$actual_range.height == $expected_range.height" ] ]
    ]);

    defineFunction("EXPON.DIST", expon).args([
        [ "x", "number+" ],
        [ "lambda", "number++" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("POISSON.DIST", poisson).args([
        [ "x", "integer+" ],
        [ "mean", "number+" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("F.DIST", Fdist).args([
        [ "x", "number+" ],
        [ "deg_freedom1", "integer++" ],
        [ "deg_freedom2", "integer++" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("F.DIST.RT", Fdist_right).args([
        [ "x", "number+" ],
        [ "deg_freedom1", "integer++" ],
        [ "deg_freedom2", "integer++" ]
    ]);

    defineFunction("F.INV", Finv).args([
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "deg_freedom1", "integer++" ],
        [ "deg_freedom2", "integer++" ]
    ]);

    defineFunction("F.INV.RT", Finv_right).args([
        [ "p", [ "and", "number", [ "[between]", 0, 1 ] ] ],
        [ "deg_freedom1", "integer++" ],
        [ "deg_freedom2", "integer++" ]
    ]);

    defineFunction("F.TEST", Ftest).args([
        [ "array1", [ "collect", "number", 1 ] ],
        [ "array2", [ "collect", "number", 1 ] ],
        [ "?", [ "assert", "$array1.length >= 2", "DIV/0" ] ],
        [ "?", [ "assert", "$array2.length >= 2", "DIV/0" ] ]
    ]);

    defineFunction("FISHER", fisher).args([
        [ "x", [ "and", "number", [ "(between)", -1, 1 ] ] ]
    ]);

    defineFunction("FISHERINV", fisherinv).args([
        [ "y", "number" ]
    ]);

    defineFunction("T.DIST", Tdist).args([
        [ "x", "number" ],
        [ "deg_freedom", "integer++" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("T.DIST.RT", Tdist_right).args([
        [ "x", "number" ],
        [ "deg_freedom", "integer++" ]
    ]);

    defineFunction("T.DIST.2T", Tdist_2tail).args([
        [ "x", "number+" ],
        [ "deg_freedom", "integer++" ]
    ]);

    defineFunction("T.INV", Tdist_inv).args([
        [ "p", [ "and", "number", [ "(between]", 0, 1 ] ] ],
        [ "deg_freedom", "integer++" ]
    ]);

    defineFunction("T.INV.2T", Tdist_2tail_inv).args([
        [ "p", [ "and", "number", [ "(between]", 0, 1 ] ] ],
        [ "deg_freedom", "integer++" ]
    ]);

    defineFunction("T.TEST", Tdist_test).args([
        [ "array1", [ "collect", "number", 1 ] ],
        [ "array2", [ "collect", "number", 1 ] ],
        [ "tails", [ "and", "integer", [ "values", 1, 2 ] ] ],
        [ "type", [ "and", "integer", [ "values", 1, 2, 3 ] ] ],
        [ "?", [ "assert", "$type != 1 || $array1.length == $array2.length", "N/A" ] ],
        [ "?", [ "assert", "$array1.length >= 2", "DIV/0" ] ],
        [ "?", [ "assert", "$array2.length >= 2", "DIV/0" ] ]
    ]);

    defineFunction("CONFIDENCE.T", confidence_t).args([
        [ "alpha", [ "and", "number", [ "(between)", 0, 1 ] ] ],
        [ "standard_dev", "number++" ],
        [ "size", [ "and", "integer++",
                    [ "assert", "$size != 1", "DIV/0" ] ] ]
    ]);

    defineFunction("CONFIDENCE.NORM", confidence_norm).args([
        [ "alpha", [ "and", "number", [ "(between)", 0, 1 ] ] ],
        [ "standard_dev", "number++" ],
        [ "size", [ "and", "integer++" ] ]
    ]);

    defineFunction("GAUSS", gauss).args([
        [ "z", "number" ]
    ]);

    defineFunction("PHI", phi).args([
        [ "x", "number" ]
    ]);

    defineFunction("LOGNORM.DIST", lognorm_dist).args([
        [ "x", "number++" ],
        [ "mean", "number" ],
        [ "standard_dev", "number++" ],
        [ "cumulative", "logical" ]
    ]);

    defineFunction("LOGNORM.INV", lognorm_inv).args([
        [ "probability", [ "and", "number", [ "(between)", 0, 1 ] ] ],
        [ "mean", "number" ],
        [ "standard_dev", "number++" ]
    ]);

    defineFunction("PROB", prob).args([
        [ "x_range", [ "collect", "number", 1 ] ],
        [ "prob_range", [ "collect", "number", 1 ] ],
        [ "lower_limit", "number" ],
        [ "upper_limit", [ "or", "number", [ "null", "$lower_limit" ] ] ],
        [ "?", [ "assert", "$prob_range.length == $x_range.length", "N/A" ] ]
    ]);

    defineFunction("SLOPE", slope).args([
        [ "known_y", [ "collect", "number", 1 ] ],
        [ "known_x", [ "collect", "number", 1 ] ],
        [ "?", [ "assert", "$known_x.length == $known_y.length", "N/A" ] ],
        [ "?", [ "assert", "$known_x.length > 0 && $known_y.length > 0", "N/A" ] ]
    ]);

    defineFunction("INTERCEPT", intercept).args([
        [ "known_y", [ "collect", "number", 1 ] ],
        [ "known_x", [ "collect", "number", 1 ] ],
        [ "?", [ "assert", "$known_x.length == $known_y.length", "N/A" ] ],
        [ "?", [ "assert", "$known_x.length > 0 && $known_y.length > 0", "N/A" ] ]
    ]);

    defineFunction("PEARSON", pearson).args([
        [ "array1", [ "collect!", "anything", 1 ] ],
        [ "array2", [ "collect!", "anything", 1 ] ],
        [ "?", [ "assert", "$array2.length == $array1.length", "N/A" ] ],
        [ "?", [ "assert", "$array2.length > 0 && $array1.length > 0", "N/A" ] ]
    ]);

    defineFunction("RSQ", rsq).args([
        [ "known_y", [ "collect", "number", 1 ] ],
        [ "known_x", [ "collect", "number", 1 ] ],
        [ "?", [ "assert", "$known_x.length == $known_y.length", "N/A" ] ],
        [ "?", [ "assert", "$known_x.length > 0 && $known_y.length > 0", "N/A" ] ],
        [ "?", [ "assert", "$known_x.length != 1 && $known_y.length != 1", "N/A" ] ]
    ]);

    defineFunction("STEYX", steyx).args([
        [ "known_y", [ "collect", "number", 1 ] ],
        [ "known_x", [ "collect", "number", 1 ] ],
        [ "?", [ "assert", "$known_x.length == $known_y.length", "N/A" ] ],
        [ "?", [ "assert", "$known_x.length >= 3 && $known_y.length >= 3", "DIV/0" ] ]
    ]);

    defineFunction("FORECAST", forecast).args([
        [ "x", "number" ],
        [ "known_y", [ "collect", "number", 1 ] ],
        [ "known_x", [ "collect", "number", 1 ] ],
        [ "?", [ "assert", "$known_x.length == $known_y.length", "N/A" ] ],
        [ "?", [ "assert", "$known_x.length > 0 && $known_y.length > 0", "N/A" ] ]
    ]);

    defineFunction("LINEST", linest).args([
        [ "known_y", "matrix" ],
        [ "known_x", [ "or", "matrix", "null" ] ],
        [ "const", [ "or", "logical", [ "null", true ] ] ],
        [ "stats", [ "or", "logical", [ "null", false ] ] ]
    ]);

    defineFunction("LOGEST", logest).args([
        [ "known_y", "matrix" ],
        [ "known_x", [ "or", "matrix", "null" ] ],
        [ "const", [ "or", "logical", [ "null", true ] ] ],
        [ "stats", [ "or", "logical", [ "null", false ] ] ]
    ]);

    defineFunction("TREND", trend).args([
        [ "known_y", "matrix" ],
        [ "known_x", [ "or", "matrix", "null" ] ],
        [ "new_x", [ "or", "matrix", "null" ] ],
        [ "const", [ "or", "logical", [ "null", true ] ] ]
    ]);

    defineFunction("GROWTH", growth).args([
        [ "known_y", "matrix" ],
        [ "known_x", [ "or", "matrix", "null" ] ],
        [ "new_x", [ "or", "matrix", "null" ] ],
        [ "const", [ "or", "logical", [ "null", true ] ] ]
    ]);

    defineFunction("FV", FV).args([
        [ "rate", "number" ],
        [ "nper", "number" ],
        [ "pmt", [ "or", "number", [ "null", 0 ] ] ],
        [ "pv", [ "or", "number", [ "null", 0 ] ] ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ],
        [ "?", [ "assert", "$pmt || $pv" ] ]
    ]);

    defineFunction("PV", PV).args([
        [ "rate", "number" ],
        [ "nper", "number" ],
        [ "pmt", [ "or", "number", [ "null", 0 ] ] ],
        [ "fv", [ "or", "number", [ "null", 0 ] ] ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ]
    ]);

    defineFunction("PMT", PMT).args([
        [ "rate", "number" ],
        [ "nper", "number" ],
        [ "pmt", "number" ],
        [ "fv", [ "or", "number", [ "null", 0 ] ] ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ]
    ]);

    defineFunction("NPER", NPER).args([
        [ "rate", "number" ],
        [ "pmt", "number" ],
        [ "pv", "number" ],
        [ "fv", [ "or", "number", [ "null", 0 ] ] ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ]
    ]);

    defineFunction("RATE", RATE).args([
        [ "nper", "number" ],
        [ "pmt", [ "or", "number", [ "null", 0 ] ] ],
        [ "pv", "number" ],
        [ "fv", [ "or", "number", [ "null", 0 ] ] ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ],
        [ "guess", [ "or", "number++", [ "null", 0.01 ] ] ],
        [ "?", [ "assert", "$pmt || $fv" ] ]
    ]);

    defineFunction("IPMT", IPMT).args([
        [ "rate", "number" ],
        [ "per", "number++" ],
        [ "nper", "number++" ],
        [ "pv", "number" ],
        [ "fv", [ "or", "number", [ "null", 0 ] ] ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ],
        [ "?", [ "assert", "$per >= 1 && $per <= $nper" ] ]
    ]);

    defineFunction("PPMT", PPMT).args([
        [ "rate", "number" ],
        [ "per", "number++" ],
        [ "nper", "number++" ],
        [ "pv", "number" ],
        [ "fv", [ "or", "number", [ "null", 0 ] ] ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ],
        [ "?", [ "assert", "$per >= 1 && $per <= $nper" ] ]
    ]);

    defineFunction("CUMPRINC", CUMPRINC).args([
        [ "rate", "number++" ],
        [ "nper", "number++" ],
        [ "pv", "number++" ],
        [ "start_period", "number++" ],
        [ "end_period", "number++" ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ],
        [ "?", [ "assert", "$end_period >= $start_period", "NUM" ] ]
    ]);

    defineFunction("CUMIPMT", CUMIPMT).args([
        [ "rate", "number++" ],
        [ "nper", "number++" ],
        [ "pv", "number++" ],
        [ "start_period", "number++" ],
        [ "end_period", "number++" ],
        [ "type", [ "or", [ "values", 0, 1 ], [ "null", 0 ] ] ],
        [ "?", [ "assert", "$end_period >= $start_period", "NUM" ] ]
    ]);

    defineFunction("NPV", NPV).args([
        [ "rate", "number" ],
        [ "values", [ "collect", "number" ] ],
        [ "?", [ "assert", "$values.length > 0", "N/A" ] ]
    ]);

    defineFunction("IRR", IRR).args([
        [ "values", [ "collect", "number", 1 ] ],
        [ "guess", [ "or", "number", [ "null", 0.1 ] ] ]
    ]);

    defineFunction("EFFECT", EFFECT).args([
        [ "nominal_rate", "number++" ],
        [ "npery", "integer++" ]
    ]);

    defineFunction("NOMINAL", NOMINAL).args([
        [ "effect_rate", "number++" ],
        [ "npery", "integer++" ]
    ]);

    defineFunction("XNPV", XNPV).args([
        [ "rate", "number" ],
        [ "values", [ "collect", "number", 1 ] ],
        [ "dates", [ "collect", "date", 1 ] ],
        [ "?", [ "assert", "$values.length == $dates.length", "NUM" ] ]
    ]);

    defineFunction("XIRR", XIRR).args([
        [ "values", [ "collect", "number", 1 ] ],
        [ "dates", [ "collect", "date", 1 ] ],
        [ "guess", [ "or", "number", [ "null", 0.1 ] ] ],
        [ "?", [ "assert", "$values.length == $dates.length", "NUM" ] ]
    ]);

    defineFunction("ISPMT", ISPMT).args([
        [ "rate", "number" ],
        [ "per", "number++" ],
        [ "nper", "number++" ],
        [ "pv", "number" ],
        [ "?", [ "assert", "$per >= 1 && $per <= $nper" ] ]
    ]);

    defineFunction("DB", DB).args([
        [ "cost", "number" ],
        [ "salvage", "number" ],
        [ "life", "number++" ],
        [ "period", "number++" ],
        [ "month", [ "or", "number", [ "null", 12 ] ] ]
    ]);

    defineFunction("DDB", DDB).args([
        [ "cost", "number" ],
        [ "salvage", "number" ],
        [ "life", "number++" ],
        [ "period", "number++" ],
        [ "factor", [ "or", "number", [ "null", 2 ] ] ]
    ]);

    defineFunction("SLN", SLN).args([
        [ "cost", "number" ],
        [ "salvage", "number" ],
        [ "life", "number++" ]
    ]);

    defineFunction("SYD", SYD).args([
        [ "cost", "number" ],
        [ "salvage", "number" ],
        [ "life", "number++" ],
        [ "per", "number++" ]
    ]);

    defineFunction("VDB", VDB).args([
        [ "cost", "number+" ],
        [ "salvage", "number+" ],
        [ "life", "number++" ],
        [ "start_period", "number+" ],
        [ "end_period", "number+" ],
        [ "factor", [ "or", "number+", [ "null", 2 ] ] ],
        [ "no_switch", [ "or", "logical", [ "null", false ] ] ],
        [ "?", [ "assert", "$end_period >= $start_period", "NUM" ] ]
    ]);

    var COUPS_ARGS = [
        [ "settlement", "date" ],
        [ "maturity", "date" ],
        [ "frequency", [ "and", "integer", [ "values", 1, 2, 4 ] ] ],
        [ "basis", [ "or", [ "null", 0 ],
                     [ "and", "integer", [ "values", 0, 1, 2, 3, 4 ] ] ] ],
        [ "?", [ "assert", "$settlement < $maturity", "NUM" ] ]
    ];

    defineFunction("COUPDAYBS", COUPDAYBS).args(COUPS_ARGS);

    defineFunction("COUPDAYS", COUPDAYS).args(COUPS_ARGS);

    defineFunction("COUPDAYSNC", COUPDAYSNC).args(COUPS_ARGS);

    defineFunction("COUPPCD", COUPPCD).args(COUPS_ARGS);

    defineFunction("COUPNCD", COUPNCD).args(COUPS_ARGS);

    defineFunction("COUPNUM", COUPNUM).args(COUPS_ARGS);

    defineFunction("ACCRINTM", ACCRINTM).args([
        [ "issue", "date" ],
        [ "settlement", "date" ],
        [ "rate", "number++" ],
        [ "par", [ "or", [ "null", 1000 ], "number++" ] ],
        [ "basis", [ "or", [ "null", 0 ],
                     [ "and", "integer", [ "values", 0, 1, 2, 3, 4 ] ] ] ],
        [ "?", [ "assert", "$issue < $settlement", "NUM" ] ]
    ]);

    defineFunction("ACCRINT", ACCRINT).args([
        [ "issue", "date" ],
        [ "first_interest", "date" ],
        [ "settlement", "date" ],
        [ "rate", "number++" ],
        [ "par", [ "or", [ "null", 1000 ], "number++" ] ],
        [ "frequency", [ "and", "integer", [ "values", 1, 2, 4 ] ] ],
        [ "basis", [ "or", [ "null", 0 ],
                     [ "and", "integer", [ "values", 0, 1, 2, 3, 4 ] ] ] ],
        [ "calc_method", [ "or", "logical", [ "null", true ] ] ],
        [ "?", [ "assert", "$issue < $settlement", "NUM" ] ]
    ]);

    defineFunction("DISC", DISC).args([
        [ "settlement", "date" ],
        [ "maturity", "date" ],
        [ "pr", "number++" ],
        [ "redemption", "number++" ],
        [ "basis", [ "or", [ "null", 0 ],
                     [ "and", "integer", [ "values", 0, 1, 2, 3, 4 ] ] ] ],
        [ "?", [ "assert", "$settlement < $maturity", "NUM" ] ]
    ]);

    defineFunction("INTRATE", INTRATE).args([
        [ "settlement", "date" ],
        [ "maturity", "date" ],
        [ "investment", "number++" ],
        [ "redemption", "number++" ],
        [ "basis", [ "or", [ "null", 0 ],
                     [ "and", "integer", [ "values", 0, 1, 2, 3, 4 ] ] ] ],
        [ "?", [ "assert", "$settlement < $maturity", "NUM" ] ]
    ]);

    defineFunction("RECEIVED", RECEIVED).args([
        [ "settlement", "date" ],
        [ "maturity", "date" ],
        [ "investment", "number++" ],
        [ "discount", "number++" ],
        [ "basis", [ "or", [ "null", 0 ],
                     [ "and", "integer", [ "values", 0, 1, 2, 3, 4 ] ] ] ],
        [ "?", [ "assert", "$settlement < $maturity", "NUM" ] ]
    ]);

    defineFunction("PRICE", PRICE).args([
        [ "settlement", "date" ],
        [ "maturity", "date" ],
        [ "rate", "number++" ],
        [ "yld", "number++" ],
        [ "redemption", "number++" ],
        [ "frequency", [ "and", "integer", [ "values", 1, 2, 4 ] ] ],
        [ "basis", [ "or", [ "null", 0 ],
                     [ "and", "integer", [ "values", 0, 1, 2, 3, 4 ] ] ] ],
        [ "?", [ "assert", "$settlement < $maturity", "NUM" ] ]
    ]);

    defineFunction("PRICEDISC", PRICEDISC).args([
        [ "settlement", "date" ],
        [ "maturity", "date" ],
        [ "discount", "number++" ],
        [ "redemption", "number++" ],
        [ "basis", [ "or", [ "null", 0 ],
                     [ "and", "integer", [ "values", 0, 1, 2, 3, 4 ] ] ] ],
        [ "?", [ "assert", "$settlement < $maturity", "NUM" ] ]
    ]);

    /* -----[ utils ]----- */

    // function resultAsMatrix(f) {
    //     return function() {
    //         var a = f.apply(this, arguments);
    //         return this.asMatrix(a);
    //     };
    // }

    /* -----[ definitions: statistical functions ]----- */

    var MAX_IT = 300,     // Maximum allowed number of iterations
        EPS = 2.2204e-16, // Relative accuracy; 1-3*(4/3-1) = 2.220446049250313e-16
        FP_MIN = 1.0e-30, // Near the smallest representable as floating-point, number.
        f_abs = Math.abs;

    function ERF(x) {
        if (f_abs(x) >= 3.3) {
            return 1 - ERFC(x);
        }
        var S = x > 0 ? 1 : -1;
        if (S == -1) {
            x = -x;
        }
        var m = 0, an = 1;
        for (var n = 1; n < 100; n++) {
            m += an;
            an *= 2*x*x/(2*n+1);
        }
        return S*2/Math.sqrt(Math.PI)*x*Math.exp(-x*x)*m;
    }

    function ERFC(x) {
        if (f_abs(x) < 3.3) {
            return 1 - ERF(x);
        }
        var s = 1;
        if (x < 0) {
            s = -1;
            x = -x;
        }
        var frac = x;
        for (var n = 8; n >= 1; n -= 0.5) {
            frac = x + n/frac;
        }
        frac = 1 / (x + frac);
        return s == 1
            ? Math.exp(-x*x)/Math.sqrt(Math.PI)*frac
            : 2 - Math.exp(-x*x)/Math.sqrt(Math.PI)*frac;
    }

    function GAMMALN(x) { // Returns the value ln[(x)] for x > 0.
        var cof = [
            1.000000000190015, 76.18009172947146, -86.50532032941677,
            24.01409824083091, -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
        ];
        var y = x, tmp = x + 5.5, ser = cof[0];
        tmp -= (x + 0.5) * Math.log(tmp);
        for (var j = 1; j <= 6; j++) {
            y += 1;
            ser += cof[j] / y;
        }
        return -tmp + Math.log(Math.sqrt(2*Math.PI) * ser / x); // log((x)) = log((x+1)) - log(x)
    }

    function GAMMA(x) { // returns Infinity for 0 or negative _integer argument.
        if (x > 0) {
            return Math.exp(GAMMALN(x));
        }
        var pi = Math.PI, y = -x; // For x<0 we use the reflection formula: (x)(1-x) = PI / sin(PI*x)
        return -pi / (y*GAMMA(y)*Math.sin(pi*y));
    }

    function BETALN(a, b) {
        return GAMMALN(a) + GAMMALN(b) - GAMMALN(a+b);
    }

    function BETA(a, b) {
        return Math.exp(BETALN(a, b));
    }

    function gamma_inc(a, x) { // returns the normalized incomplete gamma function P(a, x); x > 0.
        return x < a+1.0 ? g_series(a, x) : 1 - g_contfrac(a, x);
    }

    function g_series(a, x) { // evaluate P(a, x) by its series representation (converges quickly for x < a+1).
        var sum = 1/a,
            frac = sum,
            ap = a;
        var gln = GAMMALN(a), n;
        for (n = 1; n <= MAX_IT; n++) {
            ap++;
            frac *= x/ap;
            sum += frac;
            if (f_abs(frac) < f_abs(sum)*EPS) {
                break; // already the last frac is too small versus the current sum value
            }
        }
        return sum * Math.exp(-x + a*Math.log(x) - gln); // e^{-x} * x^a * (a) * sum
    }

    function g_contfrac(a, x) { // Q(a, x) by its continued fraction representation (converges quickly for x > a + 1); modified Lentzs method (Numerical Recipes (The Art of Scientific Computing), 2rd Edition $5.2)
        var f = FP_MIN, c = f, d = 0, aj = 1, bj = x + 1 - a;
        var gln = GAMMALN(a);
        for (var i = 1; i <= MAX_IT; i++) {
            d = bj + aj * d;
	    if (f_abs(d) < FP_MIN) {
                d = FP_MIN;
            }
	    c = bj + aj / c;
	    if (f_abs(c) < FP_MIN) {
                c = FP_MIN;
            }
	    d = 1 / d;
	    var delta = c * d;
	    f *= delta;
    	    if (f_abs(delta - 1) < EPS) {
                break;
            }
	    bj += 2;
	    aj = -i * (i - a);
	}
	return f * Math.exp(-x - gln + a * Math.log(x));
    }

    function GAMMA_DIST(x, a, b, cumulative) { // a > 0, b > 0; x >= 0
        if (!cumulative) {
            return Math.pow(x/b, a-1)*Math.exp(-x/b)/(b*GAMMA(a)); // the PDF of the Gamma distribution
        }
        return gamma_inc(a, x/b); // (else) compute the CDF (using the incomplete Gamma function)
    }

    function GAMMA_INV(p, a, b) { // the quantile function of the Gamma distribution
	if (p === 0) {
            return 0;
        }
	if (p == 1) {
            return Infinity;
        }
	var m = 0, M = 10, x = 0, ab = a*b;
	if (ab > 1) {
            M *= ab;
        }
	for (var i = 0; i < MAX_IT; i++) {
	    x = 0.5*(m + M); // console.log(x);
	    var q = GAMMA_DIST(x, a, b, true);
	    if (f_abs(p - q) < 1e-16) {
                break;
            }
	    if (q > p) {
                M = x;
            } else {
                m = x;
            }
	}
	return x;
    }

    function NORM_S_DIST(x, cumulative) {
        if (!cumulative) {
            return Math.exp(-x*x/2)/Math.sqrt(2*Math.PI);
        }
        return 0.5 + 0.5*ERF(x/Math.sqrt(2));
    }

    function NORM_S_INV(p) { // see [1] $26.2.3 and http://home.online.no/~pjacklam/notes/invnorm/#References
        // Coefficients in rational approximations.
        var a = [-3.969683028665376e+01,  2.209460984245205e+02,
                 -2.759285104469687e+02,  1.383577518672690e+02,
                 -3.066479806614716e+01,  2.506628277459239e+00],
            b = [-5.447609879822406e+01,  1.615858368580409e+02,
                 -1.556989798598866e+02,  6.680131188771972e+01,
                 -1.328068155288572e+01],
            c = [-7.784894002430293e-03, -3.223964580411365e-01,
                 -2.400758277161838e+00, -2.549732539343734e+00,
                 4.374664141464968e+00,  2.938163982698783e+00],
            d = [ 7.784695709041462e-03,  3.224671290700398e-01,
                  2.445134137142996e+00,  3.754408661907416e+00];
        // Define break-points.
        var plow  = 0.02425,
            phigh = 1 - plow;
        var q, r;
        // Rational approximation for lower region:
        if (p < plow) {
            q = Math.sqrt(-2*Math.log(p));
            return (((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) / ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        }
        // Rational approximation for upper region:
        if (phigh < p) {
            q = Math.sqrt(-2*Math.log(1-p));
            return -(((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) / ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        }
        // Rational approximation for central region:
        q = p - 0.5;
        r = q*q;
        return (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q / (((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
    }

    function NORM_DIST(x, m, s, cumulative) {
        if (!cumulative) {
            return Math.exp(-(x-m)*(x-m)/(2*s*s))/(s*Math.sqrt(2*Math.PI)); // NORM_S_DIST((x-m)/s)/s;
        }
        return NORM_S_DIST((x-m)/s, true);
    }

    function NORM_INV(p, m, s) {
        return m + s*NORM_S_INV(p);
    }

    function betastd_pdf(x, a, b) {
        return Math.exp((a-1)*Math.log(x) + (b-1)*Math.log(1-x) - BETALN(a, b));
    }

    function betastd_cdf(x, a, b) {
        var k = Math.exp(a*Math.log(x) + b*Math.log(1-x) - BETALN(a, b));
        return x < (a+1)/(a+b+2) ? k*beta_lentz(a, b, x)/a : 1 - k*beta_lentz(b, a, 1-x)/b;
    }

    function beta_lentz(a, b, x) { // estimates continued fraction by modified Lentzs method ([2] $8.17.22)
        var m, m2;
        var aa, c, d, del, h, qab, qam, qap;
        qab = a + b; // These qs will be used in factors that occur in the coefficients d_n
        qap = a + 1;
        qam = a - 1;
        c = 1; // First step of Lentzs method.
        d = 1 - qab * x / qap;
        if (f_abs(d) < FP_MIN) {
            d = FP_MIN;
        }
        d = 1/d;
        h = d;
        for (m = 1; m <= MAX_IT; m++) {
            m2 = 2*m;
            aa = m*(b - m)*x / ((qam + m2)*(a + m2));
            d = 1 + aa*d; // One step (the even one) of the recurrence.
            if (f_abs(d) < FP_MIN) {
                d = FP_MIN;
            }
            c = 1 + aa/c;
            if (f_abs(c) < FP_MIN) {
                c = FP_MIN;
            }
            d = 1/d;
            h *= d*c;
            aa = -(a + m)*(qab + m)*x / ((a + m2)*(qap + m2));
            d = 1 + aa*d; // Next step of the recurrence (the odd one).
            if (f_abs(d) < FP_MIN) {
                d = FP_MIN;
            }
            c = 1 + aa/c;
            if (f_abs(c) < FP_MIN) {
                c = FP_MIN;
            }
            d = 1/d;
            del = d*c;
            h *= del;
            if (f_abs(del - 1) < EPS) {
                break;
            }
        }
        return h; // if(m > MAX_IT) throw new Error("a or b too big, or MAX_IT too small");
    }

    function betastd_inv(p, a, b) { // the quantile function of the standard Beta distribution
	var m = 0, M = 1, x = 0;
	for (var i = 0; i < MAX_IT; i++) {
	    x = 0.5*(m + M);
	    var q = betastd_cdf(x, a, b);
	    if (f_abs(p - q) < EPS) {
                break;
            }
	    if (q > p) {
                M = x;
            } else {
                m = x;
            }
	}
	return x;
    }

    function BETADIST(x, a, b, m, M) {
        return betastd_cdf((x-m)/(M-m), a, b);
    }

    function BETA_DIST(x, a, b, cdf, m, M) {
        if (cdf) {
            return betastd_cdf((x-m)/(M-m), a, b);
        }
        return betastd_pdf((x-m)/(M-m), a, b) / (M-m);
    }

    function BETA_INV(p, a, b, m, M) {
        return m + (M-m)*betastd_inv(p, a, b);
    }

    function chisq_left(x, n, cds) {  // CHISQ.DIST(x,deg_freedom,cumulative)
        return GAMMA_DIST(x, n/2, 2, cds);
    }

    function chisq_right(x, n) { // CHISQ.DIST.RT(x,deg_freedom)
        return 1 - chisq_left(x, n, true);
    }

    function chisq_left_inv(p, n) { // CHISQ.INV( probability, degrees_freedom )
        return GAMMA_INV(p, n/2, 2);
    }

    function chisq_right_inv(p, n) { // CHISQ.INV.RT(probability,deg_freedom)
        return chisq_left_inv(1-p, n);
    }

    function chisq_test(obsv, expect) {
        var rows = obsv.length, cols = obsv[0].length;
        var x = 0, i, j;
        for (i = 0; i < rows; i++) {
            for (j = 0; j < cols; j++) {
                var eij = expect[i][j];
                var delta = obsv[i][j] - eij;
                delta *= delta;
                x += delta/eij;
            }
        }
        var n = (rows - 1)*(cols - 1);
        return chisq_right(x, n);
    }

    function expon(x, r, cdf) { // EXPON.DIST(x, lambda, cumulative)
        if (cdf) {
            return 1 - Math.exp(-r*x);
        }
        return r * Math.exp(-r*x);
    }

    function poisson(k, m, cdf) { // POISSON.DIST(x, mean, cumulative)
        if (cdf) {
            return 1 - chisq_left(2*m, 2*(k+1), true);
        }
        //return chisq_left(2*m, 2*k, true) - chisq_left(2*m, 2*(k+1), true);
        var lnf = 0;
        for (var i = 2; i <= k; i++) {
            lnf += Math.log(i); // compute log(k!)
        }
        return Math.exp(k*Math.log(m) - m - lnf);
    }

    function Fdist(x, n, d, cdf) { //F.DIST(x,deg_freedom1,deg_freedom2,cumulative)
        if (cdf) {
            return betastd_cdf(n*x/(d+n*x), n/2, d/2);
        }
        var u = n/d;
        n /= 2; d /= 2;
        return u/BETA(n, d) * Math.pow(u*x, n-1) / Math.pow(1+u*x, n+d);
    }

    function Fdist_right(x, n, d) { // F.DIST.RT(x,deg_freedom1,deg_freedom2)
        return 1 - Fdist(x, n, d, true);
    }

    function Finv_right(p, n, d) { // F.INV.RT(probability,deg_freedom1,deg_freedom2
        return d/n*(1/BETA_INV(p, d/2, n/2, 0, 1) - 1);
    }

    function Finv(p, n, d) { // F.INV(probability,deg_freedom1,deg_freedom2
        return d/n*(1/BETA_INV(1-p, d/2, n/2, 0, 1) - 1);
    }

    function _mean(arr) {
        var me = 0, n = arr.length;
        for (var i = 0; i < n; i++) {
            me += arr[i];
        }
        return me / n;
    }

    function _var_sq(arr, m) { // returns the (n-1)-part of the sum of the squares of deviations from m (= VAR)
        var v = 0, n = arr.length;
        for (var i = 0; i < n; i++) {
            var delta = arr[i] - m;
            v += delta*delta;
        }
        return v / (n-1);
    }

    function Ftest(arr1, arr2) { // F.TEST(array1,array2)
        var n1 = arr1.length - 1, n2 = arr2.length - 1;
        var va1 = _var_sq(arr1, _mean(arr1)),
            va2 = _var_sq(arr2, _mean(arr2));
        if (!va1 || !va2) {
            throw new CalcError("DIV/0");
        }
        return 2*Fdist(va1 / va2, n1, n2, true);
    }

    function fisher(x) { // FISHER(x)
        return 0.5*Math.log((1+x)/(1-x));
    }

    function fisherinv(x) { // FISHERINV(x)
        var e2 = Math.exp(2*x);
        return (e2 - 1)/(e2 + 1);
    }

    function Tdist(x, n, cdf) { // T.DIST(x,deg_freedom, cumulative)
        if (cdf) {
            return 1 - 0.5*betastd_cdf(n/(x*x+n), n/2, 0.5);
        }
        return 1/(Math.sqrt(n)*BETA(0.5, n/2)) * Math.pow(1 + x*x/n, -(n+1)/2);
    }

    function Tdist_right(x, n) { // T.DIST.RT(x,deg_freedom)
        return 1 - Tdist(x, n, true);
    }

    function Tdist_2tail(x, n) { // T.DIST.2T(x,deg_freedom)
        if (x < 0) {
            x = -x;
        }
        return 2*Tdist_right(x, n);
    }

    function Tdist_inv(p, n) { // T.INV(probability,deg_freedom)
        var x = betastd_inv(2*Math.min(p, 1-p), n/2, 0.5); // ibetainv();
        x = Math.sqrt(n * (1 - x) / x);
        return (p > 0.5) ? x : -x;
    }

    function Tdist_2tail_inv(p, n) { // T.INV.2T(probability,deg_freedom)
        // T2 = 2T_r = p => T_r(x,n) = p/2 => 1 - T(x,n,true) = p/2 => x = T^-1(1-p/2, n)
        return Tdist_inv(1-p/2, n);
    }

    function Tdist_test(gr1, gr2, tail, type) { // T.TEST(array1,array2,tails,type)
        var n1 = gr1.length, n2 = gr2.length;
        var t_st, df; // the t-statistic and the "degree of freedom"
        if (type == 1) { // paired (dependent) samples
            var d = 0, d2 = 0;
            for (var i = 0; i < n1; i++) {
                var delta = gr1[i] - gr2[i];
                d += delta;
                d2 += delta*delta;
            }
            var md = d/n1; //, md2 = d2 / n1;
            t_st = md / Math.sqrt((d2 - d*md)/(n1*(n1-1))); // has a "Student T" distribution
            return tail == 1 ? Tdist_right(t_st, n1-1) : Tdist_2tail(t_st, n1-1);
        }
        // unpaired (independent) samples
        var m1 = _mean(gr1), m2 = _mean(gr2),
            v1 = _var_sq(gr1, m1), v2 = _var_sq(gr2, m2);
        if (type == 3) { // unpaired, unequal variances
            var u1 = v1/n1, u2 = v2/n2, u = u1 + u2;
            var q1 = u1/u, q2 = u2/u; // u==0 must be invalidated
            df = 1/(q1*q1/(n1-1) + q2*q2/(n2-1));
            t_st =  f_abs(m1-m2)/Math.sqrt(u);
            return tail == 1 ? Tdist_right(t_st, df) : Tdist_2tail(t_st, df);
        }
        else { // (type == 2) unpaired, equal variances ("equal" in the sense that there is no significant difference in variance in both groups - a prealable F-test could revealed that)
            df = n1 + n2 - 2;
            t_st = f_abs(m1-m2)*Math.sqrt(df*n1*n2/((n1+n2)*((n1-1)*v1+(n2-1)*v2)));
            return tail == 1 ? Tdist_right(t_st, df) : Tdist_2tail(t_st, df);
        }
    }

    function confidence_t(alpha, stddev, size) { // CONFIDENCE.T(alpha,standard_dev,size)
        return -Tdist_inv(alpha/2, size-1)*stddev/Math.sqrt(size);
    }

    function confidence_norm(alpha, stddev, size) { // CONFIDENCE.NORM(alpha,standard_dev,size)
        return -NORM_S_INV(alpha/2)*stddev/Math.sqrt(size);
    }

    function gauss(z) { // GAUSS(z)
        return NORM_S_DIST(z, true) - 0.5;
    }

    function phi(x) { // PHI(x)
        return NORM_S_DIST(x);
    }

    function lognorm_dist(x, m, s, cumulative) { // LOGNORM.DIST(x,mean,standard_dev,cumulative)
        if (cumulative) {
            return 0.5 + 0.5*ERF((Math.log(x)-m)/(s*Math.sqrt(2)));
        }
        var t = Math.log(x)-m;
        return Math.exp(-t*t/(2*s*s))/(x*s*Math.sqrt(2*Math.PI));
    }

    function lognorm_inv(p, m, s) { //LOGNORM.INV(probability, mean, standard_dev)
        return Math.exp(NORM_INV(p, m, s));
    }

    function prob(x_, p_, lw, up) { //PROB(x_range, prob_range, [lower_limit], [upper_limit])
        var n = x_.length;
        var s = 0, i;
        for (i = 0; i < n; i++) {
            if (p_[i] <= 0 || p_[i] > 1) {
                throw new CalcError("NUM");
            }
            s += p_[i];
        }
        if (s != 1) {
            throw new CalcError("NUM");
        }
        var res = 0;
        for (i = 0; i < n; i++) {
            var x = x_[i];
            if (x >= lw && x <= up) {
                res += p_[i];
            }
        }
        return res;
    }

    function slope(y_, x_) { // SLOPE(known_y's, known_x's)
        var mx = _mean(x_), my = _mean(y_), b1 = 0, b2 = 0;
        for (var i = 0, n = y_.length; i < n; i++) {
            var t = x_[i] - mx;
            b1 += t*(y_[i] - my);
            b2 += t*t;
        }
        return b1/b2;
    }

    function intercept(y_, x_) { // INTERCEPT(known_y's, known_x's)
        var mx = _mean(x_), my = _mean(y_);
        // return my - mx*slope(y_, x_);  //but repeating the calls for _mean()
        var b1 = 0, b2 = 0;
        for (var i = 0, n = y_.length; i < n; i++) {
            var t = x_[i] - mx;
            b1 += t*(y_[i] - my);
            b2 += t*t;
        }
        return my - b1*mx/b2;
    }

    function pearson(x_, y_) { // PEARSON(array1, array2)
        whipNumberArrays(x_, y_);
        var mx = _mean(x_), my = _mean(y_);
        var s1 = 0, s2 = 0, s3 = 0;
        for(var i = 0, n = x_.length; i < n; i++) {
            var t1 = x_[i] - mx, t2 = y_[i] - my;
            s1 += t1*t2;
            s2 += t1*t1;
            s3 += t2*t2;
        }
        return s1/Math.sqrt(s2*s3);
    }

    function rsq(x_, y_) { // RSQ(known_y's,known_x's)
        var r = pearson(x_, y_);
        return r*r;
    }

    function steyx(y_, x_) { //STEYX(known_y's, known_x's)
        var n = x_.length;
        var mx = _mean(x_), my = _mean(y_);
        var s1 = 0, s2 = 0, s3 = 0;
        for (var i = 0; i < n; i++) {
            var t1 = x_[i] - mx, t2 = y_[i] - my;
            s1 += t2*t2;
            s2 += t1*t2;
            s3 += t1*t1;
        }
        return Math.sqrt((s1 - s2*s2/s3)/(n-2));
    }

    function forecast(x, y_, x_) { //FORECAST(x, known_y's, known_x's)
        var mx = _mean(x_), my = _mean(y_);
        var s1 = 0, s2 = 0;
        for (var i = 0, n = x_.length; i < n; i++) {
            var t1 = x_[i] - mx, t2 = y_[i] - my;
            s1 += t1*t2;
            s2 += t1*t1;
        }
        if (s2 === 0) {
            throw new CalcError("N/A");
        }
        var b = s1/s2, a = my - b*mx;
        return a + b*x;
    }

    function _mat_mean(Mat) { // returns the mean value of a Matrix(n, 1)
        var n = Mat.height, sum = 0;
        for (var i=0; i < n; i++) {
            sum += Mat.data[i][0];
        }
        return sum/n;
    }

    function _mat_devsq(Mat, mean) { // returns the sum of squares of deviations for a Matrix(n, 1)
        var n = Mat.height, sq = 0;
        for (var i=0; i < n; i++) {
            var x = Mat.data[i][0] - mean;
            sq += x*x;
        }
        return sq;
    }

    function linest(Y, X, konst, stats) { // LINEST(known_y's, [known_x's], [const], [stats])
        var i = 0;

        if (!X) {
            // if not passed, X should default to array {1, 2, 3, ...} (same size as Y)
            X = Y.map(function(){ return ++i; });
        }

        if (konst) { // adding 1's column is unnecessary when const==false (meaning that y_intercept==0)
            X = X.clone();
            X.eachRow(function(row){
                X.data[row].unshift(1);
            });
            ++X.width;
        }

        var Xt = X.transpose();
        var B = Xt.multiply(X).inverse().multiply(Xt).multiply(Y); // the last square estimate of the coefficients
        var line_1 = [];
        for (i = B.height-1; i >= 0; i--) {
            line_1.push(B.data[i][0]); // regression coefficients ('slopes') and the y_intercept
        }
        if (!konst) {
            line_1.push(0); // display 0 for y_intercept, when const==false
        }
        if (!stats) {
            return this.asMatrix([ line_1 ]); // don't display statistics about the regression, when stats==false
        }

        var Y1 = X.multiply(B); // the predicted Y values
        var y_y1 = Y.adds(Y1, true); // the errors of the predictions (= Y - Y1)
        var mp = !konst? 0 : _mat_mean(Y1);
        var SSreg = _mat_devsq(Y1, mp); // The regression sum of squares
        var me = !konst? 0 : _mat_mean(y_y1);
        var SSresid = _mat_devsq(y_y1, me); // The residual sum of squares
        var line_5 = [];
        line_5.push(SSreg, SSresid);
        var R2 = SSreg / (SSreg + SSresid); // The coefficient of determination
        var degfre = Y.height - X.width; // The degrees of freedom
        var err_est = Math.sqrt(SSresid / degfre); // The standard error for the y estimate
        var line_3 = [];
        line_3.push(R2, err_est);
        var F_sta = !konst ? (R2/X.width)/((1-R2)/(degfre)) : (SSreg/(X.width-1))/(SSresid/degfre); // The F statistic
        var line_4 = [];
        line_4.push(F_sta, degfre);
        var SCP = Xt.multiply(X).inverse();
        var line_2 = [];
        for (i=SCP.height-1; i >= 0; i--) { // The standard errors (of coefficients an y-intercept)
            line_2.push(Math.sqrt(SCP.data[i][i]*SSresid/degfre));
        }
        return this.asMatrix([line_1, line_2, line_3, line_4, line_5]);
    }

    function logest(Y, X, konst, stats) { // LOGEST(known_y's, [known_x's], [const], [stats])
        return linest.call(this, Y.map(Math.log), X, konst, stats).map(Math.exp);
    }

    function trend(Y, X, W, konst) { // TREND(known_y's, [known_x's], [new_x's], [const])
        var i = 0;

        if (!X) {
            // if not passed, X should default to array {1, 2, 3, ...} (same size as Y)
            X = Y.map(function(){ return ++i; });
        }

        if (konst) { // adding 1's column is unnecessary when const==false (meaning that y_intercept==0)
            X = X.clone();
            X.eachRow(function(row){
                X.data[row].unshift(1);
            });
            ++X.width;
        }

        var Xt = X.transpose();
        var B = Xt.multiply(X).inverse().multiply(Xt).multiply(Y); // the last square estimate of the coefficients

        if (!W) {
            W = X;
        } else {
            if (konst) { // for non-zero y_intercept
                W = W.clone();
                W.eachRow(function(row){
                    W.data[row].unshift(1);
                });
                ++W.width;
            }
        }
        return W.multiply(B); // the predicted Y values for the W values
    }

    function growth(Y, X, new_X, konst) { // GROWTH(known_y's, [known_x's], [new_x's], [const])
        // = EXP(TREND(LN(Y_), X_, new_X, const))
        return trend.call(this, Y.map(Math.log), X, new_X, konst).map(Math.exp);
    }

    /*
      [1] Handbook of Mathematical Functions (NIST, 1964-2010):
      https://en.wikipedia.org/wiki/Abramowitz_and_Stegun
      http://dlmf.nist.gov/
      http://www.aip.de/groups/soe/local/numres/

      [2] https://en.wikibooks.org/wiki/Statistics/Numerical_Methods/Numerics_in_Excel
    */

    /* -----[ financial functions ]----- */

    //// find the root of a function known an initial guess (Newton's method) ////
    function root_newton(func, guess, max_it, eps) { // func(x) must return [value_F(x), value_F'(x)]
        var MAX_IT = max_it || 20, // maximum number of iterations
            EPS = eps || 1E-7; // accuracy
        var root = guess;
        for (var j = 1; j <= MAX_IT; j++) {
            var f_d = func(root),
                f = f_d[0], // the value of the function
                df = f_d[1]; // the value of the derivative
            var dx = f / df;
            root -= dx;
            if (Math.abs(dx) < EPS) {
                return root;
            }
        }
        return new CalcError("NUM");
    }


    /* https://support.office.com/en-us/article/PV-function-23879d31-0e02-4321-be01-da16e8168cbd
       if(rate==0):
       PMT * nper + PV + FV = 0
       else: //the basic equation (with six variables) implied in financial problems
       PV * (1+rate)^nper + PMT * (1+rate*type) * ((1+rate)^nper-1) / rate + FV = 0         [1]
    */



    //// FV (final or future value) ////
    /* I initially invest 1000 in a saving scheme and then at the end of each month I invest an
       extra 50. If the interest rate is 0.5% per month and I continue this process for two year,
       how much will my saving be worth: =FV(0.005, 24, -50, -1000, 0) */
    function FV(rate, nper, pmt, pv, type) { // FV(rate,nper,pmt,[pv],[type])
        var h1 = Math.pow(1+rate, nper);
        var h2 = rate ? (h1 - 1)/rate : nper;
        return -(pv * h1 + pmt * h2 * (1 + rate*type));
    }

    //// PV (present value of investment) ////
    /* If I wish to accumulate 5000 in four years time by depositing 75 per month in a fixed
       rate account with interest rate of 0.4% per month, what initial investment must I also
       make: =PV(0.004, 4*12, -75, 5000, 0) */
    function PV(rate, nper, pmt, fv, type) { // PV(rate, nper, pmt, [fv], [type])
        if (!rate) {
            return -fv - pmt*nper;
        }
        var h1 = Math.pow(1+rate, nper);
        return -(fv + pmt * (h1 - 1)/rate * (1 + rate*type)) / h1;
    }

    //// PMT monthly payments (= principal part PPMT + interest part IPMT) ////
    /* How much will the monthly repayments be if I borrow 100,000 over 20 years with an
       effective monthly interest rate is 0.5%: =PMT(0.005, 12*20, 100000, 0, 0) */
    function PMT(rate, nper, pv, fv, type) { // PMT(rate, nper, pv, [fv], [type])
        if (!rate) {
            return -(fv + pv)/nper;
        }
        var h1 = Math.pow(1+rate, nper);
        return -rate*(fv + pv*h1)/((1 + rate*type)*(h1 - 1));
    }

    //// NPER (number of periods for an investment) ////
    /* How long would it take me to pay off a loan of 10,000 at a rate of 0.5% per month if I
       can afford to pay 100 per month: =NPER(0.5%, -100, 10000, 0, 0) */
    function NPER(rate, pmt, pv, fv, type) { // NPER(rate,pmt,pv,[fv],[type])
        if (!rate) {
            return -(fv + pv) / pmt;
        }
        var h1 = pmt*(1 + rate*type);
        return Math.log((h1 - fv*rate)/(h1 + pv*rate)) / Math.log(1 + rate);
    }

    //// RATE (the interest rate per period) ////
    /* I borrow 1000 over 1 year making payments of 100 per month at the end of each
       month. What is the monthly interest rate: =RATE(12, 100, 1000, 0, 0, 0) */

    function RATE (nper, pmt, pv, fv, type, guess) { // RATE(nper, pmt, pv, [fv], [type], [guess])
        function xfd(x) { // returns F(x) and F'(x), where F is given by the equation [1]
            var h2 = Math.pow(1+x, nper-1), h1 = h2*(1+x);
            return [ pv*h1 + pmt*(1/x + type)*(h1 - 1) + fv,
                     nper*pv*h2 + pmt*(-(h1 - 1)/(x*x) + (1/x + type)*nper*h2) ];
        }
        return root_newton(xfd, guess); // a root of the equation F(x)=0
    }

    //// IPMT (interest part of a loan or investment) ////
    //// PPMT (principal part of a loan) ////

    function IPMT(rate, per, nper, pv, fv, type) { // IPMT(rate, per, nper, pv, [fv], [type])
        if(type==1 && per==1) { // interest before beginnig of the payments... = ZERO
            return 0;
        }
        var pmt = PMT(rate, nper, pv, fv, type);
        var ipmt = FV(rate, per - 1, pmt, pv, type) * rate;
        return type ? ipmt/(1 + rate) : ipmt;
    }

    function PPMT(rate, per, nper, pv, fv, type) { // PPMT(rate, per, nper, pv, [fv], [type])
        var pmt = PMT(rate, nper, pv, fv, type);
        return pmt - IPMT(rate, per, nper, pv, fv, type);
    }

    //// CUMPRINC (cumulative principal paid) ////
    /* The amount financed is $200,000 at an interest rate of 7.25% for 30 years. How much is the amount of principal
       and the amount of interest paid in the first year: CUMPRINC(0.0725/12, 12*30, 200000, 1, 12, 0)
       and CUMIPMT(0.0725/12, 12*30, 200000, 1, 12, 0) */
    function CUMPRINC(rate, nper, pv, start, end, type) { // CUMPRINC(rate, nper, pv, start_period, end_period, type)
        if(type == 1) { // start >= 1 (as in Excel), but if pay at beginning of the period (type==1),
            start --;    // then periods must be counted from Zero (decreasing given start and end parameters)
            end --;
        }
        var tn = Math.pow(1 + rate, nper),
            ts = Math.pow(1 + rate, start-1),
            te = Math.pow(1 + rate, end);
        var monthlyPayment = rate * pv * tn / (tn - 1);
        var remainingBalanceAtStart = ts * pv - ((ts - 1) / rate) * monthlyPayment;
        var remainingBalanceAtEnd = te * pv - ((te - 1) / rate) * monthlyPayment;
        return remainingBalanceAtEnd - remainingBalanceAtStart;
    }

    //// CUMIPMT (cumulative  interest paid) ////
    function CUMIPMT(rate, nper, pv, start, end, type) { // CUMIPMT(rate, nper, pv, start_period, end_period, type)
        var cip = 0;
        for(var i=start; i<=end; i++) {
            cip += IPMT(rate, i, nper, pv, 0, type);
        }
        return cip;
    }

    //// NPV (Net Present Value of an investment based on a series of periodic cash flows and a discount rate) ////
    function NPV(rate, flows) { // NPV(rate,value1,[value2],...)
        var npv = 0;
        for(var i=0, n=flows.length; i < n; i++) {
            npv += flows[i]*Math.pow(1 + rate, -i-1);
        }
        return npv;
    }

    //// IRR (Internal Rate of Return on an investment based on a series of periodic cash flows) ////
    function IRR(flows, guess) { // IRR(values, [guess])
        function xfd(x) {
            var npv = 0, npv1 = 0;
            for(var j=0, n=flows.length; j < n; j++) {
                npv += flows[j]*Math.pow(1 + x, -j-1); // construct the NPV(x) value,
                npv1 += -j*flows[j]*Math.pow(1+x, -j-2); // the value in x of the NPV()-derivative
            }
            return [npv, npv1];
        }
        return root_newton(xfd, guess);
    }

    //// EFFECT (effective annual interest rate) ////
    /* which investment option is better - one that pays 5 percent after one year, or a
       savings account that pays a monthly interest of 4.75 percent:
       = (5% - EFFECT(4.75%, 12)) * 10000 */
    function EFFECT(nominal_rate, npery) { // EFFECT(nominal_rate, npery)
        return Math.pow(1 + nominal_rate/npery, npery) - 1;
    }

    //// NOMINAL (nominal annual interest rate) ////
    function NOMINAL(effect_rate, npery) { // NOMINAL(effect_rate, npery)
        return npery*(Math.pow(effect_rate + 1, 1/npery) - 1);
    }

    //// XNPV (Net Present Value of a series of cashflows at irregular intervals) ////
    function XNPV(rate, values, dates) { // XNPV(rate, values, dates)
        var npv = 0;
        for(var i=0, n=values.length; i < n; i++) {
            npv += values[i]*Math.pow(1 + rate, (dates[0]-dates[i])/365);
        }
        return npv;
    }

    //// XIRR (Internal Rate of Return of a series of cashflows at irregular intervals) ////
    function XIRR(values, dates, guess) { // XIRR(values, dates, [guess])
        function xfd(x) {
            var npv = values[0], npv1 = 0;
            for(var j=1, n=values.length; j < n; j++) {
                var delta = (dates[0] - dates[j]) / 365;
                npv += values[j]*Math.pow(1 + x, delta); // construct the XNPV(x) value,
                npv1 += delta*values[j]*Math.pow(1+x, delta - 1); // the value in x of the XNPV()-derivative
            }
            return [npv, npv1];
        }
        return root_newton(xfd, guess); // , 100, 0.1);
    }

    //// ISPMT (Interest paid during a Specific Period of an investment) ////
    function ISPMT(rate, per, nper, pv) { // ISPMT(rate, per, nper, pv)
        var tmp = -pv*rate;
        return tmp*(1 - per/nper);
    }

    //// DB (Declining Balance depreciation) ////
    function DB(cost, salvage, life, period, month) { // DB(cost, salvage, life, period, [month])
        var rate = 1 - Math.pow(salvage/cost, 1/life);
        rate = Math.floor(rate*1000 + 0.5) / 1000; // rounded to three decimals
        var db = cost * rate * month / 12;
        if(period == 1) {
            return db;
        }
        for(var i=1; i < life; i++) {
            if(i == period - 1) {
                return (cost - db) * rate;
            }
            db += (cost - db) * rate;
        }
        return (cost - db) * rate * (12 - month) / 12;
    }

    //// DDB (Double Declining Balance depreciation) ////
    function DDB(cost, salvage, life, period, factor) { // DDB(cost, salvage, life, period, [factor])
        var f = factor / life;
        var prior = -cost * (Math.pow(1-f, period-1) - 1);
        var dep = (cost - prior) * f;
        /* Depreciation cannot exceed book value.  */
        dep = Math.min(dep, Math.max(0, cost - prior - salvage));
        return dep;
    }

    //// SLN (straight-line depreciation) ////
    function SLN(cost, salvage, life) { // SLN(cost, salvage, life)
        return (cost - salvage) / life;
    }

    //// SYD (Sum-of-Years' digits Depreciation) ////
    function SYD(cost, salvage, life, per) { // SYD(cost, salvage, life, per)
        return (cost - salvage) * (life - per + 1) * 2 / (life * (life + 1));
    }

    //// VDB (Variable Declining Balance) ////
    //
    // Code adapted from Gnumeric, which in turn took it from OpenOffice.  The original code is
    // available under GNU Lesser General Public License (LGPL).
    // https://github.com/GNOME/gnumeric/blob/master/plugins/fn-financial/sc-fin.c
    function VDB (cost, salvage, life, start, end, factor, no_switch) {
        var interest = factor >= life ? 1 : factor / life;

        function _getGDA(value, period) {
            var gda, oldValue, newValue;
            if (interest == 1) {
                oldValue = period == 1 ? value : 0;
            } else {
                oldValue = value * Math.pow(1 - interest, period - 1);
            }
            newValue = value * Math.pow(1 - interest, period);
            gda = newValue < salvage ? oldValue - salvage : oldValue - newValue;
            return gda < 0 ? 0 : gda;
        }

        function _interVDB(cost, life1, period) {
            var remValue = cost - salvage;
            var intEnd = Math.ceil(period);
            var term, lia = 0, vdb = 0, nowLia = false;
            for (var i = 1; i <= intEnd; i++) {
                if (!nowLia) {
                    var gda = _getGDA(cost, i);
                    lia = remValue / (life1 - i + 1);
                    if (lia > gda) {
                        term = lia;
                        nowLia = true;
                    } else {
                        term = gda;
                        remValue -= gda;
                    }
                } else {
                    term = lia;
                }
                if (i == intEnd) {
                    term *= period + 1 - intEnd;
                }
                vdb += term;
            }
            return vdb;
        }

        var intStart = Math.floor(start), intEnd = Math.ceil(end);
        var vdb = 0;
        if (no_switch) {
            for (var i = intStart + 1; i <= intEnd; i++) {
                var term = _getGDA(cost, i);
                if (i == intStart + 1) {
                    term *= Math.min(end, intStart + 1) - start;
                } else {
                    if (i == intEnd) {
                        term *= end + 1 - intEnd;
                    }
                }
                vdb += term;
            }
        } else {
            var life1 = life;
            if (start != Math.floor(start)) {
                if (factor > 1) {
                    if (start >= life / 2) {
                        var part = start - life / 2;
                        start = life / 2;
                        end -= part;
                        life1 += 1;
                    }
                }
            }
            cost -= _interVDB(cost, life1, start);
            vdb = _interVDB(cost, life - start, end - start);
        }
        return vdb;
    }

    /*************************************************************************************/

    /*   (from  http://beginnersinvest.about.com)
         an investor agrees to loan money to a company or government in exchange for a predetermined interest rate for a pre-determined length of time.

         If an investor wanted to buy a $25,000 Coca-Cola bond with a 30 year maturity and an 10% coupon, it would work like this: He would send in the $25,000 from his savings account and get a $25,000 engraved bond certificate in exchange. After 30 years, he would be able to get his whole $25,000 back from the Coca-Cola company (of course, he can always sell it before then if he needs the money).

         Every year, hes entitled to receive 10% interest on the money he lent, or $2,500. Since most companies in the United States pay interest semi-annually, he would likely have 60 coupons attached to his bond for $1,250 each.
         Every June 30th and December 31st, the investor would go down, clip the proper coupon, send it in, and get their money.

         Although the practice is now defunct, the terminology stuck and interest payments on bonds will forever be known as coupons.
    */


    // "Use EDATE to calculate maturity dates or due dates that fall on the same day of the month as the date of issue."
    // See also: DATEDIF, DAY, DAYS, DAY360, EOMONTH (wich can be useful to determine limits of coupon periods)
    function _edate(base, months) { // EDATE(start_date, months)
        var d = unpackDate(base);
        var m = d.month + months;
        var y = d.year + Math.floor(m/12);
        m %= 12;
        if (m < 0) {
            m += 12;
        }
        d = Math.min(d.date, daysInMonth(y, m));
        return packDate(y, m, d);
    }

    function _daysBetween(from, to, basis) {
        if (basis == 1 || basis == 2 || basis == 3) { // Actual/Actual || Actual/360 || Actual/365
            return to - from;
        }
        return _days_360(from, to, basis);
    }

    // Find coupon dates that enclose the settlement date, counting backward from the maturity date.
    /* independent of the 'basis' convention to count days - here we have no need to count days */
    function _borderCoupons(settlement, maturity, freq) {
        var sett = unpackDate(settlement), base = unpackDate(maturity);
        var periods = base.year - sett.year;
        if (periods > 0) {
            periods = (periods - 1) * freq;
        }
        var prev, next, months = 12/freq;
        do {
            periods++;
            prev = _edate(maturity, - periods*months);
        } while (settlement < prev);
        periods--;
        next = _edate(maturity, - periods*months);
        return [ prev, next ];
    }

    // Find coupon dates that enclose the settlement date, counting forward from the first-coupon payment.
    /* independent of the 'basis' convention to count days - here we have no need to count days */
    function _borderCoupons_fw(first, settlement, freq) {
        var sett = unpackDate(settlement), base = unpackDate(first);
        var periods = sett.year - base.year;
        if (periods > 0) {
            periods = (periods - 1) * freq;
        }
        var prev = first, next, months = 12/freq;
        while (settlement > prev) {
            next = prev;
            periods++;
            prev = _edate(first, periods*months);
        }
        return [ next, prev ];
    }

    //// COUPDAYBS (COUPon DAYs Beginning to Settlement) ////
    /* returns the number of days from the beginning of the coupon period to the settlement date */
    function COUPDAYBS(settlement, maturity, frequency, basis) { // COUPDAYBS(settlement, maturity, frequency, [basis])
        var prev = _borderCoupons(settlement, maturity, frequency)[0];
        return _daysBetween(prev, settlement, basis);
    }

    //// COUPDAYS (COUPon DAYs containing Settlement) ////
    /* Returns the number of days in the coupon period that contains the settlement date */
    function COUPDAYS(settl, matur, freq, basis) { // COUPDAYS(settlement, maturity, frequency, [basis])
        if (basis == 1) {
            var borders = _borderCoupons(settl, matur, freq);
            return _daysBetween(borders[0], borders[1], 1);
        }
        if (basis == 3) {
            return 365/freq;
        }
        return 360/freq;
    }

    //// COUPDAYSNC (COUPon DAYs Settlement to Next Coupon) ////
    /* Returns the number of days from the settlement date to the next coupon date */
    function COUPDAYSNC(settl, matur, freq, basis) { // COUPDAYSNC(settlement, maturity, frequency, [basis])
        var next = _borderCoupons(settl, matur, freq)[1];
        return _daysBetween(settl, next, basis);
    }

    //// COUPPCD (COUPon, Previous Coupon Date) ////
    /* Returns the previous coupon date before the settlement date */
    function COUPPCD(settl, matur, freq/*, basis*/) { // COUPPCD(settlement, maturity, frequency, [basis])
        // It is no need to count days, so 'basis' becomes a inutil parameter.
        return _borderCoupons(settl, matur, freq)[0];
    }

    //// COUPNCD (COUPon, Next Coupon Date) ////
    /* Returns the next coupon date after the settlement date */
    function COUPNCD(settl, matur, freq/*, basis*/) { // COUPNCD(settlement, maturity, frequency, [basis])
        // It is no need to count days, so 'basis' becomes a inutil parameter.
        return _borderCoupons(settl, matur, freq)[1];
    }

    function COUPNUM(settl, matur, freq/*, basis*/) { // COUPNUM(settlement, maturity, frequency, [basis])
        var sett = unpackDate(settl),
            mat = unpackDate(matur);
        var months = 12*(mat.year - sett.year) + mat.month - sett.month;
        //// Discount the last month if there are not enough days? Finally - we decide to not discount.
        //// (if this "last month" have 2 days, Excel.COUPNUM returns 6 but GoogleSpreads give only 5)
        //    var res = _edate(matur, -months);
        //    if (sett.date >= unpackDate(res).date) {
        //        months--; // an incomplete last month correspond to a qvasi-coupon period
        //    }
        return 1 + (months * freq / 12 | 0);
    }

    function daysInYear(yr, basis) {
        if (basis == 3) { return 365; }
        if (basis == 1) { return isLeapYear(yr) ? 366 : 365; }
        return 360;
    }

    //// ACCRINTM  the accrued interest for a security that pays interest at maturity ////
    function ACCRINTM(issue, maturity, rate, par, basis) { // ACCRINTM(issue, settlement, rate, par, [basis])
        var year_days = daysInYear(unpackDate(maturity).year, basis); // 360;
        return rate*par * _daysBetween(issue, maturity, basis) / year_days;
    }

    function ACCRINT(issue, first, settl, rate, par, freq, basis, calc) {
        var accr = 0, cost = par * rate / freq;
        var brace, prev, next, prev1, next1, nrc;

        var annual = basis % 2 === 0 ? 360 : 365; // only if to >> from, we eventually need to count leap years
        function _numCoupons(from, to) { // better than COUPNUM(from, to, freq, basis)-1
            return (to - from)*freq/annual | 0;
        }

        if (settl <= first) {
            brace = _borderCoupons(settl, first, freq);
            prev = brace[0];
            next = brace[1];
            if (prev <= issue) {
                return cost * _daysBetween(issue, settl, basis) / _daysBetween(prev, next, basis);
            }
            brace = _borderCoupons(issue, prev, freq);
            prev1 = brace[0];
            next1 = brace[1];
            nrc = _numCoupons(next1, settl); // when settl==next, days are counted implicitly by nrc
            return cost *
                (nrc +
                 _daysBetween(issue, next1, basis) / _daysBetween(prev1, next1, basis) +
                 (settl < next? _daysBetween(prev, settl, basis) / _daysBetween(prev, next, basis) : 0));
        } else {
            brace = _borderCoupons_fw(first, settl, freq);
            prev = brace[0];
            next = brace[1];
            nrc = _numCoupons(first, settl); // COUPNUM(first, settl, freq, basis) - 1;
            if (next == settl) {
                accr = cost * nrc;
            } else {
                accr = cost * (nrc + _daysBetween(prev, settl, basis) / _daysBetween(prev, next, basis));
            }
            if (!calc) { return accr; } // Only the accrued interest between first and settlement dates.
            brace = _borderCoupons(issue, first, freq); // Add the accrued interest between issue and first dates.
            prev = brace[0];
            next = brace[1];
            nrc = _numCoupons(issue, first);
            accr += cost * (nrc + _daysBetween(issue, next, basis) / _daysBetween(prev, next, basis));
            return accr; // accrued interest between issue and settlement dates
        }
    }

    //// DISC  the discount rate for a security (given price and redemption values per 100$ face value) ////
    function DISC(settl, matur, pr, redemption, basis) { // DISC(settlement, maturity, pr, redemption, [basis])
        var annual = basis % 2 === 0 ? 360 : (isLeapYear(unpackDate(settl).year) ? 366 : 365);
        return (redemption - pr)/redemption*annual/_daysBetween(settl, matur, basis);
    }

    //// INTRATE  the interest rate for a fully invested security ////
    function INTRATE(settl, matur, investment, redemption, basis) { // INTRATE(settlement, maturity, investment, redemption, [basis])
        var annual = basis % 2 === 0 ? 360 : (isLeapYear(unpackDate(settl).year) ? 366 : 365);
        return (redemption - investment)/investment*annual/_daysBetween(settl, matur, basis);
    }

    //// RECEIVED  the amount received at maturity for a fully invested security ////
    function RECEIVED(settl, matur, investment, discount, basis) { // RECEIVED(settlement, maturity, investment, discount, [basis])
        var annual = basis % 2 === 0 ? 360 : (isLeapYear(unpackDate(settl).year) ? 366 : 365);
        return investment/(1 - discount*_daysBetween(settl, matur, basis)/annual);
    }

    //// PRICE  the price per $100 face value of a security that pays periodic interest ////
    function PRICE(settl, matur, rate, yld, redemption, freq, basis) { // PRICE(settlement, maturity, rate, yld, redemption, frequency, [basis])
        var N = 1 + ((matur - settl)*freq/(basis % 2 === 0 ? 360 : 365) | 0); // coupons playable between settlement and maturity dates
        var brace = _borderCoupons(settl, matur, freq),
            prev = brace[0], next = brace[1];
        var beg_settl = _daysBetween(prev, settl, basis),
            settl_end = _daysBetween(settl, next, basis),
            beg_end = _daysBetween(prev, next, basis);
        var den = 100*rate/freq,
            yf = yld/freq,
            frac = settl_end / beg_end;
        if (N == 1) {
            return (redemption + den)/(1 + frac*yf) - beg_settl / beg_end * den;
        }
        return redemption / Math.pow(1 + yf, N-1+frac)
            + den * Math.pow(1 + yf, 1-N-frac) * (Math.pow(1+yf, N) - 1) / yf
            - beg_settl / beg_end * den;
    }

    //// PRICEDISC  the price per $100 face value of a discounted security ////
    function PRICEDISC(settl, matur, discount, redemption, basis) { // PRICEDISC(settlement, maturity, discount, redemption, [basis])
        var dsm = _daysBetween(settl, matur, basis),
            dy = daysInYear(unpackDate(matur).year, basis);
        return redemption - discount*redemption*dsm/dy;
    }

    // Used in PEARSON, more could follow.  In some situations Excel appears to silently ignore
    // missing or non-numeric values, for example if some value in a is missing a corresponding
    // value in b, then the one in a is going to be ignored as if not present.  Arrays must have the
    // same number of elements.  I couldn't come up with a good name for this function.
    function whipNumberArrays(a, b) {
        for (var i = a.length; --i >= 0;) {
            if (typeof a[i] != "number" || typeof b[i] != "number") {
                a.splice(i, 1);
                b.splice(i, 1);
            }
        }
    }

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/borderpalette',[ "../kendo.core", "../kendo.colorpicker", "../kendo.popup" ], f);
})(function(){

    (function(kendo) {

        var $ = kendo.jQuery;
        var BORDER_TYPES = [
            "allBorders",
            "insideBorders",
            "insideHorizontalBorders",
            "insideVerticalBorders",
            "outsideBorders",
            "leftBorder",
            "topBorder",
            "rightBorder",
            "bottomBorder",
            "noBorders"
        ];

        var BORDER_PALETTE_MESSAGES = kendo.spreadsheet.messages.borderPalette = {
            allBorders: "All borders",
            insideBorders: "Inside borders",
            insideHorizontalBorders: "Inside horizontal borders",
            insideVerticalBorders: "Inside vertical borders",
            outsideBorders: "Outside borders",
            leftBorder: "Left border",
            topBorder: "Top border",
            rightBorder: "Right border",
            bottomBorder: "Bottom border",
            noBorders: "No border"
        };

        var COLOR_PICKER_MESSAGES = kendo.spreadsheet.messages.colorPicker = {
            reset: "Reset color",
            customColor: "Custom color...",
            apply: "Apply",
            cancel: "Cancel"
        };

        function withPreventDefault(f) {
            return function(e) {
                e.preventDefault();
                return f.apply(this, arguments);
            };
        }

        var ColorChooser = kendo.ui.Widget.extend({
            init: function(element, options) {
                kendo.ui.Widget.call(this, element, options);

                this.element = element;
                this.color = options.color;

                this._resetButton();
                this._colorPalette();
                this._customColorPalette();
                this._customColorButton();

                this.resetButton.on("click", withPreventDefault(this.resetColor.bind(this)));
                this.customColorButton.on("click", withPreventDefault(this.customColor.bind(this)));
            },

            options: {
                name: "ColorChooser"
            },

            events: [
                "change"
            ],

            destroy: function() {
                kendo.unbind(this.dialog.element.find(".k-action-buttons"));
                this.dialog.destroy();
                this.colorPalette.destroy();
                this.resetButton.off("click");
                this.customColorButton.off("click");
            },

            value: function(value) {
                if (value !== undefined) {
                    this.color = value;
                    this.customColorButton.find(".k-icon").css("background-color", this.color);
                    this.colorPalette.value(null);
                    this.flatColorPicker.value(this.color);
                } else {
                    return this.color;
                }
            },

            _change: function(value) {
                this.color = value;
                this.trigger("change", { value: value });
            },

            _colorPalette: function() {
                var element = $("<div />", {
                    "class": "k-spreadsheet-color-palette"
                });

                var colorPalette = this.colorPalette = $("<div />").kendoColorPalette({
                    palette: [ //metro palette
                        "#ffffff", "#000000", "#d6ecff", "#4e5b6f", "#7fd13b", "#ea157a", "#feb80a", "#00addc", "#738ac8", "#1ab39f",
                        "#f2f2f2", "#7f7f7f", "#a7d6ff", "#d9dde4", "#e5f5d7", "#fad0e4", "#fef0cd", "#c5f2ff", "#e2e7f4", "#c9f7f1",
                        "#d8d8d8", "#595959", "#60b5ff", "#b3bcca", "#cbecb0", "#f6a1c9", "#fee29c", "#8be6ff", "#c7d0e9", "#94efe3",
                        "#bfbfbf", "#3f3f3f", "#007dea", "#8d9baf", "#b2e389", "#f272af", "#fed46b", "#51d9ff", "#aab8de", "#5fe7d5",
                        "#a5a5a5", "#262626", "#003e75", "#3a4453", "#5ea226", "#af0f5b", "#c58c00", "#0081a5", "#425ea9", "#138677",
                        "#7f7f7f", "#0c0c0c", "#00192e", "#272d37", "#3f6c19", "#750a3d", "#835d00", "#00566e", "#2c3f71", "#0c594f"
                    ],
                    value: this.color,
                    change: function(e) {
                        this.customColorButton.find(".k-icon").css("background-color", "transparent");
                        this.flatColorPicker.value(null);
                        this._change(e.value);
                    }.bind(this)
                }).data("kendoColorPalette");

                element
                    .append(colorPalette.wrapper)
                    .appendTo(this.element);
            },

            _customColorPalette: function() {
                var element = $("<div />", {
                    "class": "k-spreadsheet-window",
                    "html": "<div></div>" +
                            "<div class='k-action-buttons'>" +
                                "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-" + kendo.ns + "bind='click: apply'><span class='k-button-text'>" + COLOR_PICKER_MESSAGES.apply + "</span></button>" +
                                "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-" + kendo.ns + "bind='click: close'><span class='k-button-text'>" + COLOR_PICKER_MESSAGES.cancel + "</span></button>" +
                            "</div>"
                });

                var dialog = this.dialog = element.appendTo(document.body).kendoWindow({
                    animation: false,
                    scrollable: false,
                    resizable: false,
                    maximizable: false,
                    modal: true,
                    visible: false,
                    width: "auto",
                    open: function() {
                        this.center();
                    }
                }).data("kendoWindow");

                dialog.one("activate", function() {
                    this.element.find("[" + kendo.attr("role") + "=flatcolorpicker]").data("kendoFlatColorPicker")._view._hueSlider.resize();
                });

                var flatColorPicker = this.flatColorPicker = dialog.element.children().first().kendoFlatColorPicker().data("kendoFlatColorPicker");

                var viewModel = kendo.observable({
                    apply: function() {
                        this.customColorButton.find(".k-icon").css("background-color", flatColorPicker.value());
                        this.colorPalette.value(null);
                        this._change(flatColorPicker.value());
                        dialog.close();
                    }.bind(this),
                    close: function() {
                        flatColorPicker.value(null);
                        dialog.close();
                    }
                });

                kendo.bind(dialog.element.find(".k-action-buttons"), viewModel);
            },

            _resetButton: function() {
                this.resetButton = $("<a role='button' class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-reset-color' href='#'>" +
                                    "<span class='k-button-icon k-icon k-i-reset-color'></span>" +
                                    '<span class="k-button-text">' + COLOR_PICKER_MESSAGES.reset + '</span>' +
                                   "</a>").appendTo(this.element);
            },

            _customColorButton: function() {
                this.customColorButton = $("<a role='button' class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-custom-color' href='#'>" +
                                            "<span class='k-button-icon k-icon'></span>" +
                                            '<span class="k-button-text">' + COLOR_PICKER_MESSAGES.customColor + '</span>' +
                                           "</a>").appendTo(this.element);
            },

            resetColor: function() {
                this.colorPalette.value(null);
                this.flatColorPicker.value(null);
                this._change(null);
            },

            customColor: function() {
                this.dialog.open();
            }

        });

        var BorderPalette = kendo.ui.Widget.extend({
            init: function(element, options) {
                kendo.ui.Widget.call(this, element, options);

                this.element = element;
                this.color = "#000";

                this.element.addClass("k-spreadsheet-border-palette");

                this._borderTypePalette();
                this._borderColorPalette();

                this.element.on("click", ".k-spreadsheet-border-type-palette .k-button", withPreventDefault(this._click.bind(this)));
            },

            options: {
                name: "BorderPalette"
            },

            events: [
                "change"
            ],

            destroy: function() {
                this.colorChooser.destroy();
                this.element.off("click");
            },

            _borderTypePalette: function() {
                var messages = BORDER_PALETTE_MESSAGES;
                var buttons = BORDER_TYPES.map(function(type) {
                    return '<a role="button" title="' + messages[type] + '" aria-label="' + messages[type] + '" href="#" data-border-type="' + type + '" class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button">' +
                                '<span class="k-button-icon k-icon k-i-' + kendo.toHyphens(type) + '"></span>' +
                           '</a>';
                }).join("");

                var element = $("<div />", {
                    "class": "k-spreadsheet-border-type-palette",
                    "html": buttons
                });

                element.appendTo(this.element);
            },

            _borderColorPalette: function() {
                var element = $("<div />", {
                    "class": "k-spreadsheet-border-color-palette"
                });

                element.appendTo(this.element);

                this.colorChooser = new ColorChooser(element, {
                    color: this.color,
                    change: this._colorChange.bind(this)
                });
            },

            _click: function(e) {
                this.type = $(e.currentTarget).data("borderType");
                this.trigger("change", { type: this.type, color: this.color });
            },

            _colorChange: function(e) {
                this.color = e.value;
                if (this.type) {
                    this.trigger("change", { type: this.type, color: this.color });
                }
            }
        });

        kendo.spreadsheet.ColorChooser = ColorChooser;
        kendo.spreadsheet.BorderPalette = BorderPalette;

    })(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/toolbar',[ "../kendo.toolbar", "../kendo.colorpicker", "../kendo.combobox", "../kendo.dropdownlist", "../kendo.popup", "./borderpalette" ], f);
})(function(){

(function(kendo) {

    /* jshint eqnull:true */

    var $ = kendo.jQuery;

    var ToolBar = kendo.ui.ToolBar;

    var MESSAGES = kendo.spreadsheet.messages.toolbar = {
        addColumnLeft: "Add column left",
        addColumnRight: "Add column right",
        addRowAbove: "Add row above",
        addRowBelow: "Add row below",
        alignment: "Alignment",
        alignmentButtons: {
            justtifyLeft: "Align left",
            justifyCenter: "Center",
            justifyRight: "Align right",
            justifyFull: "Justify",
            alignTop: "Align top",
            alignMiddle: "Align middle",
            alignBottom: "Align bottom"
        },
        backgroundColor: "Background",
        bold: "Bold",
        borders: "Borders",
        copy: "Copy",
        cut: "Cut",
        deleteColumn: "Delete column",
        deleteRow: "Delete row",
        filter: "Filter",
        fontFamily: "Font",
        fontSize: "Font size",
        format: "Custom format...",
        formatTypes: {
            automatic: "Automatic",
            text: "Text",
            number: "Number",
            percent: "Percent",
            financial: "Financial",
            currency: "Currency",
            date: "Date",
            time: "Time",
            dateTime: "Date time",
            duration: "Duration",
            moreFormats: "More formats..."
        },
        formatDecreaseDecimal: "Decrease decimal",
        formatIncreaseDecimal: "Increase decimal",
        freeze: "Freeze panes",
        freezeButtons: {
            freezePanes: "Freeze panes",
            freezeRows: "Freeze rows",
            freezeColumns: "Freeze columns",
            unfreeze: "Unfreeze panes"
        },
        insertComment: "Insert comment",
        insertImage: "Insert image",
        italic: "Italic",
        merge: "Merge cells",
        mergeButtons: {
            mergeCells: "Merge all",
            mergeHorizontally: "Merge horizontally",
            mergeVertically: "Merge vertically",
            unmerge: "Unmerge"
        },
        open: "Open...",
        paste: "Paste",
        quickAccess: {
            redo: "Redo",
            undo: "Undo"
        },
        exportAs: "Export...",
        toggleGridlines: "Toggle gridlines",
        sort: "Sort",
        sortButtons: {
            // sortSheetAsc: "Sort sheet A to Z",
            // sortSheetDesc: "Sort sheet Z to A",
            sortRangeAsc: "Sort range A to Z",
            sortRangeDesc: "Sort range Z to A"
        },
        textColor: "Text Color",
        textWrap: "Wrap text",
        underline: "Underline",
        validation: "Data validation...",
        hyperlink: "Link"
    };

    var defaultTools = {
        home: [
            "open",
            "exportAs",
            [ "cut", "copy", "paste" ],
            [ "bold", "italic", "underline" ], "hyperlink", "insertComment", "insertImage",
            "backgroundColor", "textColor",
            "borders",
            "fontSize", "fontFamily",
            "alignment",
            "textWrap",
            [ "formatDecreaseDecimal", "formatIncreaseDecimal" ],
            "format",
            "merge",
            "freeze",
            "filter",
            "toggleGridlines"
        ],
        insert: [
            [ "addColumnLeft", "addColumnRight", "addRowBelow", "addRowAbove" ],
            [ "deleteColumn", "deleteRow" ]
        ],
        data: [
            "sort",
            "filter",
            "validation"
        ]
    };

    var toolDefaults = {
        //home tab
        open:                  { type: "open",                                     overflow: "never",                          iconClass: "file-excel" },
        exportAs:              { type: "exportAsDialog", dialogName: "exportAs",   overflow: "never",       text: "",        iconClass: "file-excel" },
        bold:                  { type: "button", command: "PropertyChangeCommand", property: "bold",          value: true,     iconClass: "bold", togglable: true },
        italic:                { type: "button", command: "PropertyChangeCommand", property: "italic",        value: true,     iconClass: "italic", togglable: true },
        underline:             { type: "button", command: "PropertyChangeCommand", property: "underline",     value: true,     iconClass: "underline", togglable: true },
        formatDecreaseDecimal: { type: "button", command: "AdjustDecimalsCommand",                            value: -1,       iconClass: "decimal-decrease" },
        formatIncreaseDecimal: { type: "button", command: "AdjustDecimalsCommand",                            value: +1,       iconClass: "decimal-increase" },
        textWrap:              { type: "button", command: "TextWrapCommand",       property: "wrap",          value: true,     iconClass: "text-wrap", togglable: true },
        cut:                   { type: "button", command: "ToolbarCutCommand",                                                 iconClass: "cut" },
        copy:                  { type: "button", command: "ToolbarCopyCommand",                                                iconClass: "copy" },
        paste:                 { type: "button", command: "ToolbarPasteCommand",                                               iconClass: "paste" },
        separator:             { type: "separator" },
        alignment:             { type: "alignment",                           iconClass: "align-left" },
        backgroundColor:       { type: "colorPicker", property: "background", iconClass: "paint" },
        textColor:             { type: "colorPicker", property: "color",      iconClass: "foreground-color" },
        fontFamily:            { type: "fontFamily",  property: "fontFamily", iconClass: "font-family" },
        fontSize:              { type: "fontSize",    property: "fontSize",   iconClass: "font-size" },
        format:                { type: "format",      property: "format",     iconClass: "custom-format" },
        filter:                { type: "filter",      property: "hasFilter",  iconClass: "filter" },
        merge:                 { type: "merge",                               iconClass: "cells-merge" },
        freeze:                { type: "freeze",                              iconClass: "pane-freeze" },
        borders:               { type: "borders",                             iconClass: "borders-all" },
        formatCells:           { type: "dialog", dialogName: "formatCells", overflow: "never" },
        hyperlink:             { type: "dialog", dialogName: "hyperlink", iconClass: "link-horizontal", overflow: "never", text: "" },
        toggleGridlines:       { type: "button", command: "GridLinesChangeCommand", property: "gridLines", value: true, iconClass: "border-no", togglable: true },
        insertComment:         { type: "dialog", dialogName: "insertComment", property: "comment", togglable: true, overflow: "never", iconClass: "comment", text: "" },
        insertImage:           { type: "dialog", dialogName: "insertImage", overflow: "never", iconClass: "image", text: "" },

        //insert tab
        addColumnLeft:         { type: "button", command: "AddColumnCommand",    value: "left",  iconClass: "table-column-insert-left"  },
        addColumnRight:        { type: "button", command: "AddColumnCommand",    value: "right", iconClass: "table-column-insert-right" },
        addRowBelow:           { type: "button", command: "AddRowCommand",       value: "below", iconClass: "table-row-insert-below"    },
        addRowAbove:           { type: "button", command: "AddRowCommand",       value: "above", iconClass: "table-row-insert-above"    },
        deleteColumn:          { type: "button", command: "DeleteColumnCommand",                 iconClass: "table-column-delete"    },
        deleteRow:             { type: "button", command: "DeleteRowCommand",                    iconClass: "table-row-delete"       },

        //data tab
        sort:                  { type: "sort", iconClass: "sort-desc" },
        validation:            { type: "dialog", dialogName: "validation", iconClass: "exception", overflow: "never" }
    };

    var SpreadsheetToolBar = ToolBar.extend({
        init: function(element, options) {
            options.items = this._expandTools(options.tools || SpreadsheetToolBar.prototype.options.tools[options.toolbarName]);

            ToolBar.fn.init.call(this, element, options);
            var handleClick = this._click.bind(this);

            this.element.addClass("k-spreadsheet-toolbar");

            this._addSeparators(this.element);
            var that = this;
            this.element.on("keydown", function (e) {
                var tool;
                if (e.keyCode === 9) {
                    tool = that._nextTool(e.shiftKey ? -1 : 1);
                    if (tool) {
                        document.activeElement.blur();
                        if ($(tool).is(".k-upload-button")) {
                            $(tool).addClass("k-focus");
                        }
                        if($(tool).find("input").length) {
                            $(tool).find("input").trigger("focus");
                        } else {
                            tool.focus();
                        }
                        e.preventDefault();
                    }
                }
            });

            this.element.on("focusout", function () {
                $(this).find(".k-toolbar-first-visible").removeClass("k-focus");
            });

            this.bind({
                click: handleClick,
                toggle: handleClick
            });
        },
        _nextTool: function (direction) {
            var that = this;
            var tools = that.element.find(".k-dropdownlist, .k-combobox, .k-button, .k-button-group > a").not("[tabindex=-1]");
            var activeIndex = tools.index($(document.activeElement).closest(".k-dropdownlist, .k-combobox, .k-button, .k-button-group > a").not("[tabindex=-1]"));
            if (activeIndex > 0) {
                return tools[activeIndex + direction];
            }
        },
        _addSeparators: function(element) {
            var groups = element.children(".k-dropdownlist, .k-combobox, a.k-button, .k-button-group");

            groups.before("<span class='k-separator'></span>");
        },
        _expandTools: function(tools) {
            function expandTool(toolName) {
                // expand string to object, add missing tool properties
                var options = $.isPlainObject(toolName) ? toolName : toolDefaults[toolName] || {};
                var spriteCssClass = "k-icon k-i-" + options.iconClass;
                var type = options.type;
                var typeDefaults = {
                    button: {
                        showText: "overflow"
                    },
                    colorPicker: {
                        toolIcon: spriteCssClass,
                        spriteCssClass: spriteCssClass
                    },
                    borders: { spriteCssClass: spriteCssClass },
                    alignment:  { spriteCssClass: spriteCssClass },
                    merge:  { spriteCssClass: spriteCssClass },
                    freeze:  { spriteCssClass: spriteCssClass }
                };

                var tool = kendo.deepExtend({
                    name: options.name || toolName,
                    text: MESSAGES[options.name || toolName],
                    icon: options.iconClass,
                    attributes: {
                        title: MESSAGES[options.name || toolName],
                        "aria-label":   MESSAGES[options.name || toolName]
                    }
                }, typeDefaults[type], options);

                if (type == "splitButton") {
                    tool.menuButtons = tool.menuButtons.map(expandTool);
                }

                if(tool.name === "fontSize" || toolName === "fontSize") {
                    tool.attributes["aria-label"] = null;
                }

                tool.attributes["data-tool"] = toolName;

                if (options.property) {
                    tool.attributes["data-property"] = options.property;
                }

                return tool;
            }

            return tools.reduce(function(tools, tool) {
                if (Array.isArray(tool)) {
                    tools.push({ type: "buttonGroup", buttons: tool.map(expandTool) });
                } else {
                    tools.push(expandTool.call(this, tool));
                }

                return tools;
            }, []);
        },
        _click: function(e) {
            var toolName = e.target.attr("data-tool");
            var tool = toolDefaults[toolName] || {};
            var commandType = tool.command;

            if (!commandType) {
                return;
            }

            var args = {
                command: commandType,
                options: {
                    property: tool.property || null,
                    value: tool.value || null
                }
            };

            if (typeof args.options.value === "boolean") {
                args.options.value = e.checked ? true : null;
            }

            this.action(args);
        },
        events: [
            "click",
            "toggle",
            "open",
            "close",
            "overflowOpen",
            "overflowClose",

            "action",
            "dialog"
        ],
        options: {
            name: "SpreadsheetToolBar",
            resizable: true,
            tools: defaultTools
        },
        action: function(args) {
            this.trigger("action", args);
        },
        dialog: function(args) {
            this.trigger("dialog", args);
        },
        refresh: function(activeCell) {
            var range = activeCell;
            var tools = this._tools();

            function setToggle(tool, value) {
                var toolbar = tool.toolbar;
                var overflow = tool.overflow;
                var togglable = (toolbar && toolbar.options.togglable) ||
                                 (overflow && overflow.options.togglable);

                if (!togglable) {
                    return;
                }

                var toggle = false;

                if (typeof value === "boolean") {
                    toggle = value;
                } else if (typeof value === "string") {
                    if (toolbar.options.hasOwnProperty("value")) {
                        toggle = toolbar.options.value === value;
                    } else {
                        // if no value is specified in the tool
                        // options, assume it should be ON if the
                        // range value is not null, and OFF otherwise.
                        toggle = value != null;
                    }
                }

                toolbar.toggle(toggle);

                if (overflow) {
                    overflow.toggle(toggle);
                }
            }

            function update(tool, value) {
                var toolbar = tool.toolbar;
                var overflow = tool.overflow;
                var selection, enabled;

                if (toolbar && toolbar.update) {
                    toolbar.update(value);
                }

                if (overflow && overflow.update) {
                    overflow.update(value);
                }

                if (tool.type == "filter") {
                    selection = range.sheet().selection();

                    if (selection && selection._ref && selection._ref.height) {
                        enabled = value || selection._ref.height() > 1;
                        toolbar.enable(enabled);
                        overflow.enable(enabled);
                    }
                }
            }

            for (var i = 0; i < tools.length; i++) {
                var property = tools[i].property;
                var tool = tools[i].tool;
                var value = kendo.isFunction(range[property]) ? range[property]() : range;

                if (property == "gridLines") {
                    // the law of leaky abstractions kicks in.  this
                    // isn't really a property of the range, it's
                    // per-sheet.
                    value = range.sheet().showGridLines();
                }

                if (tool.type === "button") {
                    setToggle(tool, value);
                } else {
                    update(tool, value);
                }
            }
            this.resize();
        },
        _tools: function() {
            return this.element.find("[data-property]").toArray().map(function(element) {
                element = $(element);
                return {
                    property: element.attr("data-property"),
                    tool: this._getItem(element)
                };
            }.bind(this));
        },
        destroy: function() {
            // TODO: move to ToolBar.destroy to take care of these
            this.element.find("[data-command],.k-button").each(function() {
                var element = $(this);
                var instance = element.data("instance");
                if (instance && instance.destroy) {
                    instance.destroy();
                }
            });

            ToolBar.fn.destroy.call(this);
        }
    });
    kendo.spreadsheet.ToolBar = SpreadsheetToolBar;

    var DropDownTool = kendo.toolbar.Item.extend({
        init: function(options, toolbar) {
            var dropDownList = $("<select />")
                .attr("title", options.attributes.title)
                .attr("aria-label", options.attributes.title)
                .kendoDropDownList({
                    height: "auto",
                    autoWidth: true
                }).data("kendoDropDownList");

            this.dropDownList = dropDownList;
            this.element = dropDownList.wrapper;
            this.options = options;
            this.toolbar = toolbar;

            this.attributes();
            this.addUidAttr();
            this.addOverflowAttr();

            dropDownList.bind("open", this._open.bind(this));
            dropDownList.bind("change", this._change.bind(this));

            this.element.width(options.width).attr({
                "data-command": "PropertyChangeCommand",
                "data-property": options.property
            });
        },
        _open: function() {
            var ddl = this.dropDownList;
            var list = ddl.list;
            var listWidth;

            list.css({
                whiteSpace: "nowrap",
                width: "auto"
            });

            listWidth = list.width();

            if (listWidth > 0) {
                listWidth += 20;
            } else {
                listWidth = ddl._listWidth;
            }

            list.css("width", listWidth + kendo.support.scrollbar());

            ddl._listWidth = listWidth;
        },
        _change: function(e) {
            var that = this;
            var instance = e.sender;
            var value = instance.value();
            var dataItem = instance.dataItem();
            var popupName = dataItem ? dataItem.popup : undefined;

            if (popupName) {
                setTimeout(function () {
                    that.toolbar.dialog({ name: popupName });
                });
            } else {
                that.toolbar.action({
                    command: "PropertyChangeCommand",
                    options: {
                        property: this.options.property,
                        value: value == "null" ? null : value
                    }
                });
            }
        },
        value: function(value) {
            if (value !== undefined) {
                this.dropDownList.value(value);
            } else {
                return this.dropDownList.value();
            }
        }
    });

    var PopupTool = kendo.toolbar.Item.extend({
        init: function(options, toolbar) {
            this.element = $("<a role='button' href='#' class='k-button k-button-md k-rounded-md  k-button-solid k-button-solid-base'>" +
                                "<span class='k-button-icon k-icon " + options.spriteCssClass + "'></span>" +
                                "<span class='k-button-text'><span class='k-icon k-i-arrow-s'></span></span>" +
                            "</a>");

            this.element
                .on("click touchend", this.open.bind(this))
                .attr("data-command", options.command);

            this.options = options;
            this.toolbar = toolbar;

            this.attributes();
            this.addUidAttr();
            this.addOverflowAttr();

            this._popup();
        },
        destroy: function() {
            this.popup.destroy();
        },
        open: function(ev) {
            ev.preventDefault();
            this.popup.toggle();
        },
        _popup: function() {
            var element = this.element;

            this.popup = $("<div class='k-spreadsheet-popup' />").appendTo(element).kendoPopup({
                anchor: element
            }).data("kendoPopup");
        }
    });

    kendo.toolbar.registerComponent("dialog", kendo.toolbar.ToolBarButton.extend({
        init: function(options, toolbar) {
            kendo.toolbar.ToolBarButton.fn.init.call(this, options, toolbar);

            this._dialogName = options.dialogName;

            this.element.on("click touchend", this.open.bind(this))
                        .data("instance", this);
        },
        open: function() {
            this.toolbar.dialog({ name: this._dialogName });
        }
    }));

    kendo.toolbar.registerComponent("exportAsDialog", kendo.toolbar.Item.extend({
        init: function(options, toolbar) {
            this._dialogName = options.dialogName;

            this.toolbar = toolbar;
            this._title = options.attributes.title;
            this.element = $("<button type='button' role='button' class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button'>" +
                                 "<span class='k-button-icon k-icon k-i-download'></span>" +
                             "</button>")
                             .attr("title", this._title)
                             .attr("aria-label", this._title)
                             .data("instance", this);

            this.element.on("click", this.open.bind(this))
                        .data("instance", this);
        },
        open: function() {
            this.toolbar.dialog({ name: this._dialogName });
        }
    }));

    var OverflowDialogButton = kendo.toolbar.OverflowButton.extend({
        init: function(options, toolbar) {
            kendo.toolbar.OverflowButton.fn.init.call(this, options, toolbar);

            this.element.on("click touchend", this._click.bind(this));

            this.message = this.options.text;

            var instance = this.element.data("button");
            this.element.data(this.options.type, instance);
        },
        _click: $.noop
    });

    var ColorPicker = PopupTool.extend({
        init: function(options, toolbar) {
            PopupTool.fn.init.call(this, options, toolbar);
            this.popup.element.addClass("k-spreadsheet-colorpicker");

            this.colorChooser = new kendo.spreadsheet.ColorChooser(this.popup.element, {
                change: this._colorChange.bind(this)
            });

            this.element.attr({
                "data-property": options.property
            });

            this.element.data({
                type: "colorPicker",
                colorPicker: this,
                instance: this
            });
        },
        destroy: function() {
            this.colorChooser.destroy();
            PopupTool.fn.destroy.call(this);
        },
        update: function(value) {
            this.value(value);
        },
        value: function(value) {
            this.colorChooser.value(value);
        },
        _colorChange: function(e) {
            this.toolbar.action({
                command: "PropertyChangeCommand",
                options: {
                    property: this.options.property,
                    value: e.sender.value()
                }
            });
            this.popup.close();
        }
    });

    var ColorPickerButton = OverflowDialogButton.extend({
        init: function(options, toolbar) {
            options.iconName = "text";
            OverflowDialogButton.fn.init.call(this, options, toolbar);
        },
        _click: function() {
            this.toolbar.dialog({
                name: "colorPicker",
                options: {
                    title: this.options.property, property: this.options.property
                }
            });
        }
    });

    kendo.toolbar.registerComponent("colorPicker", ColorPicker, ColorPickerButton);

    var FONT_SIZES = [8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
    var DEFAULT_FONT_SIZE = 12;

    var FontSize = kendo.toolbar.Item.extend({
        init: function(options, toolbar) {
            var comboBox = $("<input />")
                .attr("aria-label", options.attributes.title)
                .attr("title", options.attributes.title)
                .kendoComboBox({
                    change: this._valueChange.bind(this),
                    clearButton: false,
                    dataSource: options.fontSizes || FONT_SIZES,
                    value: DEFAULT_FONT_SIZE
                }).data("kendoComboBox");

            this.comboBox = comboBox;
            this.element = comboBox.wrapper;
            this.options = options;
            this.toolbar = toolbar;

            this.attributes();
            this.addUidAttr();
            this.addOverflowAttr();

            this.element.width(options.width).attr({
                "data-command": "PropertyChangeCommand",
                "data-property": options.property
            });

            this.element.data({
                type: "fontSize",
                fontSize: this
            });
        },

        _valueChange: function(e) {
            this.toolbar.action({
                command: "PropertyChangeCommand",
                options: {
                    property: this.options.property,
                    value: kendo.parseInt(e.sender.value())
                }
            });
        },

        update: function(value) {
            this.value(kendo.parseInt(value) || DEFAULT_FONT_SIZE);
        },

        value: function(value) {
            if (value !== undefined) {
                this.comboBox.value(value);
            } else {
                return this.comboBox.value();
            }
        }
    });

    var FontSizeButton = OverflowDialogButton.extend({
        _click: function() {
            this.toolbar.dialog({
                name: "fontSize",
                options: {
                    sizes: FONT_SIZES,
                    defaultSize: DEFAULT_FONT_SIZE
                }
            });
        },
        update: function(value) {
            this._value = value || DEFAULT_FONT_SIZE;
            this.element.find(".k-button-text").text(this.message + " (" + this._value + ") ...");
        }
    });

    kendo.toolbar.registerComponent("fontSize", FontSize, FontSizeButton);

    var FONT_FAMILIES = ["Arial", "Courier New", "Georgia", "Times New Roman", "Trebuchet MS", "Verdana"];
    var DEFAULT_FONT_FAMILY = "Arial";

    var FontFamily = DropDownTool.extend({
        init: function(options, toolbar) {
            DropDownTool.fn.init.call(this, options, toolbar);

            var ddl = this.dropDownList;
            ddl.setDataSource(options.fontFamilies || FONT_FAMILIES);
            ddl.value(DEFAULT_FONT_FAMILY);

            this.element.data({
                type: "fontFamily",
                fontFamily: this
            });
        },
        update: function(value) {
            this.value(value || DEFAULT_FONT_FAMILY);
        }
    });

    var FontFamilyButton = OverflowDialogButton.extend({
        _click: function() {
            this.toolbar.dialog({
                name: "fontFamily",
                options: {
                    fonts: FONT_FAMILIES,
                    defaultFont: DEFAULT_FONT_FAMILY
                }
            });
        },
        update: function(value) {
            this._value = value || DEFAULT_FONT_FAMILY;
            this.element.find(".k-button-text").text(this.message + " (" + this._value + ") ...");
        }
    });

    kendo.toolbar.registerComponent("fontFamily", FontFamily, FontFamilyButton);

    var defaultFormats = kendo.spreadsheet.formats = {
        automatic: null,
        text: "@",
        number: "#,0.00",
        percent: "0.00%",
        financial: '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
        currency: "$#,##0.00;[Red]$#,##0.00",
        date: "m/d/yyyy",
        time: "h:mm:ss AM/PM",
        dateTime: "m/d/yyyy h:mm",
        duration: "[h]:mm:ss"
    };

    var Format = DropDownTool.extend({
        _revertTitle: function(e) {
            e.sender.value("");
            e.sender.wrapper.width("auto");
        },
        init: function(options, toolbar) {
            DropDownTool.fn.init.call(this, options, toolbar);

            var ddl = this.dropDownList;
            var icon = "<span class='k-icon k-i-" + options.iconClass + "' style='line-height: 1em; width: 1.35em;'></span>";
            ddl.bind("change", this._revertTitle.bind(this));
            ddl.bind("dataBound", this._revertTitle.bind(this));
            ddl.setOptions({
                dataValueField: "format",
                dataTextField: "name",
                dataValuePrimitive: true,
                valueTemplate: icon,
                template:
                    "# if (data.sample) { #" +
                        "<span class='k-spreadsheet-sample'>#: data.sample #</span>" +
                    "# } #" +
                    "#: data.name #"
            });
            ddl.text(icon);
            ddl.setDataSource([
                { format: defaultFormats.automatic, name: MESSAGES.formatTypes.automatic },
                { format: defaultFormats.text, name: MESSAGES.formatTypes.text },
                { format: defaultFormats.number, name: MESSAGES.formatTypes.number , sample: "1,499.99" },
                { format: defaultFormats.percent, name: MESSAGES.formatTypes.percent , sample: "14.50%" },
                { format: defaultFormats.financial, name: MESSAGES.formatTypes.financial , sample: "(1,000.12)" },
                { format: defaultFormats.currency, name: MESSAGES.formatTypes.currency , sample: "$1,499.99" },
                { format: defaultFormats.date, name: MESSAGES.formatTypes.date , sample: "4/21/2012" },
                { format: defaultFormats.time, name: MESSAGES.formatTypes.time , sample: "5:49:00 PM" },
                { format: defaultFormats.dateTime, name: MESSAGES.formatTypes.dateTime , sample: "4/21/2012 5:49:00" },
                { format: defaultFormats.duration, name: MESSAGES.formatTypes.duration , sample: "168:05:00" },
                { popup: "formatCells", name: MESSAGES.formatTypes.moreFormats }
            ]);

            this.element.data({
                type: "format",
                format: this
            });

            ddl.wrapper.find("[role='option']").attr("aria-label", "Select format");
        }
    });

    var FormatButton = OverflowDialogButton.extend({
        _click: function() {
            this.toolbar.dialog({ name: "formatCells" });
        }
    });

    kendo.toolbar.registerComponent("format", Format, FormatButton);

    var BorderChangeTool = PopupTool.extend({
        init: function(options, toolbar) {
            PopupTool.fn.init.call(this, options, toolbar);
            this._borderPalette();

            this.element.data({
                type: "borders",
                instance: this
            });
        },
        destroy: function() {
            this.borderPalette.destroy();
            PopupTool.fn.destroy.call(this);
        },
        _borderPalette: function() {
            var element = $("<div />").appendTo(this.popup.element);
            this.borderPalette = new kendo.spreadsheet.BorderPalette(element, {
                change: this._action.bind(this)
            });
        },
        _action: function(e) {
            this.toolbar.action({
                command: "BorderChangeCommand",
                options: {
                    border: e.type,
                    style: { size: 1, color: e.color }
                }
            });
        }
    });

    var BorderChangeButton = OverflowDialogButton.extend({
        _click: function() {
            this.toolbar.dialog({ name: "borders" });
        }
    });

    kendo.toolbar.registerComponent("borders", BorderChangeTool, BorderChangeButton);

    var AlignmentTool = PopupTool.extend({
        init: function(options, toolbar) {
            PopupTool.fn.init.call(this, options, toolbar);

            this.element.attr({ "data-property": "alignment" });
            this._defineButtons();
            this._commandPalette();
            this.popup.element.on("click", ".k-button", function(e) {
                this._action($(e.currentTarget));
            }.bind(this));

            this.element.data({
                type: "alignment",
                alignment: this,
                instance: this
            });
        },
        _defineButtons: function() {
            this.buttons = [
                { property: "textAlign",     value: "left",    iconClass: "align-left",   text: MESSAGES.alignmentButtons.justtifyLeft },
                { property: "textAlign",     value: "center",  iconClass: "align-center", text: MESSAGES.alignmentButtons.justifyCenter },
                { property: "textAlign",     value: "right",   iconClass: "align-right",  text: MESSAGES.alignmentButtons.justifyRight },
                { property: "textAlign",     value: "justify", iconClass: "align-justify",   text: MESSAGES.alignmentButtons.justifyFull },
                { property: "verticalAlign", value: "top",     iconClass: "align-top",      text: MESSAGES.alignmentButtons.alignTop },
                { property: "verticalAlign", value: "center",  iconClass: "align-middle",   text: MESSAGES.alignmentButtons.alignMiddle },
                { property: "verticalAlign", value: "bottom",  iconClass: "align-bottom",   text: MESSAGES.alignmentButtons.alignBottom }
            ];
        },
        destroy: function() {
            this.popup.element.off();
            PopupTool.fn.destroy.call(this);
        },
        update: function(range) {
            var textAlign = range.textAlign();
            var verticalAlign = range.verticalAlign();
            var element = this.popup.element;

            element.find(".k-button").removeClass("k-active");

            if (textAlign) {
                element.find("[data-property=textAlign][data-value=" + textAlign + "]").addClass("k-active");
            }

            if (verticalAlign) {
                element.find("[data-property=verticalAlign][data-value=" + verticalAlign + "]").addClass("k-active");
            }
        },
        _commandPalette: function() {
            var buttons = this.buttons;
            var element = $("<div />").appendTo(this.popup.element);
            buttons.forEach(function(options, index) {
                var button = "<a role='button' title='" + options.text + "' data-property='" + options.property + "' data-value='" + options.value + "' class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button'>" +
                                "<span class='k-button-icon k-icon k-i-" + options.iconClass + "'></span>" +
                             "</a>";
                if (index !== 0 && buttons[index - 1].property !== options.property) {
                    element.append($("<span class='k-separator' />"));
                }
                element.append(button);
            });
        },
        _action: function(button) {
            var property = button.attr("data-property");
            var value = button.attr("data-value");

            this.toolbar.action({
                command: "PropertyChangeCommand",
                options: {
                    property: property,
                    value: value
                }
            });
        }
    });

    var AlignmentButton = OverflowDialogButton.extend({
        _click: function() {
            this.toolbar.dialog({ name: "alignment" });
        }
    });

    kendo.toolbar.registerComponent("alignment", AlignmentTool, AlignmentButton);

    var MergeTool = PopupTool.extend({
        init: function(options, toolbar) {
            PopupTool.fn.init.call(this, options, toolbar);

            this.popup.element.addClass("k-menu-popup");

            this._defineButtons();
            this._commandPalette();
            this.popup.element.on("click", ".k-menu-item", function(e) {
                this._action($(e.currentTarget));
            }.bind(this));

            this.element.data({
                type: "merge",
                merge: this,
                instance: this
            });
        },
        _defineButtons: function() {
            this.buttons = [
                { value: "cells",        iconClass: "cells-merge",        text: MESSAGES.mergeButtons.mergeCells },
                { value: "horizontally", iconClass: "cells-merge-horizontally", text: MESSAGES.mergeButtons.mergeHorizontally },
                { value: "vertically",   iconClass: "cells-merge-vertically",   text: MESSAGES.mergeButtons.mergeVertically },
                { value: "unmerge",      iconClass: "table-unmerge",      text: MESSAGES.mergeButtons.unmerge }
            ];
        },
        destroy: function() {
            this.popup.element.off();
            PopupTool.fn.destroy.call(this);
        },
        _commandPalette: function() {
            var element = $("<ul class='k-group k-menu-group k-reset k-menu-group-md'>").appendTo(this.popup.element);

            this.buttons.forEach(function(options) {
                var item = "<li class='k-item k-menu-item' data-value='" + options.value + "'>" +
                    "<span class='k-link k-menu-link'>" +
                        "<span class='k-icon k-i-" + options.iconClass + "'></span>" +
                        "<span class='k-menu-link-text'>" + options.text + "</span>" +
                    "</span>" +
                "</li>";

                element.append(item);
            });
        },
        _action: function(button) {
            var value = button.attr("data-value");

            this.toolbar.action({
                command: "MergeCellCommand",
                options: {
                    value: value
                }
            });
        }
    });

    var MergeButton = OverflowDialogButton.extend({
        _click: function() {
            this.toolbar.dialog({ name: "merge" });
        }
    });

    kendo.toolbar.registerComponent("merge", MergeTool, MergeButton);

    var FreezeTool = PopupTool.extend({
        init: function(options, toolbar) {
            PopupTool.fn.init.call(this, options, toolbar);

            this.popup.element.addClass("k-menu-popup");
            this._defineButtons();
            this._commandPalette();
            this.popup.element.on("click", ".k-menu-item", function(e) {
                this._action($(e.currentTarget));
            }.bind(this));

            this.element.data({
                type: "freeze",
                freeze: this,
                instance: this
            });
        },
        _defineButtons: function() {
            this.buttons = [
                { value: "panes",    iconClass: "pane-freeze",  text: MESSAGES.freezeButtons.freezePanes },
                { value: "rows",     iconClass: "row-freeze",    text: MESSAGES.freezeButtons.freezeRows },
                { value: "columns",  iconClass: "column-freeze",    text: MESSAGES.freezeButtons.freezeColumns },
                { value: "unfreeze", iconClass: "table-unmerge", text: MESSAGES.freezeButtons.unfreeze }
            ];
        },
        destroy: function() {
            this.popup.element.off();
            PopupTool.fn.destroy.call(this);
        },
        _commandPalette: function() {
            var element = $("<ul class='k-group k-menu-group k-reset k-menu-group-md'>").appendTo(this.popup.element);
            this.buttons.forEach(function(options) {
                var item = "<li class='k-item k-menu-item' data-value='" + options.value + "'>" +
                    "<span class='k-link k-menu-link'>" +
                        "<span class='k-icon k-i-" + options.iconClass + "'></span>" +
                        "<span class='k-menu-link-text'>" + options.text + "</span>" +
                    "</span>" +
                "</li>";
                element.append(item);
            });
        },
        _action: function(button) {
            var value = button.attr("data-value");

            this.toolbar.action({
                command: "FreezePanesCommand",
                options: {
                    value: value
                }
            });
        }
    });

    var FreezeButton = OverflowDialogButton.extend({
        _click: function() {
            this.toolbar.dialog({ name: "freeze" });
        }
    });

    kendo.toolbar.registerComponent("freeze", FreezeTool, FreezeButton);

    var Sort = DropDownTool.extend({
        _revertTitle: function(e) {
            e.sender.wrapper.find('[role="option"]').attr("aria-label", e.sender.value());
            e.sender.value("");
            e.sender.wrapper.width("auto");
        },
        init: function(options, toolbar) {
            DropDownTool.fn.init.call(this, options, toolbar);

            var ddl = this.dropDownList;
            ddl.bind("change", this._revertTitle.bind(this));
            ddl.bind("dataBound", this._revertTitle.bind(this));
            ddl.setOptions({
                valueTemplate: "<span class='k-icon k-i-" + options.iconClass + "' style='line-height: 1em; width: 1.35em;'></span>",
                template: "<span class='k-icon k-i-#= iconClass #' style='line-height: 1em; width: 1.35em;'></span>#=text#",
                dataTextField: "text",
                dataValueField: "value"
            });
            ddl.setDataSource([
                // { value: "asc", sheet: true, asc: true,  text: MESSAGES.sortButtons.sortSheetAsc,  iconClass: "sort-asc" },
                // { value: "desc", sheet: true, asc: false, text: MESSAGES.sortButtons.sortSheetDesc,  , iconClass: "sort-desc" },
                { value: "asc", sheet: false, text: MESSAGES.sortButtons.sortRangeAsc, iconClass: "sort-asc" },
                { value: "desc", sheet: false, text: MESSAGES.sortButtons.sortRangeDesc, iconClass: "sort-desc" }
            ]);
            ddl.select(0);
            ddl.wrapper.find('[role="option"]').attr("aria-label", "asc");

            this.element.data({
                type: "sort",
                sort: this
            });
        },
        _change: function(e) {
            var instance = e.sender;
            var dataItem = instance.dataItem();

            if (dataItem) {
                this.toolbar.action({
                    command: "SortCommand",
                    options: {
                        value: dataItem.value,
                        sheet: dataItem.sheet
                    }
                });
            }
        },
        value: $.noop
    });

    var SortButton = OverflowDialogButton.extend({
        _click: function() {
            this.toolbar.dialog({ name: "sort" });
        }
    });

    kendo.toolbar.registerComponent("sort", Sort, SortButton);

    var Filter = kendo.toolbar.ToolBarButton.extend({
        init: function(options, toolbar) {
            options.showText = "overflow";
            kendo.toolbar.ToolBarButton.fn.init.call(this, options, toolbar);

            this.element.on("click", this._click.bind(this));

            this.element.data({
                type: "filter",
                filter: this
            });
        },
        _click: function() {
            this.toolbar.action({ command: "FilterCommand" });
        },
        update: function(value) {
            this.toggle(value);
        }
    });

    var FilterButton = OverflowDialogButton.extend({
        init: function(options, toolbar) {
            OverflowDialogButton.fn.init.call(this, options, toolbar);

            this.element.data({
                type: "filter",
                filter: this
            });
        },
        _click: function() {
            this.toolbar.action({ command: "FilterCommand" });
        },
        update: function(value) {
            this.toggle(value);
        }
    });

    kendo.toolbar.registerComponent("filter", Filter, FilterButton);

    var Open = kendo.toolbar.Item.extend({
        init: function(options, toolbar) {
            this.toolbar = toolbar;
            this.element = $("<div class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-upload-button k-icon-button'>" +
                                 "<span class='k-button-icon k-icon k-i-folder-open'></span>" +
                             "</div>").data("instance", this);

            this._title = options.attributes.title;
            this._reset();
        },
        _reset: function() {
            this.element.find("input").remove();

            $("<input type='file' autocomplete='off' accept='.xlsx'/>")
                .attr("title", this._title)
                .attr("aria-label", this._title)
                .one("change", this._change.bind(this))
                .appendTo(this.element);
        },
        _change: function(e) {
            this.toolbar.action({
                command: "OpenCommand",
                options: {
                    file: e.target.files[0]
                }
            });

            this._reset();
        }
    });
    kendo.toolbar.registerComponent("open", Open);

    kendo.spreadsheet.TabStrip = kendo.ui.TabStrip.extend({
        init: function(element, options) {
            kendo.ui.TabStrip.fn.init.call(this, element, options);
            element.addClass("k-spreadsheet-tabstrip");
            this._quickAccessButtons();

            this.toolbars = {};

            var tabs = options.dataSource;

            this.contentElements.each(function(idx, element) {
                this._toolbar($(element), tabs[idx].id, options.toolbarOptions[tabs[idx].id]);
            }.bind(this));

            this.one("activate", function() { //force resize of the tabstrip after TabStrip tab is opened
                this.toolbars[this.options.dataSource[0].id].resize();
            });
        },

        events: kendo.ui.TabStrip.fn.events.concat([ "action", "dialog" ]),

        destroy: function() {
            this.quickAccessToolBar.off("click");
            kendo.ui.TabStrip.fn.destroy.call(this);
            for (var name in this.toolbars) {
                this.toolbars[name].destroy();
            }
        },

        action: function(args) {
            this.trigger("action", args);
        },

        dialog: function(args) {
            this.trigger("dialog", args);
        },

        refreshTools: function(range) {
            var toolbars = this.toolbars;
            for (var name in toolbars) {
                if (toolbars.hasOwnProperty(name)) {
                    toolbars[name].refresh(range);
                }
            }
        },

        _quickAccessButtons: function() {
            var buttons = [
                { title: MESSAGES.quickAccess.undo, iconClass: "undo", action: "undo" },
                { title: MESSAGES.quickAccess.redo, iconClass: "redo", action: "redo" }
            ];
            var buttonTemplate = kendo.template("<a role='button' href='\\#' title='#= title #' data-action='#= action #' class='k-button k-button-md k-rounded-md k-button-flat k-button-flat-base k-icon-button' aria-label='#= title #'><span class='k-button-icon k-icon k-i-#=iconClass#'></span></a>");

            this.quickAccessToolBar = $("<div />", {
                "class": "k-spreadsheet-quick-access-toolbar",
                "html": kendo.render(buttonTemplate, buttons)
            }).insertBefore(this.wrapper);

            this.quickAccessToolBar.on("click", ".k-button", function(e) {
                e.preventDefault();

                var action = $(e.currentTarget).attr("data-action");
                this.action({ action: action });
            }.bind(this));

            this.quickAccessAdjust();
        },

        quickAccessAdjust: function() {
            this.tabGroup.css("padding-left", kendo._outerWidth(this.quickAccessToolBar));
        },

        _toolbar: function(container, name, tools) {
            var element;
            var options;

            if (this.toolbars[name]) {
                this.toolbars[name].destroy();
                container.children(".k-toolbar").remove();
            }

            if (tools) {
                element = container.html("<div></div>").children("div");

                options = {
                    tools: typeof tools === "boolean" ? undefined : tools,
                    toolbarName: name,
                    action: this.action.bind(this),
                    dialog: this.dialog.bind(this)
                };

                this.toolbars[name] = new kendo.spreadsheet.ToolBar(element, options);
            }
        }

    });

})(window.kendo);

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/dialogs',[ "../kendo.core", "../kendo.binder", "../kendo.validator" ], f);
})(function(){

(function(kendo) {

    /* jshint eqnull:true */
    /* jshint latedef: false */
    /* jshint multistr: true */

    var $ = kendo.jQuery;
    var ObservableObject = kendo.data.ObservableObject;

    var MESSAGES = kendo.spreadsheet.messages.dialogs = {
        apply: "Apply",
        save: "Save",
        cancel: "Cancel",
        remove: "Remove",
        retry: "Retry",
        revert: "Revert",
        okText: "OK",
        formatCellsDialog: {
            title: "Format",
            categories: {
                number: "Number",
                currency: "Currency",
                date: "Date"
            }
        },
        fontFamilyDialog: {
            title: "Font"
        },
        fontSizeDialog: {
            title: "Font size"
        },
        bordersDialog: {
            title: "Borders"
        },
        alignmentDialog: {
            title: "Alignment",
            buttons: {
                justtifyLeft: "Align left",
                justifyCenter: "Center",
                justifyRight: "Align right",
                justifyFull: "Justify",
                alignTop: "Align top",
                alignMiddle: "Align middle",
                alignBottom: "Align bottom"
            }
        },
        mergeDialog: {
            title: "Merge cells",
            buttons: {
                mergeCells: "Merge all",
                mergeHorizontally: "Merge horizontally",
                mergeVertically: "Merge vertically",
                unmerge: "Unmerge"
            }
        },
        freezeDialog: {
            title: "Freeze panes",
            buttons: {
                freezePanes: "Freeze panes",
                freezeRows: "Freeze rows",
                freezeColumns: "Freeze columns",
                unfreeze: "Unfreeze panes"
            }
        },
        confirmationDialog: {
            text: "Are you sure you want to remove this sheet?",
            title: "Sheet remove"
        },
        validationDialog: {
            title: "Data Validation",
            hintMessage: "Please enter a valid {0} value {1}.",
            hintTitle: "Validation {0}",
            criteria: {
                any: "Any value",
                number: "Number",
                text: "Text",
                date: "Date",
                custom: "Custom Formula",
                list: "List"
            },
            comparers: {
                greaterThan: "greater than",
                lessThan: "less than",
                between: "between",
                notBetween: "not between",
                equalTo: "equal to",
                notEqualTo: "not equal to",
                greaterThanOrEqualTo: "greater than or equal to",
                lessThanOrEqualTo: "less than or equal to"
            },
            comparerMessages: {
                greaterThan: "greater than {0}",
                lessThan: "less than {0}",
                between: "between {0} and {1}",
                notBetween: "not between {0} and {1}",
                equalTo: "equal to {0}",
                notEqualTo: "not equal to {0}",
                greaterThanOrEqualTo: "greater than or equal to {0}",
                lessThanOrEqualTo: "less than or equal to {0}",
                custom: "that satisfies the formula: {0}"
            },
            labels: {
                criteria: "Criteria",
                comparer: "Comparer",
                min: "Min",
                max: "Max",
                value: "Value",
                start: "Start",
                end: "End",
                onInvalidData: "On invalid data",
                rejectInput: "Reject input",
                showWarning: "Show warning",
                showHint: "Show hint",
                hintTitle: "Hint title",
                hintMessage: "Hint message",
                ignoreBlank: "Ignore blank",
                showListButton: "Display button to show list",
                showCalendarButton: "Display button to show calendar"
            },
            placeholders: {
                typeTitle: "Type title",
                typeMessage: "Type message"
            }
        },
        exportAsDialog: {
            title: "Export...",
            defaultFileName: "Workbook",
            xlsx: {
                description: "Excel Workbook (.xlsx)"
            },
            pdf: {
                description: "Portable Document Format (.pdf)",
                area: {
                    workbook: "Entire Workbook",
                    sheet: "Active Sheet",
                    selection: "Selection"
                },
                paper: {
                    a2        : "A2 (420 mm  594 mm)",
                    a3        : "A3 (297 mm x 420 mm)",
                    a4        : "A4 (210 mm x 297 mm)",
                    a5        : "A5 (148 mm x 210 mm)",
                    b3        : "B3 (353 mm  500 mm)",
                    b4        : "B4 (250 mm x 353 mm)",
                    b5        : "B5 (176 mm x 250 mm)",
                    folio     : 'Folio (8.5" x 13")',
                    legal     : 'Legal (8.5" x 14")',
                    letter    : 'Letter (8.5" x 11")',
                    tabloid   : 'Tabloid (11" x 17")',
                    executive : 'Executive (7.25" x 10.5")'
                },
                margin: {
                    normal: "Normal",
                    narrow: "Narrow",
                    wide: "Wide"
                }
            },
            labels: {
                scale: "Scale",
                fit: "Fit to page",
                fileName: "File name",
                saveAsType: "Save as type",
                exportArea: "Export",
                paperSize: "Paper size",
                margins: "Margins",
                orientation: "Orientation",
                print: "Print",
                guidelines: "Guidelines",
                center: "Center",
                horizontally: "Horizontally",
                vertically: "Vertically"
            }
        },
        modifyMergedDialog: {
            errorMessage: "Cannot change part of a merged cell."
        },
        rangeDisabledDialog: {
            errorMessage: "Destination range contains disabled cells."
        },
        intersectsArrayDialog: {
            errorMessage: "You cannot alter part of an array"
        },
        incompatibleRangesDialog: {
            errorMessage: "Incompatible ranges"
        },
        noFillDirectionDialog: {
            errorMessage: "Cannot determine fill direction"
        },
        duplicateSheetNameDialog: {
            errorMessage: "Duplicate sheet name"
        },
        overflowDialog: {
            errorMessage: "Cannot paste, because the copy area and the paste area are not the same size and shape."
        },
        useKeyboardDialog: {
            title: "Copying and pasting",
            errorMessage: "These actions cannot be invoked through the menu. Please use the keyboard shortcuts instead:",
            labels: {
                forCopy: "for copy",
                forCut: "for cut",
                forPaste: "for paste"
            }
        },
        unsupportedSelectionDialog: {
            errorMessage: "That action cannot be performed on multiple selection."
        },
        linkDialog: {
            title: "Hyperlink",
            labels: {
                text: "Text",
                url: "Address",
                removeLink: "Remove link"
            }
        },
        insertCommentDialog: {
            title: "Insert comment",
            labels: {
                comment: "Comment",
                removeComment: "Remove comment"
            }
        },
        insertImageDialog: {
            title: "Insert image",
            info: "Drag an image here, or click to select",
            typeError: "Please select a JPEG, PNG or GIF image"
        }
    };

    var registry = {};
    kendo.spreadsheet.dialogs = {
        register: function(name, dialogClass) {
            registry[name] = dialogClass;
        },
        registered: function(name) {
            return !!registry[name];
        },
        create: function(name, options) {
            var dialogClass = registry[name];

            if (dialogClass) {
                return new dialogClass(options);
            }
        }
    };

    var SpreadsheetDialog = kendo.spreadsheet.SpreadsheetDialog = kendo.Observable.extend({
        init: function(options) {
            kendo.Observable.fn.init.call(this, options);

            this.options = translate($.extend(true, {}, this.options, options));

            this.bind(this.events, options);
        },
        events: [
            "close",
            "activate"
        ],
        options: {
            autoFocus: true
        },
        dialog: function() {
            if (!this._dialog) {
                var options = {
                    autoFocus: false,
                    scrollable: false,
                    resizable: false,
                    modal: true,
                    visible: false,
                    width: this.options.width || 320,
                    title: this.options.title,
                    open: function() {
                        this.center();
                    },
                    close: this._onDialogClose.bind(this),
                    activate: this._onDialogActivate.bind(this),
                    deactivate: this._onDialogDeactivate.bind(this)
                };
                this._dialog = $("<div class='k-spreadsheet-window k-action-window k-popup-edit-form' />")
                    .addClass(this.options.className || "")
                    .append(kendo.template(this.options.template)({
                        messages: kendo.spreadsheet.messages.dialogs || MESSAGES,
                        ns: kendo.ns,

                        // this is for ImportErrorDialog.  ugly that
                        // we need this line here, but I couldn't
                        // figure out a better way
                        errors: this.options.errors
                    }))
                    .kendoWindow(options)
                    .data("kendoWindow");
            }

            return this._dialog;
        },
        _onDialogClose: function() {
            this.trigger("close", {
                action: this._action
            });
        },
        _onDialogActivate: function() {
            this.trigger("activate");
        },
        _onDialogDeactivate: function() {
            this.trigger("deactivate");
            this.destroy();
        },
        destroy: function() {
            if (this._dialog) {
                this._dialog.destroy();
                this._dialog = null;
            }
        },
        open: function() {
            this.dialog().open();
            this.dialog().element.find(".k-button-solid-primary").trigger("focus");
        },
        apply: function() {
            this.close();
        },
        close: function() {
            this._action = "close";

            this.dialog().close();
        }
    });

    function formattedValue(value, format) {
        return kendo.spreadsheet.formatting.text(value, format);
    }

    var FormatCellsViewModel = kendo.spreadsheet.FormatCellsViewModel = ObservableObject.extend({
        init: function(options) {
            ObservableObject.fn.init.call(this, options);

            this.useCategory(this.category);
        },
        useCategory: function(category) {
            var type = category && category.type || "number";
            var formatCurrency = type == "currency";

            this.category = category;

            this.set("showCurrencyFilter", formatCurrency && this.currencies.length > 1);

            if (!formatCurrency) {
                this.set("formats", this.allFormats[type + "Formats"]);
            } else {
                this.currency(this.currencies[0]);
            }

            this.useFirstFormat();
        },
        useFirstFormat: function() {
            if (this.formats.length) {
                this.set("format", this.formats[0].value);
            }
        },
        currency: function(currency) {
            if (currency !== undefined) {
                this._currency = currency;

                var info = currency.value;
                var formats = [
                    { currency: info, decimals: true },
                    { currency: info, decimals: true, iso: true },
                    { currency: info, decimals: false }
                ];

                formats = formats.map(function(format) {
                    format = FormatCellsViewModel.convert.currency(format);

                    return { value: format, name: formattedValue(1000, format) };
                });

                this.set("formats", formats);

                this.useFirstFormat();
            }

            return this._currency || this.currencies[0];
        },
        categoryFilter: function(category) {
            if (category !== undefined) {
                this.useCategory(category);
            }

            return this.category;
        },
        preview: function() {
            var format = this.get("format");
            var value = this.value || 0;

            if (format && format.length) {
                return formattedValue(value, format);
            } else {
                return value;
            }
        }
    });

    FormatCellsViewModel.convert = {
        currency: function(options) {
            function repeat(token, n) {
                return new Array(n+1).join(token);
            }

            // convert culture info to spreadsheet format
            var info = options.currency;
            var format = info.pattern[1];

            if (options.decimals) {
                format = format.replace(/n/g, "n" + info["."] + repeat("0", info.decimals));
            }

            if (options.iso) {
                format = '"' + info.abbr + '" ' + format.replace(/\s*\$\s*/g, "");
            } else {
                format = format.replace(/\$/g, JSON.stringify(info.symbol));
            }

            format = format.replace(/n/g, "?");

            return format;
        },
        date: function(format) {
            if ((/T|Z/).test(format)) {
                return "";
            }

            return format.toLowerCase().replace(/tt/g, "AM/PM").replace(/'/g, '"');
        }
    };

    function uniqueBy(field, array) {
        var result = [];
        var values = [];

        for (var i = 0; i < array.length; i++) {
            if ($.inArray(array[i][field], values) == -1) {
                result.push(array[i]);
                values.push(array[i][field]);
            }
        }

        return result;
    }

    var FormatCellsDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.formatCellsDialog || MESSAGES;
            var defaultOptions = {
                title: messages.title,
                categories: [
                    { type: "number", name: messages.categories.number },
                    { type: "currency", name: messages.categories.currency },
                    { type: "date", name: messages.categories.date }
                ]
            };

            SpreadsheetDialog.fn.init.call(this, $.extend(defaultOptions, options));

            this._generateFormats();
        },
        options: {
            className: "k-spreadsheet-format-cells",
            template:
                "<div class='k-edit-form-container'>" +

                    "<div class='k-root-tabs' data-#:ns#role='tabstrip' " +
                        "data-#:ns#text-field='name' " +
                        "data-#:ns#bind='source: categories, value: categoryFilter' " +
                        "data-#:ns#animation='false'></div>" +

                    "<div class='k-spreadsheet-preview' data-#:ns#bind='text: preview'></div>" +

                    "<script type='text/x-kendo-template' id='format-item-template'>" +
                        "\\#: data.name \\#" +
                    "</script>" +

                    "<select data-#:ns#role='dropdownlist' class='k-format-filter' " +
                        "data-#:ns#text-field='description' " +
                        "data-#:ns#value-field='value.name' " +
                        "data-#:ns#bind='visible: showCurrencyFilter, value: currency, source: currencies'></select>" +

                    "<ul data-#:ns#role='staticlist' tabindex='0' " +
                        "id='formats-list' " +
                        "aria-label='formats list' " +
                        "class='k-list k-reset' " +
                        "data-#:ns#template='format-item-template' " +
                        "data-#:ns#value-primitive='true' " +
                        "data-#:ns#value-field='value' " +
                        "data-#:ns#bind='source: formats, value: format'></ul>" +

                    "<div class='k-action-buttons'>" +
                        "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: apply'><span class='k-button-text'>#: messages.apply #</span></button>" +
                        "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: close'><span class='k-button-text'>#: messages.cancel #</span></button>" +
                    "</div>"+

                "</div>"
        },
        _generateFormats: function() {
            var options = this.options;

            if (!options.currencies) {
                options.currencies = FormatCellsDialog.currenciesFrom(kendo.cultures);
            }

            if (!options.numberFormats) {
                options.numberFormats = [
                    { value: "#.00%", name: "100.00%" },
                    { value: "#%", name: "100%" },
                    { value: "#.00", name: "1024.00" },
                    { value: "#,###.00", name: "1,024.00" }
                ];
            }

            if (!options.dateFormats) {
                var calendarPatterns = kendo.cultures.current.calendars.standard.patterns;

                options.dateFormats = uniqueBy("value", $.map(calendarPatterns, function(format) {
                    format = FormatCellsViewModel.convert.date(format);

                    if (!format) {
                        return;
                    }

                    return { value: format, name: formattedValue(34567.7678, format) };
                }));
            }
        },
        open: function(range) {
            var options = this.options;
            var value = range.value();
            var categories = options.categories.slice(0);
            var element;

            this.viewModel = new FormatCellsViewModel({
                currencies: options.currencies.slice(0),
                allFormats: {
                    numberFormats: options.numberFormats.slice(0),
                    dateFormats: options.dateFormats.slice(0)
                },
                categories: categories,
                format: range.format(),
                category: value instanceof Date ? categories[2] : categories[0],
                apply: this.apply.bind(this),
                close: this.close.bind(this),
                value: value
            });

            SpreadsheetDialog.fn.open.call(this);

            element = this.dialog().element;

            kendo.bind(element, this.viewModel);

            var currencyFilter = element.find("select.k-format-filter").data("kendoDropDownList");

            if (options.currencies.length > 10) {
                currencyFilter.setOptions({ filter: "contains" });
            }

            element.find(kendo.roleSelector("staticlist")).parent().addClass("k-list-wrapper");

            element.find(".k-tabstrip-item").attr("aria-controls", "formats-list");
        },
        apply: function() {
            var format = this.viewModel.format;

            SpreadsheetDialog.fn.apply.call(this);

            this.trigger("action", {
                command: "PropertyChangeCommand",
                options: {
                    property: "format",
                    value: format
                }
            });
        }
    });

    FormatCellsDialog.currenciesFrom = function (cultures) {
        return uniqueBy("description", $.map(cultures, function(culture, name) {
            if (!(/-/).test(name)) {
                return;
            }

            var currency = culture.numberFormat.currency;
            var description = kendo.format(
                "{0} ({1}, {2})",
                currency.name,
                currency.abbr,
                currency.symbol
            );

            return { description: description, value: currency };
        }));
    };

    kendo.spreadsheet.dialogs.register("formatCells", FormatCellsDialog);

    kendo.spreadsheet.dialogs.FormatCellsDialog = FormatCellsDialog;

    var MessageDialog = SpreadsheetDialog.extend({
        options: {
            className: "k-spreadsheet-message",
            title: "",
            messageId: "",
            text: "",
            template:
                "<div class='k-spreadsheet-message-content' data-#:ns#bind='text: text'></div>" +
                "<div class='k-action-buttons'>" +
                    "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: close'>" +
                        "<span class='k-button-text'>#= messages.okText #</span>" +
                    "</button>" +
                "</div>"
        },
        open: function() {
            SpreadsheetDialog.fn.open.call(this);

            var options = this.options;
            var text = options.text;

            if (options.messageId) {
                text = kendo.getter(options.messageId, true)(kendo.spreadsheet.messages.dialogs);
            }

            kendo.bind(this.dialog().element, {
                text: text,
                close: this.close.bind(this)
            });
        }
    });

    kendo.spreadsheet.dialogs.register("message", MessageDialog);

    var ConfirmationDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.confirmationDialog || MESSAGES;
            var defaultOptions = {
                title: messages.title,
                text: messages.text
            };

            SpreadsheetDialog.fn.init.call(this, $.extend(defaultOptions, options));
        },
        options: {
            className: "k-spreadsheet-message",
            messageId: "",
            template:
                "<div class='k-spreadsheet-message-content' data-#:ns#bind='text: text'></div>" +
                "<div class='k-action-buttons'>" +
                    "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: confirm'>" +
                        "<span class='k-button-text'>#= messages.okText #</span>" +
                    "</button>" +
                    "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: cancel'>" +
                        "<span class='k-button-text'>#= messages.cancel #</span>" +
                    "</button>" +
                "</div>"
        },
        open: function() {
            SpreadsheetDialog.fn.open.call(this);

            var options = this.options;
            var text = options.text;

            if (options.messageId) {
                text = kendo.getter(options.messageId, true)(kendo.spreadsheet.messages.dialogs);
            }

            kendo.bind(this.dialog().element, {
                text: text,
                confirm: this.confirm.bind(this),
                cancel: this.close.bind(this)
            });
        },
        isConfirmed: function() {
            return this._confirmed;
        },
        confirm: function() {
            this._confirmed = true;
            this.close();
        }
    });

    kendo.spreadsheet.dialogs.register("confirmation", ConfirmationDialog);

    var ValidationErrorDialog = SpreadsheetDialog.extend({
        options: {
            className: "k-spreadsheet-message",
            title: "",
            messageId: "",
            text: "",
            template:
            "<div class='k-spreadsheet-message-content' data-#:ns#bind='text: text'></div>" +
            "<div class='k-action-buttons'>" +
                "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: retry'>" +
                    "<span class='k-button-text'>#= messages.retry #</span>" +
                "</button>" +
                "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: cancel'>" +
                    "<span class='k-button-text'>#= messages.cancel #</span>" +
                "</button>" +
            "</div>"
        },
        open: function() {
            SpreadsheetDialog.fn.open.call(this);

            var options = this.options;
            var text = options.text;

            if (options.messageId) {
                text = kendo.getter(options.messageId, true)(kendo.spreadsheet.messages.dialogs);
            }

            kendo.bind(this.dialog().element, {
                text: text,
                retry: this.retry.bind(this),
                cancel: this.close.bind(this)
            });
        },
        retry: function() {
            this._retry = true;
            this.close();
        }
    });

    kendo.spreadsheet.dialogs.register("validationError", ValidationErrorDialog);

    var FontFamilyDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.fontFamilyDialog || MESSAGES;

            SpreadsheetDialog.fn.init.call(this, $.extend({ title: messages.title }, options));

            this._list();
        },
        options: {
            template: "<ul class='k-list k-reset'></ul>"
        },
        _list: function() {
            var ul = this.dialog().element.find("ul");
            var fonts = this.options.fonts;
            var defaultFont = this.options.defaultFont;

            this.list = new kendo.ui.StaticList(ul, {
                dataSource: new kendo.data.DataSource({ data: fonts }),
                template: "#: data #",
                value: defaultFont,
                change: this.apply.bind(this)
            });

            this.list.dataSource.fetch();
        },
        apply: function(e) {
            SpreadsheetDialog.fn.apply.call(this);

            this.trigger("action", {
                command: "PropertyChangeCommand",
                options: {
                    property: "fontFamily",
                    value: e.sender.value()[0]
                }
            });
        }
    });

    kendo.spreadsheet.dialogs.register("fontFamily", FontFamilyDialog);

    var FontSizeDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.fontSizeDialog || MESSAGES;

            SpreadsheetDialog.fn.init.call(this, $.extend({ title: messages.title }, options));

            this._list();
        },
        options: {
            template: "<ul class='k-list k-reset'></ul>"
        },
        _list: function() {
            var ul = this.dialog().element.find("ul");
            var sizes = this.options.sizes;
            var defaultSize = this.options.defaultSize;

            this.list = new kendo.ui.StaticList(ul, {
                dataSource: new kendo.data.DataSource({ data: sizes }),
                template: "#: data #",
                value: defaultSize,
                change: this.apply.bind(this)
            });

            this.list.dataSource.fetch();
        },
        apply: function(e) {
            SpreadsheetDialog.fn.apply.call(this);

            this.trigger("action", {
                command: "PropertyChangeCommand",
                options: {
                    property: "fontSize",
                    value: kendo.parseInt(e.sender.value()[0])
                }
            });
        }
    });

    kendo.spreadsheet.dialogs.register("fontSize", FontSizeDialog);

    var BordersDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.bordersDialog || MESSAGES;

            SpreadsheetDialog.fn.init.call(this, $.extend({ title: messages.title }, options));

            this.element = this.dialog().element;
            this._borderPalette();

            this.viewModel = kendo.observable({
                apply: this.apply.bind(this),
                close: this.close.bind(this)
            });

            kendo.bind(this.element.find(".k-action-buttons"), this.viewModel);
        },
        options: {
            width: 177,
            template:   "<div></div>" +
                        "<div class='k-action-buttons'>" +
                            "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: apply'><span class='k-button-text'>#: messages.apply #</span></button>" +
                            "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: close'><span class='k-button-text'>#: messages.cancel #</span></button>" +
                        "</div>"
        },
        apply: function() {
            SpreadsheetDialog.fn.apply.call(this);

            var state = this.value();

            this.trigger("action", {
                command: "BorderChangeCommand",
                options: {
                    border: state.type,
                    style: { size: 1, color: state.color }
                }
            });
        },
        _borderPalette: function() {
            var element = this.dialog().element.find("div").first();

            this.borderPalette = new kendo.spreadsheet.BorderPalette(element, {
                change: this.value.bind(this)
            });
        },
        value: function(state) {
            if (state === undefined) {
                return this._state;
            } else {
                this._state = state;
            }
        }
    });

    kendo.spreadsheet.dialogs.register("borders", BordersDialog);

    var ColorChooser = SpreadsheetDialog.extend({
        init: function(options) {
            SpreadsheetDialog.fn.init.call(this, options);

            this.element = this.dialog().element;
            this.property = options.property;
            this.options.title = options.title;

            this.viewModel = kendo.observable({
                apply: this.apply.bind(this),
                close: this.close.bind(this)
            });

            kendo.bind(this.element.find(".k-action-buttons"), this.viewModel);
        },
        options: {
            template:   "<div></div>" +
                        "<div class='k-action-buttons'>" +
                            "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: apply'><span class='k-button-text'>#: messages.apply #</span></button>" +
                            "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: close'><span class='k-button-text'>#: messages.cancel #</span></button>" +
                        "</div>"
        },
        apply: function() {
            SpreadsheetDialog.fn.apply.call(this);

            this.trigger("action", {
                command: "PropertyChangeCommand",
                options: {
                    property: this.property,
                    value: this.value()
                }
            });
        },
        value: function(e) {
            if (e === undefined) {
                return this._value;
            } else {
                this._value = e.value;
            }
        }
    });

    var ColorPickerDialog = ColorChooser.extend({
        init: function(options) {
            options.width = 177;
            ColorChooser.fn.init.call(this, options);
            this._colorPalette();
        },
        _colorPalette: function() {
            var element = this.dialog().element.find("div").first();
            this.colorPalette = element.kendoColorPalette({
                palette: [ //metro palette
                    "#ffffff", "#000000", "#d6ecff", "#4e5b6f", "#7fd13b", "#ea157a", "#feb80a", "#00addc", "#738ac8", "#1ab39f",
                    "#f2f2f2", "#7f7f7f", "#a7d6ff", "#d9dde4", "#e5f5d7", "#fad0e4", "#fef0cd", "#c5f2ff", "#e2e7f4", "#c9f7f1",
                    "#d8d8d8", "#595959", "#60b5ff", "#b3bcca", "#cbecb0", "#f6a1c9", "#fee29c", "#8be6ff", "#c7d0e9", "#94efe3",
                    "#bfbfbf", "#3f3f3f", "#007dea", "#8d9baf", "#b2e389", "#f272af", "#fed46b", "#51d9ff", "#aab8de", "#5fe7d5",
                    "#a5a5a5", "#262626", "#003e75", "#3a4453", "#5ea226", "#af0f5b", "#c58c00", "#0081a5", "#425ea9", "#138677",
                    "#7f7f7f", "#0c0c0c", "#00192e", "#272d37", "#3f6c19", "#750a3d", "#835d00", "#00566e", "#2c3f71", "#0c594f"
                ],
                change: this.value.bind(this)
            }).data("kendoColorPalette");
        }
    });

    kendo.spreadsheet.dialogs.register("colorPicker", ColorPickerDialog);

    var CustomColorDialog = ColorChooser.extend({
        init: function(options) {
            options.width = 268;
            ColorChooser.fn.init.call(this, options);
            this.dialog().setOptions({ animation: false });
            this.dialog().one("activate", this._colorPicker.bind(this));
        },
        _colorPicker: function() {
            var element = this.dialog().element.find("div").first();
            this.colorPicker = element.kendoFlatColorPicker({
                change: this.value.bind(this)
            }).data("kendoFlatColorPicker");
        }
    });

    kendo.spreadsheet.dialogs.register("customColor", CustomColorDialog);

    var AlignmentDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.alignmentDialog || MESSAGES;
            var defaultOptions = {
                title: messages.title,
                buttons: [
                    { property: "textAlign",     value: "left",    iconClass: "align-left",   text: messages.buttons.justtifyLeft },
                    { property: "textAlign",     value: "center",  iconClass: "align-center", text: messages.buttons.justifyCenter },
                    { property: "textAlign",     value: "right",   iconClass: "align-right",  text: messages.buttons.justifyRight },
                    { property: "textAlign",     value: "justify", iconClass: "align-justify",   text: messages.buttons.justifyFull },
                    { property: "verticalAlign", value: "top",     iconClass: "align-top",      text: messages.buttons.alignTop },
                    { property: "verticalAlign", value: "center",  iconClass: "align-middle",   text: messages.buttons.alignMiddle },
                    { property: "verticalAlign", value: "bottom",  iconClass: "align-bottom",   text: messages.buttons.alignBottom }
                ]
            };

            SpreadsheetDialog.fn.init.call(this, $.extend(defaultOptions, options));

            this._list();
        },
        options: {
            template: "<ul class='k-list k-reset'></ul>"
        },
        _list: function() {
            var ul = this.dialog().element.find("ul");

            this.list = new kendo.ui.StaticList(ul, {
                dataSource: new kendo.data.DataSource({ data: this.options.buttons }),
                template: "<a role='button' title='#=text#' data-property='#=property#' data-value='#=value#'>" +
                                "<span class='k-icon k-i-#=iconClass#'></span>" +
                                "#=text#" +
                           "</a>",
                change: this.apply.bind(this)
            });

            this.list.dataSource.fetch();
        },
        apply: function(e) {
            var dataItem = e.sender.value()[0];
            SpreadsheetDialog.fn.apply.call(this);

            this.trigger("action", {
                command: "PropertyChangeCommand",
                options: {
                    property: dataItem.property,
                    value: dataItem.value
                }
            });
        }
    });

    kendo.spreadsheet.dialogs.register("alignment", AlignmentDialog);

    var MergeDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.mergeDialog || MESSAGES;
            var defaultOptions = {
                title: messages.title,
                buttons: [
                    { value: "cells",        iconClass: "cells-merge",        text: messages.buttons.mergeCells },
                    { value: "horizontally", iconClass: "cells-merge-horizontally", text: messages.buttons.mergeHorizontally },
                    { value: "vertically",   iconClass: "cells-merge-vertically",   text: messages.buttons.mergeVertically },
                    { value: "unmerge",      iconClass: "table-unmerge",      text: messages.buttons.unmerge }
                ]
            };

            SpreadsheetDialog.fn.init.call(this, $.extend(defaultOptions, options));

            this._list();
        },
        options: {
            template: "<ul class='k-list k-reset'></ul>"
        },
        _list: function() {
            var ul = this.dialog().element.find("ul");

            this.list = new kendo.ui.StaticList(ul, {
                dataSource: new kendo.data.DataSource({ data: this.options.buttons }),
                template: "<a role='button' title='#=text#' data-value='#=value#'>" +
                            "<span class='k-icon k-icon k-i-#=iconClass#'></span>#=text#" +
                          "</a>",
                change: this.apply.bind(this)
            });

            this.list.dataSource.fetch();
        },
        apply: function(e) {
            var dataItem = e.sender.value()[0];
            SpreadsheetDialog.fn.apply.call(this);

            this.trigger("action", {
                command: "MergeCellCommand",
                options: {
                    value: dataItem.value
                }
            });
        }
    });

    kendo.spreadsheet.dialogs.register("merge", MergeDialog);

    var FreezeDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.freezeDialog || MESSAGES;
            var defaultOptions = {
                title: messages.title,
                buttons: [
                    { value: "panes",    iconClass: "pane-freeze",  text: messages.buttons.freezePanes },
                    { value: "rows",     iconClass: "row-freeze",    text: messages.buttons.freezeRows },
                    { value: "columns",  iconClass: "column-freeze",    text: messages.buttons.freezeColumns },
                    { value: "unfreeze", iconClass: "table-unmerge", text: messages.buttons.unfreeze }
                ]
            };

            SpreadsheetDialog.fn.init.call(this, $.extend(defaultOptions, options));

            this._list();
        },
        options: {
            template: "<ul class='k-list k-reset'></ul>"
        },
        _list: function() {
            var ul = this.dialog().element.find("ul");

            this.list = new kendo.ui.StaticList(ul, {
                dataSource: new kendo.data.DataSource({ data: this.options.buttons }),
                template: "<a role='button' title='#=text#' data-value='#=value#'>" +
                            "<span class='k-icon k-icon k-i-#=iconClass#'></span>#=text#" +
                          "</a>",
                change: this.apply.bind(this)
            });

            this.list.dataSource.fetch();
        },
        apply: function(e) {
            var dataItem = e.sender.value()[0];
            SpreadsheetDialog.fn.apply.call(this);

            this.trigger("action", {
                command: "FreezePanesCommand",
                options: {
                    value: dataItem.value
                }
            });
        }
    });

    kendo.spreadsheet.dialogs.register("freeze", FreezeDialog);

    var ValidationViewModel = kendo.spreadsheet.ValidationCellsViewModel = ObservableObject.extend({
        init: function(options) {
            ObservableObject.fn.init.call(this, options);

            this.bind("change", (function(e) {

                if (e.field === "criterion") {
                    this.reset();

                    if (this.criterion === "custom" || this.criterion === "list") {
                        this.setHintMessageTemplate();
                    }
                }

                if (e.field === "comparer") {
                    this.setHintMessageTemplate();
                }

                if ((e.field == "hintMessage" || e.field == "hintTitle") && !this._mute) {
                    this.shouldBuild = false;
                }

                if ((e.field == "from" || e.field == "to" || e.field == "hintMessageTemplate" || e.field == "type") && this.shouldBuild) {
                    this.buildMessages();
                }
            }).bind(this));

            this.reset();
        },
        buildMessages: function() {
            this._mute = true;
            this.set("hintTitle", this.hintTitleTemplate ? kendo.format(this.hintTitleTemplate, this.type) : "");
            this.set("hintMessage", this.hintMessageTemplate ? kendo.format(this.hintMessageTemplate, this.from, this.to) : "");
            this._mute = false;
        },
        reset: function() {
            this.setComparers();
            this.set("comparer", this.comparers[0].type);
            this.set("from", null);
            this.set("to", null);

            this.set("useCustomMessages", false);

            this.shouldBuild = true;

            this.hintTitleTemplate = this.defaultHintTitle;
            this.buildMessages();
        },
        //TODO: refactor
        setComparers: function() {
            var all = this.defaultComparers;
            var comparers = [];

            if (this.criterion === "text") {
                var text_comparers = ["equalTo", "notEqualTo"];
                for (var idx = 0; idx < all.length; idx++) {
                    if (text_comparers[0] == all[idx].type) {
                        comparers.push(all[idx]);
                        text_comparers.shift();
                    }
                }
            } else {
                comparers = all.slice();
            }

            this.set("comparers", comparers);
        },
        setHintMessageTemplate: function() {
           if (this.criterion !== "custom" && this.criterion !== "list") {
               this.set("hintMessageTemplate", kendo.format(this.defaultHintMessage, this.criterion, this.comparerMessages[this.comparer]));
           } else {
               this.set("hintMessageTemplate", "");
               this.set("hintMessage", "");
           }
        },
        isAny: function() {
            return this.get("criterion") === "any";
        },
        isNumber: function() {
            return this.get("criterion") === "number";
        },
        showToForNumber: function() {
            return this.showTo() && this.isNumber();
        },
        showToForDate: function() {
            return this.showTo() && this.isDate();
        },
        isText: function() {
            return this.get("criterion") === "text";
        },
        isDate: function() {
            return this.get("criterion") === "date";
        },
        isList: function() {
            return this.get("criterion") === "list";
        },
        isCustom: function() {
            return this.get("criterion") === "custom";
        },
        showRemove: function() {
            return this.get("hasValidation");
        },
        showTo: function() {
            return this.get("comparer") == "between" || this.get("comparer") == "notBetween";
        },
        update: function(validation) {
            this.set("hasValidation", !!validation);

            if (validation) {
                this.fromValidationObject(validation);
            }
        },
        fromValidationObject: function(validation) {
            this.set("criterion", validation.dataType);
            this.set("comparer", validation.comparerType);
            this.set("from", validation.from);
            this.set("to", validation.to);
            this.set("type", validation.type);
            this.set("ignoreBlank", validation.allowNulls);
            this.set("showButton", validation.showButton);

            if (validation.messageTemplate || validation.titleTemplate) {
                this.hintMessageTemplate = validation.messageTemplate;
                this.hintMessage = validation.messageTemplate;
                this.hintTitleTemplate = validation.titleTemplate;
                this.hintTitle = validation.titleTemplate;
                this.useCustomMessages = true;
                this.buildMessages();
            } else {
                this.useCustomMessages = false;
            }
        },
        toValidationObject: function() {
            if (this.criterion === "any") {
                return null;
            }

            var options = {
                type: this.type,
                dataType: this.criterion,
                comparerType: this.comparer,
                from: this.from,
                to: this.to,
                allowNulls: this.ignoreBlank,
                showButton: this.showButton
            };

            if (this.useCustomMessages) {
                options.messageTemplate = this.shouldBuild ? this.hintMessageTemplate : this.hintMessage;
                options.titleTemplate = this.hintTitle;
            }

            return options;
        }
    });

    var ValidationDialog = SpreadsheetDialog.extend({
        init: function(options) {
            var messages = kendo.spreadsheet.messages.dialogs.validationDialog || MESSAGES;
            var defaultOptions = {
                title: messages.title,
                hintMessage: messages.hintMessage,
                hintTitle: messages.hintTitle,
                criteria: [
                    { type: "any", name: messages.criteria.any },
                    { type: "number", name: messages.criteria.number },
                    { type: "text", name: messages.criteria.text },
                    { type: "date", name: messages.criteria.date },
                    { type: "custom", name: messages.criteria.custom },
                    { type: "list", name: messages.criteria.list }
                ],
                comparers: [
                    { type: "greaterThan", name: messages.comparers.greaterThan },
                    { type: "lessThan",    name: messages.comparers.lessThan },
                    { type: "between",     name: messages.comparers.between },
                    { type: "notBetween",  name: messages.comparers.notBetween },
                    { type: "equalTo",     name: messages.comparers.equalTo },
                    { type: "notEqualTo",  name: messages.comparers.notEqualTo },
                    { type: "greaterThanOrEqualTo", name: messages.comparers.greaterThanOrEqualTo },
                    { type: "lessThanOrEqualTo",    name: messages.comparers.lessThanOrEqualTo }
                ],
                comparerMessages: messages.comparerMessages
            };

            SpreadsheetDialog.fn.init.call(this, $.extend(defaultOptions, options));
        },
        options: {
            width: 450,
            criterion: "any",
            type: "reject",
            ignoreBlank: true,
            showButton: true,
            useCustomMessages: false,
            errorTemplate:
                '<div class="k-tooltip k-tooltip-error k-validator-tooltip">' +
                    '<span class="k-tooltip-icon k-icon k-i-warning"></span>' +
                    '<span class="k-tooltip-content">#= message #</span>' +
                    '<span class="k-callout k-callout-n"></span>' +
                '</div>',
            template:
                '<div class="k-edit-form-container">' +
                    '<div class="k-edit-label"><label for="criteria">#: messages.validationDialog.labels.criteria #:</label></div>' +
                    '<div class="k-edit-field">' +
                        '<select id="criteria" data-#:ns#role="dropdownlist" ' +
                            'title="#: messages.validationDialog.labels.criteria #"' +
                            'data-#:ns#text-field="name" ' +
                            'data-#:ns#value-field="type" ' +
                            'data-#:ns#bind="value: criterion, source: criteria"></select>' +
                    '</div>' +

                    '<div data-#:ns#bind="visible: isNumber">' +
                        '<div class="k-edit-label"><label for="number-comparer">#: messages.validationDialog.labels.comparer #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<select id="number-comparer" data-#:ns#role="dropdownlist" ' +
                                'title="#: messages.validationDialog.labels.comparer #"' +
                                'data-#:ns#text-field="name" ' +
                                'data-#:ns#value-field="type" ' +
                                'data-#:ns#bind="value: comparer, source: comparers"></select>' +
                        '</div>' +
                        '<div class="k-edit-label"><label for="comparer-min">#: messages.validationDialog.labels.min #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="comparer-min" name="#: messages.validationDialog.labels.min #" title="#: messages.validationDialog.labels.min #" placeholder="e.g. 10" class="k-input-inner" data-#:ns#bind="value: from, enabled: isNumber" required="required" /></span>' +
                        '</div>' +
                        '<div data-#:ns#bind="visible: showTo">' +
                            '<div class="k-edit-label"><label for="comparer-max">#: messages.validationDialog.labels.max #:</label></div>' +
                            '<div class="k-edit-field">' +
                                '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="comparer-max" name="#: messages.validationDialog.labels.max #" title="#: messages.validationDialog.labels.max #" placeholder="e.g. 100" class="k-input-inner" data-#:ns#bind="value: to, enabled: showToForNumber" required="required" /></span>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +

                    '<div data-#:ns#bind="visible: isText">' +
                        '<div class="k-edit-label"><label for="text-comparer">#: messages.validationDialog.labels.comparer #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<select id="text-comparer" data-#:ns#role="dropdownlist" ' +
                                'title="#: messages.validationDialog.labels.comparer #"' +
                                'data-#:ns#text-field="name" ' +
                                'data-#:ns#value-field="type" ' +
                                'data-#:ns#bind="value: comparer, source: comparers"></select>' +
                        '</div>' +
                        '<div class="k-edit-label"><label for="text-comparer-value">#: messages.validationDialog.labels.value #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="text-comparer-value" name="#: messages.validationDialog.labels.value #" title="#: messages.validationDialog.labels.value #" class="k-input-inner" data-#:ns#bind="value: from, enabled: isText" required="required" /></span>' +
                        '</div>' +
                    '</div>' +

                    '<div data-#:ns#bind="visible: isDate">' +
                        '<div class="k-edit-label"><label for="date-comparer">#: messages.validationDialog.labels.comparer #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<select id="date-comparer" data-#:ns#role="dropdownlist" ' +
                                'title="#: messages.validationDialog.labels.comparer #"' +
                                'data-#:ns#text-field="name" ' +
                                'data-#:ns#value-field="type" ' +
                                'data-#:ns#bind="value: comparer, source: comparers"></select>' +
                        '</div>' +
                        '<div class="k-edit-label"><label for="date-comparer-start">#: messages.validationDialog.labels.start #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="date-comparer-start" name="#: messages.validationDialog.labels.start #" title="#: messages.validationDialog.labels.start #" class="k-input-inner" data-#:ns#bind="value: from, enabled: isDate" required="required" /></span>' +
                        '</div>' +
                        '<div data-#:ns#bind="visible: showTo">' +
                            '<div class="k-edit-label"><label for="date-comparer-end">#: messages.validationDialog.labels.end #:</label></div>' +
                            '<div class="k-edit-field">' +
                                '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="date-comparer-end" name="#: messages.validationDialog.labels.end #" title="#: messages.validationDialog.labels.end #" class="k-input-inner" data-#:ns#bind="value: to, enabled: showToForDate" required="required" /></span>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +

                    '<div data-#:ns#bind="visible: isCustom">' +
                        '<div class="k-edit-label"><label for="custom-comparer-value">#: messages.validationDialog.labels.value #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="custom-comparer-value" name="#: messages.validationDialog.labels.value #" title="#: messages.validationDialog.labels.value #" class="k-input-inner" data-#:ns#bind="value: from, enabled: isCustom" required="required" /></span>' +
                        '</div>' +
                    '</div>' +

                    '<div data-#:ns#bind="visible: isList">' +
                        '<div class="k-edit-label"><label for="list-comparer-value">#: messages.validationDialog.labels.value #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="list-comparer-value" name="#: messages.validationDialog.labels.value #" title="#: messages.validationDialog.labels.value #" class="k-input-inner" data-#:ns#bind="value: from, enabled: isList" required="required" /></span>' +
                        '</div>' +
                    '</div>' +

                    '<div data-#:ns#bind="visible: isList">' +
                        '<div class="k-edit-field">' +
                            '<input type="checkbox" name="showButton" id="listShowButton" class="k-checkbox k-checkbox-md k-rounded-md" data-#:ns#bind="checked: showButton"/>' +
                            '<label for="listShowButton" class="k-checkbox-label">' +
                                ' #: messages.validationDialog.labels.showListButton #' +
                            '</label>' +
                        '</div>' +
                    "</div>" +

                    '<div data-#:ns#bind="visible: isDate">' +
                        '<div class="k-edit-field">' +
                            '<input type="checkbox" name="showButton" id="dateShowButton" class="k-checkbox k-checkbox-md k-rounded-md" data-#:ns#bind="checked: showButton"/>' +
                            '<label for="dateShowButton" class="k-checkbox-label">' +
                                ' #: messages.validationDialog.labels.showCalendarButton #' +
                            '</label>' +
                        '</div>' +
                    "</div>" +

                    '<div data-#:ns#bind="invisible: isAny">' +
                        '<div class="k-edit-field">' +
                            '<input type="checkbox" title="#: messages.validationDialog.labels.ignoreBlank #" name="ignoreBlank" id="ignoreBlank" class="k-checkbox k-checkbox-md k-rounded-md" data-#:ns#bind="checked: ignoreBlank"/>' +
                            '<label for="ignoreBlank" class="k-checkbox-label">' +
                                ' #: messages.validationDialog.labels.ignoreBlank #' +
                            '</label>' +
                        '</div>' +
                    '</div>' +

                    '<div data-#:ns#bind="invisible: isAny">' +
                        '<div class="k-hr"></div>' +
                        '<div class="k-edit-label"><label>#: messages.validationDialog.labels.onInvalidData #:</label></div>' +
                        '<div class="k-edit-field">' +
                            '<input type="radio" title="#: messages.validationDialog.labels.rejectInput #" id="validationTypeReject" name="validationType" value="reject" data-#:ns#bind="checked: type" class="k-radio k-radio-md" />' +
                            '<label for="validationTypeReject" class="k-radio-label">' +
                                 "#: messages.validationDialog.labels.rejectInput #" +
                            '</label> ' +
                            '<input type="radio" title="#: messages.validationDialog.labels.showWarning #" id="validationTypeWarning"  name="validationType" value="warning" data-#:ns#bind="checked: type" class="k-radio k-radio-md" />' +
                            '<label for="validationTypeWarning" class="k-radio-label">' +
                                 "#: messages.validationDialog.labels.showWarning #" +
                            '</label>' +
                        '</div>' +
                    '</div>' +

                    '<div data-#:ns#bind="invisible: isAny" class="hint-wrapper">' +
                        '<div class="k-edit-field">' +
                            '<input type="checkbox" title="#: messages.validationDialog.labels.showHint #" name="useCustomMessages" id="useCustomMessages" class="k-checkbox k-checkbox-md k-rounded-md" data-#:ns#bind="checked: useCustomMessages" />' +
                            '<label class="k-checkbox-label" for="useCustomMessages">'+
                                ' #: messages.validationDialog.labels.showHint #' +
                            '</label>' +
                        '</div>' +
                        '<div data-#:ns#bind="visible: useCustomMessages">' +
                            '<div class="k-edit-label"><label for="hint-title">#: messages.validationDialog.labels.hintTitle #:</label></div>' +
                            '<div class="k-edit-field">' +
                                '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="hint-title" name="hint-title" class="k-input-inner" title="#: messages.validationDialog.labels.hintTitle #" placeholder="#: messages.validationDialog.placeholders.typeTitle #" data-#:ns#bind="value: hintTitle" /></span>' +
                            '</div>' +
                            '<div class="k-edit-label"><label for="hint-message">#: messages.validationDialog.labels.hintMessage #:</label></div>' +
                            '<div class="k-edit-field">' +
                                '<span class="k-textbox k-input k-input-md k-rounded-md k-input-solid"><input id="hint-message" class="k-input-inner" title="#: messages.validationDialog.labels.hintMessage #" placeholder="#: messages.validationDialog.placeholders.typeMessage #" data-#:ns#bind="value: hintMessage" /></span>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +

                    '<div class="k-action-buttons">' +
                        '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base" data-#:ns#bind="visible: showRemove, click: remove"><span class="k-button-text">#: messages.remove #</span></button>' +
                        '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary" data-#:ns#bind="click: apply"><span class="k-button-text">#: messages.apply #</span></button>' +
                        '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base" data-#:ns#bind="click: close"><span class="k-button-text">#: messages.cancel #</span></button>' +
                    "</div>" +
                "</div>"
        },
        open: function(range) {
            var options = this.options;
            var element;

            this.viewModel = new ValidationViewModel({
                type: options.type,
                defaultHintMessage: options.hintMessage,
                defaultHintTitle: options.hintTitle,
                defaultComparers: options.comparers.slice(0),
                comparerMessages: options.comparerMessages,
                criteria: options.criteria.slice(0),
                criterion: options.criterion,
                ignoreBlank: options.ignoreBlank,
                showButton: options.showButton,
                apply: this.apply.bind(this),
                close: this.close.bind(this),
                remove: this.remove.bind(this)
            });

            this.viewModel.update(range.validation());

            SpreadsheetDialog.fn.open.call(this);

            element = this.dialog().element;

            if (this.validatable) {
                this.validatable.destroy();
            }

            kendo.bind(element, this.viewModel);

            this.validatable = new kendo.ui.Validator(element.find(".k-edit-form-container"), {
                validateOnBlur: false,
                errorTemplate: this.options.errorTemplate || undefined
            });
        },
        apply: function() {

            if (this.validatable.validate()) {
                SpreadsheetDialog.fn.apply.call(this);

                this.trigger("action", {
                    command: "EditValidationCommand",
                    options: {
                        value: this.viewModel.toValidationObject()
                    }
                });
            }
        },
        remove: function() {
            this.viewModel.set("criterion", "any");
            this.apply();
        }
    });

    kendo.spreadsheet.dialogs.register("validation", ValidationDialog);
    kendo.spreadsheet.dialogs.ValidationDialog = ValidationDialog;

    function PDF_PAPER_SIZE(size) {
        return {
            value: size,
            text: TEXT("exportAsDialog.pdf.paper." + size)
        };
    }

    var ExportAsDialog = SpreadsheetDialog.extend({
        init: function(options) {
            SpreadsheetDialog.fn.init.call(this, options);
            options = this.options;

            this.viewModel = kendo.observable({
                title: options.title,
                name: options.name,
                extension: options.extension,
                fileFormats:options.fileFormats,
                excel: options.excelExport,
                pdf: {
                    proxyURL: options.pdfExport.proxyURL,
                    forceProxy: options.pdfExport.forceProxy,
                    title: options.pdfExport.title,
                    author: options.pdfExport.author,
                    autoPrint: options.pdfExport.autoPrint,
                    subject: options.pdfExport.subject,
                    keywords: options.pdfExport.keywords,
                    creator: options.pdfExport.creator,
                    date: options.pdfExport.date,

                    fitWidth: options.pdf.fitWidth,
                    area: options.pdf.area,
                    areas: options.pdf.areas,
                    paperSize: options.pdf.paperSize,
                    paperSizes: options.pdf.paperSizes,
                    margin: options.pdf.margin,
                    margins: options.pdf.margins,
                    landscape: options.pdf.landscape,
                    guidelines: options.pdf.guidelines,
                    hCenter: options.pdf.hCenter,
                    vCenter: options.pdf.vCenter
                },
                apply: this.apply.bind(this),
                close: this.close.bind(this)
            });

            var dialog = this.dialog();
            this.viewModel.bind("change", function(e) {
                if (e.field === "extension") {
                    this.set("showPdfOptions", this.extension === ".pdf" ? true : false);
                    dialog.center();
                }
            });

            kendo.bind(dialog.element, this.viewModel);
        },
        options: {
            title: TEXT("exportAsDialog.title", "Export..."),
            name: TEXT("exportAsDialog.defaultFileName", "Workbook"),
            extension: ".xlsx",
            fileFormats: [{
                description: TEXT("exportAsDialog.xlsx.description", "Excel Workbook (.xlsx)"),
                extension: ".xlsx"
            }, {
                description: TEXT("exportAsDialog.pdf.description", "Portable Document Format (.pdf)"),
                extension: ".pdf"
            }],
            pdf: {
                fitWidth: true,
                area: "workbook",
                areas: [{
                    area: "workbook",
                    text: TEXT("exportAsDialog.pdf.area.workbook", "Entire Workbook")
                },{
                    area: "sheet",
                    text: TEXT("exportAsDialog.pdf.area.sheet", "Active Sheet")
                },{
                    area: "selection",
                    text: TEXT("exportAsDialog.pdf.area.selection", "Selection")
                }],
                paperSize: "a4",
                paperSizes: [
                    "a2", "a3", "a4", "a5", "b3", "b4", "b5", "folio", "legal", "letter", "tabloid", "executive"
                ].map(PDF_PAPER_SIZE),
                margin: {bottom: "0.75in", left: "0.7in", right: "0.7in", top: "0.75in"},
                margins: [
                    { value: { bottom: "0.75in", left: "0.7in", right: "0.7in", top: "0.75in" },
                      text: TEXT("exportAsDialog.pdf.margin.normal", "Normal")
                    },
                    { value: { bottom: "0.75in", left: "0.25in", right: "0.25in", top: "0.75in" },
                      text: TEXT("exportAsDialog.pdf.margin.narrow", "Narrow")
                    },
                    { value: { bottom: "1in", left: "1in", right: "1in", top: "1in" },
                      text: TEXT("exportAsDialog.pdf.margin.wide", "Wide")
                    }
                ],
                landscape: true,
                guidelines: true,
                hCenter: true,
                vCenter: true
            },
            width: 520,
            template:
                "<div class='k-edit-label'><label id='name-label'>#: messages.exportAsDialog.labels.fileName #:</label></div>" +
                "<div class='k-edit-field'>" +
                    "<span class='k-textbox k-input k-input-md k-rounded-md k-input-solid'><input aria-labelledby='name-label' class='k-input-inner' data-#:ns#bind='value: name' /></span>" +
                "</div>" +
                "<div >" +
                    "<div class='k-edit-label'><label id='file-format-label'>#: messages.exportAsDialog.labels.saveAsType #:</label></div>" +
                    "<div class='k-edit-field'>" +
                    "<select aria-labelledby='file-format-label' data-#:ns#role='dropdownlist' class='k-file-format' " +
                        "data-#:ns#text-field='description' " +
                        "data-#:ns#value-field='extension' " +
                        "data-#:ns#bind='value: extension, source: fileFormats'></select>" +
                    "</div>" +
                "</div>" +
                "<div class='k-export-config' data-#:ns#bind='visible: showPdfOptions'>" +
                    "<hr class='k-hr' />" +
                    "<div class='k-edit-label'><label id='export-area-label'>#: messages.exportAsDialog.labels.exportArea #:</label></div>" +
                    "<div class='k-edit-field'>" +
                        "<select aria-labelledby='export-area-label' data-#:ns#role='dropdownlist' class='k-file-format' " +
                            "data-#:ns#text-field='text' " +
                            "data-#:ns#value-field='area' " +
                            "data-#:ns#bind='value: pdf.area, source: pdf.areas'></select>" +
                    "</div>" +
                    "<div class='k-edit-label'><label id='paper-size-label'>#: messages.exportAsDialog.labels.paperSize#:</label></div>" +
                    "<div class='k-edit-field'>" +
                        "<select aria-labelledby='paper-size-label' data-#:ns#role='dropdownlist' class='k-file-format' " +
                            "data-#:ns#text-field='text' " +
                            "data-#:ns#value-field='value' " +
                            "data-#:ns#bind='value: pdf.paperSize, source: pdf.paperSizes'></select>" +
                    "</div>" +
                    "<div class='k-edit-label'><label id='margins-label'>#: messages.exportAsDialog.labels.margins #:</label></div>" +
                    "<div class='k-edit-field'>" +
                        "<select aria-labelledby='margins-label' data-#:ns#role='dropdownlist' class='k-file-format' " +
                            "data-#:ns#value-primitive='true'" +
                            "data-#:ns#text-field='text' " +
                            "data-#:ns#value-field='value' " +
                            "data-#:ns#bind='value: pdf.margin, source: pdf.margins'></select>" +
                    "</div>" +
                    "<div class='k-edit-label'><label>#: messages.exportAsDialog.labels.orientation #:</label></div>" +
                    "<div class='k-edit-field'>" +
                        "<div class='k-button-group'>" +
                            "<input type='radio' id='k-orientation-portrait' aria-label='orientation portrait' name='orientation' data-#:ns#type='boolean' data-#:ns#bind='checked: pdf.landscape' value='false' />" +
                            "<label class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-group-start k-orientation-button' for='k-orientation-portrait'><span class='k-button-icon k-icon k-i-page-portrait'></span></label>" +
                            "<input type='radio' id='k-orientation-landscape' aria-label='orientation landscape' name='orientation' data-#:ns#type='boolean' data-#:ns#bind='checked: pdf.landscape' value='true' />" +
                            "<label class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-group-end k-orientation-button' for='k-orientation-landscape'><span class='k-button-icon k-icon k-i-page-landscape'></span></label>" +
                        "</div>" +
                    "</div>" +
                    "<div class='k-edit-label'><label>#: messages.exportAsDialog.labels.print #:</label></div>" +
                    "<div class='k-edit-field'>" +
                        "<input class='k-checkbox k-checkbox-md k-rounded-md' id='guidelines' type='checkbox' data-#:ns#bind='checked: pdf.guidelines'/><label class='k-checkbox-label' for='guidelines'>#: messages.exportAsDialog.labels.guidelines#</label>" +
                    "</div>" +
                    "<div class='k-edit-label'><label>#: messages.exportAsDialog.labels.scale #:</label></div>" +
                    "<div class='k-edit-field'>" +
                        "<input class='k-checkbox k-checkbox-md k-rounded-md' id='fitWidth' type='checkbox' data-#:ns#bind='checked: pdf.fitWidth'/><label class='k-checkbox-label' for='fitWidth'>#: messages.exportAsDialog.labels.fit #</label>" +
                    "</div>" +
                    "<div class='k-edit-label'><label>#: messages.exportAsDialog.labels.center #:</label></div>" +
                    "<div class='k-edit-field'>" +
                        "<input class='k-checkbox k-checkbox-md k-rounded-md' id='hCenter' type='checkbox' data-#:ns#bind='checked: pdf.hCenter'/><label class='k-checkbox-label' for='hCenter'>#: messages.exportAsDialog.labels.horizontally #</label>" +
                        "<input class='k-checkbox k-checkbox-md k-rounded-md' id='vCenter' type='checkbox' data-#:ns#bind='checked: pdf.vCenter'/><label class='k-checkbox-label' for='vCenter'>#: messages.exportAsDialog.labels.vertically #</label>" +
                    "</div>" +
                    "<div class='k-page-orientation'>" +
                        "<span class='k-icon k-i-page-portrait' data-#:ns#bind='invisible: pdf.landscape'></span>" +
                        "<span class='k-icon k-i-page-landscape' data-#:ns#bind='visible: pdf.landscape'></span>" +
                    "</div>" +
                "</div>" +
                "<div class='k-action-buttons'>" +
                    "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: apply'><span class='k-button-text'>#: messages.save #</span></button>" +
                    "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: close'><span class='k-button-text'>#: messages.cancel #</span></button>" +
                "</div>"
        },
        apply: function() {
            SpreadsheetDialog.fn.apply.call(this);

            this.trigger("action", {
                command: "SaveAsCommand",
                options: this.viewModel
            });
        }
    });
    kendo.spreadsheet.dialogs.register("exportAs", ExportAsDialog);

    function basicErrorDialog(id, msg) {
        kendo.spreadsheet.dialogs.register(
            id,
            MessageDialog.extend({
                options: { messageId: msg }
            })
        );
    }

    basicErrorDialog("modifyMerged", "modifyMergedDialog.errorMessage");
    basicErrorDialog("rangeDisabled", "rangeDisabledDialog.errorMessage");
    basicErrorDialog("intersectsArray", "intersectsArrayDialog.errorMessage");
    basicErrorDialog("overflow", "overflowDialog.errorMessage");
    basicErrorDialog("unsupportedSelection", "unsupportedSelectionDialog.errorMessage");
    basicErrorDialog("incompatibleRanges", "incompatibleRangesDialog.errorMessage");
    basicErrorDialog("noFillDirection", "noFillDirectionDialog.errorMessage");
    basicErrorDialog("duplicateSheetName", "duplicateSheetNameDialog.errorMessage");

    var ImportErrorDialog = MessageDialog.extend({
        options: {
            width: 640,
            title: "Errors in import",
            template:
                "<div class='k-spreadsheet-message-content k-spreadsheet-import-errors'>" +
                  "<div class='k--header-message'>We encountered #= errors.length # errors while reading this file.  Please be aware that some formulas might be missing, or contain invalid results.</div>" +
                  "<div class='k--errors'>" +
                    "<table>" +
                      "<thead>" +
                        "<tr><th>Context</th><th>Error message</th></tr>" +
                      "</thead>" +
                      "# for (var i = 0; i < errors.length; ++i) { #" +
                        "# var err = errors[i]; #" +
                        "<tr><td>#: err.context #</td><td>#: err.error #</td></tr>" +
                      "# } #" +
                    "</table>" +
                  "</div>" +
                "</div>" +
                "<div class='k-action-buttons'>" +
                  "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: close'>" +
                    "<span class='k-button-text'>#: messages.okText #</span>" +
                  "</button>" +
                "</div>"
        }
    });

    kendo.spreadsheet.dialogs.register("importError", ImportErrorDialog);

    var UseKeyboardDialog = MessageDialog.extend({
        options: {
            title: TEXT("useKeyboardDialog.title", "Copying and pasting"),
            template:
                "#: messages.useKeyboardDialog.errorMessage #" +
                "<div>Ctrl+C #: messages.useKeyboardDialog.labels.forCopy #</div>" +
                "<div>Ctrl+X #: messages.useKeyboardDialog.labels.forCut #</div>" +
                "<div>Ctrl+V #: messages.useKeyboardDialog.labels.forPaste #</div>" +
                '<div class="k-action-buttons">' +
                    "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: close'>" +
                        "<span class='k-button-text'>#= messages.okText #</span>" +
                    "</button>" +
                "</div>"
        }
    });

    kendo.spreadsheet.dialogs.register("useKeyboard", UseKeyboardDialog);

    var HyperlinkDialog = SpreadsheetDialog.extend({
        options: {
            title: TEXT("linkDialog.title", "Hyperlink"),
            template:
            ("<div class='k-edit-label'><label id='url-label'>#: messages.linkDialog.labels.url #:</label></div>" +
             "<div class='k-edit-field'><span class='k-textbox k-input k-input-md k-rounded-md k-input-solid'><input class='k-input-inner' data-#:ns#bind='value: url' title='#: messages.linkDialog.labels.url #' aria-labelledby='url-label'/></span></div>" +
             "<div class='k-action-buttons'>" + (
                 ("<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-left' data-#:ns#bind='click: remove'><span class='k-button-text'>#= messages.linkDialog.labels.removeLink #</span></button>" +
                  "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: apply'><span class='k-button-text'>#= messages.okText #</span></button>" +
                  "<button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: cancel'><span class='k-button-text'>#= messages.cancel #</span></button>")
             ) + "</div>"
            ),
            autoFocus: false
        },
        open: function(range) {
            var self = this;
            SpreadsheetDialog.fn.open.apply(self, arguments);
            var element = self.dialog().element;
            var model = kendo.observable({
                url: range.link(),
                apply: function() {
                    if (!/\S/.test(model.url)) {
                        model.url = null;
                    }
                    self.trigger("action", {
                        command: "HyperlinkCommand",
                        options: {
                            link: model.url
                        }
                    });
                    self.close();
                },
                remove: function() {
                    model.url = null;
                    model.apply();
                },
                cancel: self.close.bind(self)
            });
            kendo.bind(element, model);

            // it would be nice if we could easily handle that in one
            // place for all dialogs, but it doesn't seem easily
            // doable.
            element.find("input")
                .trigger("focus")
                .on("keydown", function(ev){
                    if (ev.keyCode == 13 /*ENTER*/) {
                        model.url = $(this).val(); // there won't be a "change" event and the model wouldn't update :-\
                        ev.stopPropagation();
                        ev.preventDefault();
                        model.apply();
                    } else if (ev.keyCode == 27 /*ESC*/) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        model.cancel();
                    }
                });
        }
    });

    kendo.spreadsheet.dialogs.register("hyperlink", HyperlinkDialog);

    var InsertCommentDialog = SpreadsheetDialog.extend({
        options: {
            className: "k-spreadsheet-insert-comment",
            template: "\
<div class='k-edit-label'><label id='comment-label'>#: messages.insertCommentDialog.labels.comment #:</label></div>\
<div class='k-edit-field'><span class='k-input k-textarea k-input-solid k-input-md k-rounded-md'><textarea aria-labelledby='comment-label' rows='5' class='k-input-inner' data-#:ns#bind='value: comment'></textarea></span></div>\
<div class='k-action-buttons'>\
  <button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-left' data-#:ns#bind='click: remove'><span class='k-button-text'>#: messages.insertCommentDialog.labels.removeComment #</span></button>\
  <button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='click: apply'><span class='k-button-text'>#: messages.okText #</span></button>\
  <button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: cancel'><span class='k-button-text'>#= messages.cancel #</span></button>\
</div>\
",
            title: TEXT("insertCommentDialog.title", "Insert comment"),
            autoFocus: false,
            width: 450
        },
        open: function(range) {
            var self = this;
            SpreadsheetDialog.fn.open.apply(self, arguments);
            var element = self.dialog().element;
            var model = kendo.observable({
                comment: range.comment(),
                apply: function() {
                    if (!/\S/.test(model.comment)) {
                        model.comment = null;
                    }
                    self.trigger("action", {
                        command: "InsertCommentCommand",
                        options: {
                            value: model.comment
                        }
                    });
                    self.close();
                },
                remove: function() {
                    model.comment = null;
                    model.apply();
                },
                cancel: self.close.bind(self)
            });
            kendo.bind(element, model);

            element.find("textarea").trigger("focus");
        }
    });

    kendo.spreadsheet.dialogs.register("insertComment", InsertCommentDialog);

    var InsertImageDialog = SpreadsheetDialog.extend({
        options: {
            template: "\
<div class='k-spreadsheet-insert-image-dialog'>\
  <label data-#:ns#bind='style: { background-image: imageUrl },\
                    css: { k-spreadsheet-has-image: hasImage, k-hover: isHovered },\
                    events: { dragenter: dragEnter, dragover: stopEvent, dragleave: dragLeave, drop: drop }'>\
    <div data-#:ns#bind='text: info'></div>\
    <input type='file' data-#:ns#bind='events: { change: change }'\
           accept='image/png, image/jpeg, image/gif' />\
  </label>\
</div>\
<div class='k-action-buttons'>\
  <button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary' data-#:ns#bind='enabled: okEnabled, click: apply'><span class='k-button-text'>#: messages.okText #</span></button>\
  <button class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base' data-#:ns#bind='click: cancel'><span class='k-button-text'>#= messages.cancel #</span></button>\
</div>",
            title: TEXT("insertImageDialog.title", "Insert image"),
            width: "auto"
        },
        open: function() {
            var self = this;
            SpreadsheetDialog.fn.open.apply(self, arguments);
            var element = self.dialog().element;
            var model = kendo.observable({
                okEnabled: false,
                info: kendo.spreadsheet.messages.dialogs.insertImageDialog.info,
                imageUrl: "",
                hasImage: false,
                isHovered: false,
                _url: null,
                _image: null,
                apply: function() {
                    window.URL.revokeObjectURL(model._url);
                    self.trigger("action", {
                        command: "InsertImageCommand",
                        options: {
                            blob   : model._image,
                            width  : model._width,
                            height : model._height
                        }
                    });
                    self.close();
                },
                cancel: self.close.bind(self),
                stopEvent: function(ev) {
                    ev.stopPropagation();
                    ev.preventDefault();
                },
                drop: function(ev) {
                    model.stopEvent(ev);
                    model.selectFile(ev.originalEvent.dataTransfer.files);
                    model.set("isHovered", false);
                },
                dragEnter: function(ev) {
                    model.stopEvent(ev);
                    model.set("isHovered", true);
                },
                dragLeave: function(ev) {
                    model.stopEvent(ev);
                    model.set("isHovered", false);
                },
                change: function(ev) {
                    model.selectFile(ev.target.files);
                },
                selectFile: function(files) {
                    var image;
                    for (var i = 0; i < files.length; ++i) {
                        if (/^image\//i.test(files[i].type)) {
                            image = files[i];
                            break;
                        }
                    }
                    if (model._url) {
                        window.URL.revokeObjectURL(model._url);
                    }
                    if (image) {
                        model._image = image;
                        model._url = window.URL.createObjectURL(image);
                        var img = new Image();
                        img.src = model._url;
                        img.onload = function() {
                            model._width = img.width;
                            model._height = img.height;
                            model.set("info", kendo.spreadsheet.messages.dialogs.insertImageDialog.info);
                            model.set("okEnabled", true);
                            model.set("imageUrl", "url('" + model._url + "')");
                            model.set("hasImage", true);
                        };
                    } else {
                        model._image = null;
                        model.set("info", kendo.spreadsheet.messages.dialogs.insertImageDialog.typeError);
                        model.set("okEnabled", false);
                        model.set("imageUrl", "");
                        model.set("hasImage", false);
                    }
                }
            });
            kendo.bind(element, model);
        }
    });

    kendo.spreadsheet.dialogs.register("insertImage", InsertImageDialog);

    function Localizable(path, def) {
        this.path = path.split(".");
        this.def = def;
    }

    Localizable.prototype.trans = function() {
        var msg = kendo.spreadsheet.messages.dialogs;
        for (var i = 0; i < this.path.length; ++i) {
            msg = msg[this.path[i]];
            if (!msg) {
                return this.def;
            }
        }
        return msg;
    };

    function TEXT(path, def) {
        return new Localizable(path, def);
    }

    function translate(thing) {
        if (thing instanceof Localizable) {
            return thing.trans();
        }
        else if (Array.isArray(thing)) {
            return thing.map(translate);
        }
        else if (thing != null && typeof thing == "object") {
            return Object.keys(thing).reduce(function(ret, key){
                ret[key] = translate(thing[key]);
                return ret;
            }, {});
        }
        return thing;
    }

})(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/sheetbinder',[ "../kendo.core", "../kendo.data", "./sheet" ], f);
})(function(){

(function(kendo) {

    var identity = function(o) { return o; };

    var SheetDataSourceBinder = kendo.Class.extend({
        init: function(options) {

            this.options = kendo.jQuery.extend({}, this.options, options);

            this.columns = this._normalizeColumns(this.options.columns);

            this._sheet();
            this._dataSource();

            this._header();

            this._boundRowsCount = 0;

            this.dataSource.fetch();
        },

        _sheet: function() {
            this.sheet = this.options.sheet;

            this._sheetChangeHandler = this._sheetChange.bind(this);
            this._sheetDeleteRowHandler = this._sheetDeleteRow.bind(this);
            this._sheetInsertRowHandler = this._sheetInsertRow.bind(this);

            this.sheet.bind("change", this._sheetChangeHandler)
                .bind("afterDeleteRow", this._sheetDeleteRowHandler)
                .bind("afterInsertRow", this._sheetInsertRowHandler);
        },

        _sheetInsertRow: function(e) {
            if (e.index !== undefined) {
                this.dataSource.insert(Math.max(e.index - 1, 0), {});
            }
        },

        _sheetDeleteRow: function(e) {
            if (e.index !== undefined) {
                var dataSource = this.dataSource;
                var model = dataSource.view()[e.index - 1];

                if (model) {
                    dataSource.remove(model);
                }
            }
        },

        _header: function() {
            this.sheet.batch(function() {
                this.columns.forEach(function(column, index) {
                    this.sheet.range(0,index).value(column.title);
                }.bind(this));
            }.bind(this));
        },

        _sheetChange: function(e) {
            if (e.insertRow || e.deleteRow) {
                // these actions are handled via custom events
                return;
            }

            if (e.recalc && e.ref) {
                var UnionRef = kendo.spreadsheet.UnionRef;
                var dataSource = this.dataSource;
                var data = dataSource.view();
                var columns = this.columns;
                var values = [];
                var sheet = this.sheet;
                var fields, getters, normalizedRef, i, rangeRef, normalizedRefs;
                var setValues = function(ref) {
                    ref = ref.toRangeRef();
                    var record;
                    var valueIndex = 0;
                    for (var ri = ref.topLeft.row; ri <= ref.bottomRight.row; ri++) {
                        record = data[ri - 1]; // skip header row

                        if (!record) {
                            record = dataSource.insert(ri - 1, {});
                            data = dataSource.view();
                        }

                        var colValueIndex = 0;
                        for (var ci = ref.topLeft.col; ci <= ref.bottomRight.col && ci < columns.length; ci++) {
                            var currentValue = values[i][valueIndex][colValueIndex++];
                            record.set(columns[ci].field, getters[ci](currentValue));
                        }
                        valueIndex++;
                    }
                };

                if (dataSource.reader.model) {
                    fields = dataSource.reader.model.fields;
                }

                if (!columns.length && data.length) {
                    columns = Object.keys(data[0].toJSON());
                }

                getters = columns.map(function(column) {
                    var field = column.field;
                    if (field && fields && fields[field] && fields[field].type == "date") {
                        return kendo.spreadsheet.numberToDate;
                    }
                    return identity;
                });

                this._skipRebind = true;
                normalizedRef = sheet._grid.normalize(e.ref);

                if(!(normalizedRef instanceof UnionRef)) {
                    normalizedRef = new UnionRef([normalizedRef]);
                }

                normalizedRefs = normalizedRef.refs;

                normalizedRefs.forEach(function(ref) {
                    values.push(sheet.range(ref).values());
                });

                for(i = 0; i < normalizedRefs.length; i++) {
                    rangeRef = normalizedRefs[i];
                    rangeRef.forEach(setValues);
                }

                this._boundRowsCount = dataSource.view().length;

                this._skipRebind = false;
            }
        },

        _normalizeColumns: function(columns) {
            return columns.map(function(column) {
                var field = column.field || column;
                return {
                    field: field,
                    title: column.title || field
                };
            });
        },

        _dataSource: function() {
            var options = this.options;
            var dataSource = options.dataSource;

            dataSource = Array.isArray(dataSource) ? { data: dataSource } : dataSource;

            if (this.dataSource && this._changeHandler) {
                this.dataSource.unbind("change", this._changeHandler)
                    .unbind("progress", this._progressHandler)
                    .unbind("error", this._errorHandler);
            } else {
                this._changeHandler = this._change.bind(this);
                this._progressHandler = this._requestStart.bind(this);
                this._errorHandler = this._error.bind(this);
            }

            this.dataSource = kendo.data.DataSource.create(dataSource)
                .bind("change", this._changeHandler)
                .bind("progress", this._progressHandler)
                .bind("error", this._errorHandler);
        },

        _error: function() {
            this._progress(false);
        },

        _requestStart: function() {
            this._progress(true);
        },

        _progress: function(toggle) {
            this.sheet.trigger("progress", {
                toggle: toggle
            });
        },

        _change: function() {
            if (this._skipRebind) {
                return;
            }

            if (this.sheet.trigger("dataBinding")) {
                return;
            }

            var data = this.dataSource.view();
            var columns = this.columns;

            if (!columns.length && data.length) {
                this.columns = columns = this._normalizeColumns(Object.keys(data[0].toJSON()));
                this._header();
            }

            var getters = columns.map(function(column) {
                return kendo.getter(column.field);
            });

            this.sheet.batch(function() {
                var length = Math.max(data.length, this._boundRowsCount, this.sheet._grid.rowCount - 1);

                for (var idx = 0; idx < length; idx++) {
                    for (var getterIdx = 0; getterIdx < getters.length; getterIdx++) {
                        var value = data[idx] ? getters[getterIdx](data[idx]) : null;

                        //skip header row
                        this.sheet.range(idx + 1, getterIdx).value(value);
                    }
                }
            }.bind(this));

            this._boundRowsCount = data.length;

            this._progress(false);
            this.sheet.trigger("dataBound");
        },

        destroy: function() {
            this.dataSource.unbind("change", this._changeHandler)
                .unbind("progress", this._progressHandler)
                .unbind("error", this._errorHandler);

            this.sheet.unbind("change", this._sheetChangeHandler)
                .unbind("deleteRow", this._sheetDeleteRowHandler)
                .unbind("insertRow", this._sheetInsertRowHandler);
        },

        options: {
            columns: []
        }
    });

    kendo.spreadsheet.SheetDataSourceBinder = SheetDataSourceBinder;
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/filtermenu',[ "../kendo.core", "../kendo.popup", "../kendo.treeview", "../kendo.numerictextbox", "../kendo.datepicker", "../kendo.datetimepicker" ], f);
})(function(){

    (function(kendo) {

        var $ = kendo.jQuery;
        var Widget = kendo.ui.Widget;
        var classNames = {
            details: "k-details",
            button: "k-button",
            detailsSummary: "k-details-summary",
            detailsContent: "k-details-content",
            icon: "k-icon",
            iconCollapse: "k-i-arrow-45-down-right",
            iconExpand: "k-i-arrow-60-right",
            iconSearch: "k-i-zoom",
            textbox: "k-textbox",
            wrapper: "k-spreadsheet-filter-menu",
            filterByCondition: "k-spreadsheet-condition-filter",
            filterByValue: "k-spreadsheet-value-filter",
            valuesTreeViewWrapper: "k-spreadsheet-value-treeview-wrapper",
            actionButtons: "k-action-buttons"
        };

        kendo.spreadsheet.messages.filterMenu = {
            all: "All",
            sortAscending: "Sort range A to Z",
            sortDescending: "Sort range Z to A",
            filterByValue: "Filter by value",
            filterByCondition: "Filter by condition",
            apply: "Apply",
            search: "Search",
            addToCurrent: "Add to current selection",
            clear: "Clear",
            blanks: "(Blanks)",
            operatorNone: "None",
            and: "AND",
            or: "OR",
            operators: {
                string: {
                    contains: "Text contains",
                    doesnotcontain: "Text does not contain",
                    startswith: "Text starts with",
                    endswith: "Text ends with",
                    matches: "Text matches",
                    doesnotmatch: "Text does not match"
                },
                date: {
                    eq:  "Date is",
                    neq: "Date is not",
                    lt:  "Date is before",
                    gt:  "Date is after"
                },
                number: {
                    eq: "Is equal to",
                    neq: "Is not equal to",
                    gte: "Is greater than or equal to",
                    gt: "Is greater than",
                    lte: "Is less than or equal to",
                    lt: "Is less than"
                }
            }
        };

        var Details = Widget.extend({
            init: function(element, options) {
                Widget.fn.init.call(this, element, options);

                this.element.addClass(FilterMenu.classNames.details);

                this._summary = this.element.find("." + FilterMenu.classNames.detailsSummary)
                    .on("click", this._toggle.bind(this));

                var iconClass = options.expanded ? FilterMenu.classNames.iconCollapse : FilterMenu.classNames.iconExpand;
                this._icon = $("<span />", { "class": FilterMenu.classNames.icon + " " + iconClass })
                    .prependTo(this._summary);

                this._container = kendo.wrap(this._summary.next(), true);

                if (!options.expanded) {
                    this._container.hide();
                }
            },
            options: {
                name: "Details"
            },
            events: [ "toggle" ],
            visible: function() {
                return this.options.expanded;
            },
            toggle: function(show) {
                var animation = kendo.fx(this._container).expand("vertical");

                animation.stop()[show ? "reverse" : "play"]();

                this._icon.toggleClass(FilterMenu.classNames.iconExpand, show)
                          .toggleClass(FilterMenu.classNames.iconCollapse, !show);

                this.options.expanded = !show;
            },
            _toggle: function() {
                var show = this.visible();
                this.toggle(show);
                this.trigger("toggle", { show: show });
            }
        });

        kendo.data.binders.spreadsheetFilterValue = kendo.data.Binder.extend({
            init: function(element, bindings, options) {
                kendo.data.Binder.fn.init.call(this, element, bindings, options);

                this._change = this.change.bind(this);
                $(this.element).on("change", this._change);
            },
            refresh: function() {
                var that = this,
                    value = that.bindings.spreadsheetFilterValue.get(); //get the value from the View-Model

                $(that.element).val(value instanceof Date ? "" : value);
            },
            change: function() {
                var value = this.element.value;
                this.bindings.spreadsheetFilterValue.set(value); //update the View-Model
            }
        });

        kendo.data.binders.widget.spreadsheetFilterValue = kendo.data.Binder.extend({
            init: function(widget, bindings, options) {
                kendo.data.Binder.fn.init.call(this, widget.element[0], bindings, options);

                this.widget = widget;
                this._change = this.change.bind(this);
                this.widget.first("change", this._change);
            },
            refresh: function() {
                var binding = this.bindings.spreadsheetFilterValue,
                    value = binding.get(),
                    type = $(this.widget.element).data("filterType");

                if ((type === "date" && value instanceof Date) || (type === "number" && !isNaN(value))) {
                    this.widget.value(value);
                } else {
                    this.widget.value(null);
                }
            },
            change: function() {
                var value = this.widget.value(),
                    binding = this.bindings.spreadsheetFilterValue;

                binding.set(value);
            }
        });

        var templates = {
            filterByValue:
                "<div class='" + classNames.detailsSummary + "'>#= messages.filterByValue #</div>" +
                "<div class='" + classNames.detailsContent + "'>" +
                    "<div class='k-searchbox k-input k-input-md k-rounded-md k-input-solid'>" +
                        "<span class='k-input-icon k-icon k-i-search'></span>" +
                        "<input class='k-input-inner' autocomplete='off' placeholder='#= messages.search #' data-#=ns#bind='events: { input: filterValues }' />" +
                    "</div>" +
                    "<div data-#=ns#bind='visible: hasActiveSearch'><input class='k-checkbox k-checkbox-md k-rounded-md' type='checkbox' data-#=ns#bind='checked: appendToSearch' id='_#=guid#'/><label class='k-checkbox-label' for='_#=guid#'>#= messages.addToCurrent #</label></div>" +
                    "<div class='" + classNames.valuesTreeViewWrapper + "'>" +
                        "<div data-#=ns#role='treeview' " +
                            "data-#=ns#checkboxes='{ checkChildren: true }' "+
                            "data-#=ns#bind='source: valuesDataSource, events: { check: valuesChange, select: valueSelect }' "+
                            "></div>" +
                    "</div>" +
                "</div>",
            filterByCondition:
                "<div class='" + classNames.detailsSummary + "'>#= messages.filterByCondition #</div>" +
                "<div class='" + classNames.detailsContent + "'>" +
                    '<div>' +
                        '<select ' +
                            'aria-label="#= messages.filterByCondition #" ' +
                            'data-#=ns#role="dropdownlist"' +
                            'data-#=ns#bind="value: operator, source: operators, events: { change: operatorChange } "' +
                            'data-#=ns#value-primitive="false"' +
                            'data-#=ns#option-label="#=messages.operatorNone#"' +
                            'data-#=ns#height="auto"' +
                            'data-#=ns#text-field="text"' +
                            'data-#=ns#value-field="unique">'+
                        '</select>'+
                    '</div>' +

                    '<div data-#=ns#bind="visible: isString">' +
                        '<input aria-label="string-value" data-filter-type="string" data-#=ns#bind="spreadsheetFilterValue: customFilter.criteria[0].value" class="k-textbox" />'+
                    '</div>' +

                    '<div data-#=ns#bind="visible: isNumber">' +
                        '<input aria-label="number-value" data-filter-type="number" data-#=ns#role="numerictextbox" data-#=ns#bind="spreadsheetFilterValue: customFilter.criteria[0].value" />'+
                    '</div>' +

                    '<div data-#=ns#bind="visible: isDate">' +
                        '<input aria-label="date-value" data-filter-type="date" data-#=ns#role="datepicker" data-#=ns#bind="spreadsheetFilterValue: customFilter.criteria[0].value" />'+
                    '</div>' +
                "</div>",
            menuItem:
                "<li data-command='#=command#' data-dir='#=dir#'>" +
                    "<span class='k-icon k-i-#=iconClass#'></span>#=text#" +
                "</li>",
            actionButtons:
                "<button data-#=ns#bind='click: apply' class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-primary'><span class='k-button-text'>#=messages.apply#</span></button>" +
                "<button data-#=ns#bind='click: clear' class='k-button k-button-md k-rounded-md k-button-solid k-button-solid-base'><span class='k-button-text'>#=messages.clear#</span></button>"
        };

        function distinctValues(values) {
            var hash = {};
            var result = [];

            for (var i = 0; i < values.length; i++) {
                if (!hash[values[i].value]) {
                    hash[values[i].value] = values[i];
                    result.push(values[i]);
                } else if (!hash[values[i].value].checked && values[i].checked) {
                    hash[values[i].value].checked = true;
                }
            }

            return result;
        }

        function filter(dataSource, query) {
            var hasVisibleChildren = false;
            var data = dataSource instanceof kendo.data.HierarchicalDataSource && dataSource.data();
            var valuesFilter = this;
            var values = this.values;
            for (var i = 0; i < data.length; i++) {
                var item = data[i];
                var text = item.text.toString().toLocaleLowerCase(kendo.culture().name);
                var itemVisible = query === true || query === "" || text.indexOf(query) >= 0;
                var filterSpread = filter.bind(valuesFilter);
                var anyVisibleChildren = filterSpread(item.children, query); // pass true if parent matches

                hasVisibleChildren = hasVisibleChildren || anyVisibleChildren || itemVisible;
                item.hidden = !itemVisible && !anyVisibleChildren;

                if (query.length || (values && !values.length)) {
                    item.checked = !item.hidden;
                } else if (values && values.indexOf(item.text) != -1){
                    item.checked = true;
                }
            }

            if (data) {
                // re-apply filter on children
                dataSource.filter({ field: "hidden", operator: "neq", value: true });
            }

            return hasVisibleChildren;
        }

        function uncheckAll(dataSource) {
            var data = dataSource instanceof kendo.data.HierarchicalDataSource && dataSource.data();

            for (var i = 0; i < data.length; i++) {
                var item = data[i];
                item.checked = false;

                if (item.hasChildren) {
                    uncheckAll(item.children);
                }
            }
        }

        var FilterMenuViewModel = kendo.spreadsheet.FilterMenuViewModel = kendo.data.ObservableObject.extend({
            valuesChange: function(e) {
                var dataSource = e ? e.sender.dataSource : this.valuesDataSource;
                var checked = function(item) {
                    return item.checked;
                };
                var value = function(item) {
                    return item.dataType === "date" ? kendo.spreadsheet.dateToNumber(item.value) : item.value;
                };
                var unique = function(value, index, array) {
                    return array.lastIndexOf(value) === index;
                };
                var data = dataSource.data();
                var values = data.toJSON()[0].items;
                var blanks = values.filter(function(item) {
                    return item.dataType === "blank";
                });

                blanks = blanks.length ? blanks[0].checked : false;
                values = values.filter(checked).map(value);

                if (this.appendToSearch && this.valueFilter && this.valueFilter.values.length) {
                    values = values.concat(this.valueFilter.values.toJSON()).sort().filter(unique);
                }

                this.set("valueFilter", {
                    values: values,
                    blanks: blanks
                });
            },
            valueSelect: function(e) {
                e.preventDefault();

                var node = e.sender.dataItem(e.node);
                node.set("checked", !node.checked);
            },
            hasActiveSearch: false,
            appendToSearch: false,
            filterValues: function(e) {
                var query = typeof e == "string" ? e : $(e.target).val().toLocaleLowerCase(kendo.culture().name);
                var dataSource = this.valuesDataSource;

                this.set("hasActiveSearch", !!query);

                var filterSpread = filter.bind(this.valueFilter);
                uncheckAll(dataSource);
                filterSpread(dataSource, query);
            },
            reset: function() {
                this.set("customFilter", { logic: "and", criteria: [ { operator: null, value: null } ] });
                this.set("valueFilter", { values: [] });
            },
            operatorChange: function(e) {
                var dataItem = e.sender.dataItem();
                this.set("operatorType", dataItem.type);

                // https://github.com/telerik/kendo-ui-core/issues/3317 - when switching from Value
                // filter to filter by condition, the customFilter property is lost.
                if (!this.get("customFilter")) {
                    this.reset();
                }

                this.set("customFilter.criteria[0].operator", dataItem.value);
            },
            isNone: function() {
                return this.get("operatorType") === undefined;
            },
            isString: function() {
                return this.get("operatorType") === "string";
            },
            isNumber: function() {
                return this.get("operatorType") === "number";
            },
            isDate: function() {
                return this.get("operatorType") === "date";
            }
        });

        function flattenOperators(operators) {
            var messages = kendo.spreadsheet.messages.filterMenu.operators;
            var result = [];
            for (var type in operators) {
                if (!operators.hasOwnProperty(type)) {
                    continue;
                }

                for (var operator in operators[type]) {
                    if (!operators[type].hasOwnProperty(operator)) {
                        continue;
                    }

                    result.push({
                        text: messages[type][operator],
                        value: operator,
                        unique: type + "_" + operator,
                        type: type
                    });
                }
            }
            return result;
        }

        var FilterMenuController = kendo.spreadsheet.FilterMenuController = {
            valuesTree: function(range, column) {
                return [{
                    text: kendo.spreadsheet.messages.filterMenu.all,
                    expanded: true,
                    checked: false,
                    items: this.values(range.resize({ top: 1 }), column)
                }];
            },
            values: function(range, column) {
                var values = [];
                var messages = kendo.spreadsheet.messages.filterMenu;
                var columnRange = range.column(column);
                var sheet = range.sheet();

                columnRange.forEachCell(function(row, col, cell) {
                    var checked = true;
                    if (sheet.isHiddenRow(row)) {
                        checked = false;
                    }

                    var value = cell.value;
                    var dataType = cell.dataType;
                    var text = cell.text;

                    if (value === undefined) {
                        dataType = "blank";
                    } else if (cell.format) {
                        dataType = kendo.spreadsheet.formatting.type(value, cell.format);
                    } else {
                        dataType = typeof value;
                    }

                    if (value !== null && cell.format) {
                        text = kendo.spreadsheet.formatting.text(value, cell.format);
                    } else {
                        text = dataType == "blank" ? messages.blanks : value;
                    }

                    if (dataType === "percent" || dataType === "currency") { //treat percent as number
                        dataType = "number";
                    }

                    if (dataType === "date") {
                        value = kendo.spreadsheet.numberToDate(value);
                    }

                    values.push({
                        dataType: dataType,
                        value: value,
                        text: text,
                        checked: checked
                    });
                });

                values = distinctValues(values);

                values.sort(function(a, b) {
                    if (a.dataType === b.dataType) {
                        return 0;
                    }

                    if (a.dataType === "blank" || b.dataType === "blank") {
                        return a.dataType === "blank" ? -1 : 1;
                    }

                    if (a.dataType === "number" || b.dataType === "number") {
                        return a.dataType === "number" ? -1 : 1;
                    }

                    if (a.dataType === "date" || b.dataType === "date") {
                        return a.dataType === "date" ? -1 : 1;
                    }

                    return 0;
                });

                return values;
            },

            filterType: function(range, column) {
                // 1. try to infer type from current filter
                var sheet = range.sheet();
                var filter = this.filterForColumn(column, sheet);
                var type;

                filter = filter && filter.filter.toJSON();

                if (filter && filter.filter == "custom") {
                    var value = filter.criteria[0].value;

                    if (value instanceof Date) {
                        type = "date";
                    } else if (typeof value == "string") {
                        type = "string";
                    } else if (typeof value == "number") {
                        type = "number";
                    }
                }

                if (!type) {
                    // 2. try to infer type from column data
                    var topValue = this.values(range.row(1), column)[0];
                    type = topValue && topValue.dataType;

                    if (type == "blank") {
                        type = null;
                    }
                }

                return type;
            },

            filterForColumn: function(column, sheet) {
                var allFilters = sheet.filter();
                var filters;

                if (allFilters) {
                    filters =  allFilters.columns.filter(function(item) {
                        return item.index === column;
                    })[0];
                }

                return filters;
            },

            filter: function(column, sheet) {
                var columnFilters = this.filterForColumn(column, sheet);

                if (!columnFilters) {
                    return;
                }

                var options = columnFilters.filter.toJSON();
                var type = options.filter;

                delete options.filter;

                var result = {
                    type: type,
                    options: options
                };

                var criteria = options.criteria;
                if (criteria && criteria.length) {
                    result.operator = criteria[0].operator;
                }

                return result;
            }
        };

        var FilterMenu = Widget.extend({
            init: function(element, options) {
                Widget.call(this, element, options);

                this.element.addClass(FilterMenu.classNames.wrapper);

                this.viewModel = new FilterMenuViewModel({
                    active: "value",
                    operator: null,
                    operators: flattenOperators(this.options.operators),
                    clear: this.clear.bind(this),
                    apply: this.apply.bind(this)
                });

                this._filterInit();
                this._popup();
                this._sort();
                this._filterByCondition();
                this._filterByValue();
                this._actionButtons();
            },

            options: {
                name: "FilterMenu",
                column: 0,
                range: null,
                operators: {
                    string: {
                        contains: "Text contains",
                        doesnotcontain: "Text does not contain",
                        startswith: "Text starts with",
                        endswith: "Text ends with",
                        matches: "Text matches",
                        doesnotmatch: "Text does not match"
                    },
                    date: {
                        eq:  "Date is",
                        neq: "Date is not",
                        lt:  "Date is before",
                        gt:  "Date is after"
                    },
                    number: {
                        eq: "Is equal to",
                        neq: "Is not equal to",
                        gte: "Is greater than or equal to",
                        gt: "Is greater than",
                        lte: "Is less than or equal to",
                        lt: "Is less than"
                    }
                }
            },

            events: [
                "action"
            ],

            destroy: function() {
                Widget.fn.destroy.call(this);

                this.menu.destroy();
                this.valuesTreeView.destroy();
                this.popup.destroy();
            },

            openFor: function(anchor, event) {
                if ($(anchor).hasClass("k-spreadsheet-view-size")) {
                    // on touch devices this element will sit above to
                    // enable scrolling; it's not useful as an anchor,
                    // use event coords instead.
                    this.popup.open(event.pageX, event.pageY);
                } else {
                    this.popup.setOptions({ anchor: anchor });
                    this.popup.open();
                }
            },

            close: function() {
                this.popup.close();
            },

            clear: function() {
                this.action({
                    command: "ClearFilterCommand",
                    options: {
                        column: this.options.column
                    }
                });
                this.viewModel.reset();
                this.close();
            },

            apply: function() {
                this._active();

                var options = {
                    operatingRange: this.options.range,
                    column: this.options.column
                };

                var valueFilter;
                var customFilter;

                if (this.viewModel.active === "value") {
                    this.viewModel.valuesChange({ sender: this.valuesTreeView });
                    valueFilter = this.viewModel.valueFilter.toJSON();

                    if (valueFilter.blanks || (valueFilter.values && valueFilter.values.length)) {
                        options.valueFilter = valueFilter;
                    }
                } else if (this.viewModel.active === "custom") {
                    customFilter = this.viewModel.customFilter.toJSON();

                    if (customFilter.criteria.length && customFilter.criteria[0].value !== null) {
                        options.customFilter = customFilter;
                    }
                }

                if (options.valueFilter || options.customFilter) {
                    this.action({ command: "ApplyFilterCommand", options: options });
                }
            },

            action: function(options) {
                this.trigger("action", $.extend({ }, options));
            },

            _filterInit: function() {
                var column = this.options.column;
                var range = this.options.range;
                var sheet = range.sheet();
                var activeFilter = FilterMenuController.filter(column, sheet);

                if (activeFilter) {
                    var filterType = FilterMenuController.filterType(range, column);

                    this.viewModel.set("active", activeFilter.type);
                    this.viewModel.set(activeFilter.type + "Filter", activeFilter.options);

                    if (activeFilter.type == "custom") {
                        this.viewModel.set("operator", filterType + "_" + activeFilter.operator);
                        this.viewModel.set("operatorType", filterType);
                    }
                } else {
                    this.viewModel.reset();
                }
            },

            _popup: function() {
                this.popup = this.element.kendoPopup({
                    copyAnchorStyles: false
                }).data("kendoPopup");
            },

            _sort: function() {
                var template = kendo.template(FilterMenu.templates.menuItem);
                var messages = kendo.spreadsheet.messages.filterMenu;
                var items = [
                    { command: "sort", dir: "asc", text: messages.sortAscending, iconClass: "sort-asc" },
                    { command: "sort", dir: "desc", text: messages.sortDescending, iconClass: "sort-desc" }
                ];

                var ul = $("<ul></ul>", {
                    "html": kendo.render(template, items)
                }).appendTo(this.element);

                this.menu = ul.kendoMenu({
                    orientation: "vertical",
                    select: function(e) {
                        var dir = $(e.item).data("dir");
                        var range = this.options.range.resize({ top: 1 });
                        var options = {
                            value: dir,
                            sheet: false,
                            operatingRange: range,
                            column: this.options.column
                        };

                        this.action({ command: "SortCommand", options: options });
                    }.bind(this)
                }).data("kendoMenu");
            },

            _appendTemplate: function(template, className, details, expanded) {
                var compiledTemplate = kendo.template(template);
                var wrapper = $("<div class='" + className + "'/>").html(compiledTemplate({
                    messages: kendo.spreadsheet.messages.filterMenu,
                    guid: kendo.guid(),
                    ns: kendo.ns
                }));

                this.element.append(wrapper);

                if (details) {
                    details = new Details(wrapper, { expanded: expanded, toggle: this._detailToggle.bind(this) }); // jshint ignore:line
                }

                kendo.bind(wrapper, this.viewModel);

                return wrapper;
            },

            _detailToggle: function(e) {
                this.element
                    .find("[" + kendo.attr("role") + "=details]")
                    .not(e.sender.element)
                    .data("kendoDetails")
                    .toggle(!e.show);
            },

            _filterByCondition: function() {
                var isExpanded = this.viewModel.active === "custom";
                this._appendTemplate(FilterMenu.templates.filterByCondition, FilterMenu.classNames.filterByCondition, true, isExpanded);
            },

            _filterByValue: function() {
                var isExpanded = this.viewModel.active === "value";
                var wrapper = this._appendTemplate(FilterMenu.templates.filterByValue, FilterMenu.classNames.filterByValue, true, isExpanded);

                this.valuesTreeView = wrapper.find("[" + kendo.attr("role") + "=treeview]").data("kendoTreeView");

                var values = FilterMenuController.valuesTree(this.options.range, this.options.column);

                this.viewModel.set("valuesDataSource", new kendo.data.HierarchicalDataSource({ data: values, accentFoldingFiltering: kendo.culture().name }));
            },

            _actionButtons: function() {
                this._appendTemplate(FilterMenu.templates.actionButtons, FilterMenu.classNames.actionButtons, false);
            },

            _active: function() {
                var activeContainer = this.element.find("[" + kendo.attr("role") + "=details]").filter(function(index, element) {
                    return $(element).data("kendoDetails").visible();
                });

                if (activeContainer.hasClass(FilterMenu.classNames.filterByValue)) {
                    this.viewModel.set("active", "value");
                } else if (activeContainer.hasClass(FilterMenu.classNames.filterByCondition)) {
                    this.viewModel.set("active", "custom");
                }
            }
        });

        kendo.spreadsheet.FilterMenu = FilterMenu;
        $.extend(true, FilterMenu, { classNames: classNames, templates: templates });

    })(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/editor',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var SheetEditor = kendo.Observable.extend({
        init: function(view) {
            kendo.Observable.fn.init.call(this);

            this.view = view;
            this.formulaBar = view.formulaBar;
            this._active = false;

            this.barInput = view.formulaBar.formulaInput;
            this.cellInput = view.formulaInput;

            this.barInput.syncWith(this.cellInput);
            this.cellInput.syncWith(this.barInput);

            this.barInput.bind("keyup", this._triggerUpdate.bind(this));
            this.cellInput.bind("keyup", this._triggerUpdate.bind(this));

            this.barInput.bind("blur", this._blur.bind(this));
            this.cellInput.bind("blur", this._blur.bind(this));
        },

        events: [
            "activate",
            "deactivate",
            "change",
            "update"
        ],

        _blur: function() {
            this.deactivate();
        },

        _triggerUpdate: function() {
            this.trigger("update", { value: this.value() });
        },

        activeEditor: function() {
            var editor = null;
            var activeElement = kendo._activeElement();

            if (this.barElement()[0] === activeElement) {
                editor = this.barInput;
            } else if (this.cellElement()[0] === activeElement) {
                editor = this.cellInput;
            }

            return editor;
        },

        activate: function(options) {
            var viewElement = this.view.element,
                viewWidth, scrollerElement, scrollbarWidth;

            this._active = true;
            this._rect = options.rect;
            this._range = options.range;

            this.cellInput.position(options.rect);
            this.cellInput.resize(options.rect);
            this.cellInput.tooltip(options.tooltip);
            this.cellInput.activeCell = this.barInput.activeCell = this._range.topLeft();
            this.cellInput.activeSheet = this.barInput.activeSheet = this._range._sheet;

            if(viewElement) {
                viewWidth = viewElement.width();
                scrollerElement = viewElement.find(".k-spreadsheet-scroller")[0];
                scrollbarWidth = scrollerElement.offsetWidth - scrollerElement.clientWidth;

                this.cellInput.element.css("max-width", viewWidth - scrollbarWidth - this.cellInput.element.position().left + "px");
            }

            this.trigger("activate");

            return this;
        },

        deactivate: function(noChange) {
            var cellInput = this.cellInput;

            if (!this._active) {
                return;
            }

            this._active = false;

            if (!noChange && cellInput.value() != this._value) {
                this.trigger("change", {
                    value: cellInput.value(),
                    range: this._range
                });
            }

            this._rect = null;
            cellInput.hide();
            this.trigger("deactivate");
        },

        enable: function(enable) {
            this.barInput.enable(enable);
            this.cellInput.enable(enable);
        },

        barElement: function() {
            return this.barInput.element;
        },

        cellElement: function() {
            return this.cellInput.element;
        },

        focus: function(inputType) {
            inputType = inputType || "cell";

            if (inputType === "cell") {
                this.cellInput.element.trigger("focus");
                this.cellInput.end();
            } else {
                this.barInput.element.trigger("focus");
            }
        },

        isActive: function() {
            return this._active;
        },

        isFiltered: function() {
            return this.barInput.popup.visible() || this.cellInput.popup.visible();
        },

        canInsertRef: function(isKeyboardAction) {
            var editor = this.activeEditor();
            return editor && editor.canInsertRef(isKeyboardAction);
        },

        highlightedRefs: function() {
            var editor = this.activeEditor();
            var refs = [];

            if (editor) {
                refs = editor.highlightedRefs();
            }

            return refs;
        },

        scale: function() {
            this.cellInput.scale();
        },

        toggleTooltip: function(rect) {
            this.cellInput.toggleTooltip(notEqual(this._rect, rect));
        },

        value: function(value, isArrayFormula) {
            if (value === undefined) {
                return this.barInput.value();
            }

            if (value === null) {
                value = "";
            }

            this._value = value;

            this.barInput.value(value);
            this.cellInput.value(value);

            this.barInput.element.toggleClass("k-spreadsheet-array-formula", !!isArrayFormula);
        },

        insertNewline: function() {
            this.activeEditor().insertNewline();
            this.scale();
        },

        select: function() {
            this.activeEditor().select();
        }
    });

    function notEqual(oldRect, newRect) {
        return oldRect && (oldRect.top !== newRect.top || oldRect.left !== newRect.left);
    }

    kendo.spreadsheet.SheetEditor = SheetEditor;
})(kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

// -*- fill-column: 100 -*-

(function(f, define){
    define('spreadsheet/autofill',[ "./runtime", "./range" ], f);
})(function(){
    "use strict";

    // jshint eqnull:true

    var spreadsheet = kendo.spreadsheet;
    var Range = spreadsheet.Range;
    var runtime = spreadsheet.calc.runtime;
    var Formula = runtime.Formula;

    var ERR_INCOMPATIBLE = "incompatibleRanges";
    var ERR_NO_DIRECTION = "noFillDirection";

    var FillError = Range.FillError = function(msg) {
        this.code = msg;
    };

    // `srcRange`: the range containing data that we wish to fill.  `direction`: 0, 1, 2, 3.  So
    // when bit 0 is set we're doing horizontal filling, and when bit 1 is set we're doing it in
    // reverse order.
    Range.prototype._previewFillFrom = function(srcRange, direction) {
        var destRange = this, sheet = destRange._sheet;
        if (typeof srcRange == "string") {
            srcRange = sheet.range(srcRange);
        }
        var src = srcRange._ref.toRangeRef().clone().setSheet(sheet.name());
        var dest = destRange._ref.toRangeRef().clone().setSheet(sheet.name());

        if (src.intersects(dest)) {
            // the UI will send e.g. C2:C8.fillFrom(C7:D8) (intersecting ranges).  this figures out
            // the actual destination range.
            if (src.eq(dest)) {
                return null; // nothing to do
            }
            dest = dest.clone();
            if (src.topLeft.eq(dest.topLeft)) {
                if (src.width() == dest.width()) {
                    dest.topLeft.row += src.height();
                    direction = 0;
                } else if (src.height() == dest.height()) {
                    dest.topLeft.col += src.width();
                    direction = 1;
                } else {
                    throw new FillError(ERR_INCOMPATIBLE);
                }
            } else if (src.bottomRight.eq(dest.bottomRight)) {
                if (src.width() == dest.width()) {
                    dest.bottomRight.row -= src.height();
                    direction = 2;
                } else if (src.height() == dest.height()) {
                    dest.bottomRight.col -= src.width();
                    direction = 3;
                } else {
                    throw new FillError(ERR_INCOMPATIBLE);
                }
            } else {
                throw new FillError(ERR_INCOMPATIBLE);
            }
            return sheet.range(dest)._previewFillFrom(srcRange, direction);
        }

        if (direction == null) {
            // try to determine based on ranges location/geometry
            if (src.topLeft.col == dest.topLeft.col) {
                // assume vertical filling
                direction = src.topLeft.row < dest.topLeft.row ? 0 : 2;
            } else if (src.topLeft.row == dest.topLeft.row) {
                direction = src.topLeft.col < dest.topLeft.col ? 1 : 3;
            } else {
                throw new FillError(ERR_NO_DIRECTION);
            }
        }
        var horizontal = direction & 1;
        var descending = direction & 2;
        if ((horizontal && src.height() != dest.height()) ||
            (!horizontal && src.width() != dest.width())) {
            throw new FillError(ERR_INCOMPATIBLE);
        }
        var data = srcRange._properties(), n;
        if (!horizontal) {
            data = transpose(data);
            n = dest.height();
        } else {
            n = dest.width();
        }
        var fill = new Array(data.length);
        var hint = null;
        for (var i = 0; i < data.length; ++i) {
            var s = data[i];
            var f = findSeries(s);
            var a = fill[i] = new Array(n);
            for (var j = 0; j < n; ++j) {
                var idx = descending ? -j - 1 : s.length + j;
                var srcIdx = descending ? s.length - (j % s.length) - 1 : (j % s.length);
                var cell = a[descending ? n - j - 1 : j] = f(idx, srcIdx);
                if (cell.value != null) {
                    hint = cell.value;
                }
            }
        }
        if (!horizontal) {
            fill = transpose(fill);
        }
        return { props: fill, direction: direction, dest: destRange, hint: hint };
    };

    Range.prototype.fillFrom = function(srcRange, direction) {
        var x = this._previewFillFrom(srcRange, direction);
        x.dest._properties(x.props, true);
        return x.dest;
    };

    // This is essentially the FORECAST function, see ./runtime.functions.2.js.
    // It receives an array of values, and returns a function that "predicts"
    // the value in cell N.
    function linearRegression(data) {
        var N = data.length;
        var mx = (N + 1) / 2, my = data.reduce(function(a, b){
            return a + b;
        }, 0) / N;
        var s1 = 0, s2 = 0;
        for (var i = 0; i < N; i++) {
            var t1 = (i + 1) - mx, t2 = data[i] - my;
            s1 += t1 * t2;
            s2 += t1 * t1;
        }
        if (!s2) {
            return function(N){
                return data[N % data.length];
            };
        }
        var b = s1 / s2, a = my - b * mx;
        return function(N) {
            return a + b * (N + 1);
        };
    }

    function findSeries(properties) {
        function findStep(a) {
            var diff = a[1] - a[0];
            for (var i = 2; i < a.length; ++i) {
                if (a[i] - a[i-1] != diff) {
                    return null;
                }
            }
            return diff;
        }
        function getData(a) {
            return a.map(function(v){
                return v.number;
            });
        }
        var series = [];
        var data = properties.map(function(x){
            return x.formula || x.value;
        });
        forEachSeries(data, function(begin, end, type, a){
            var f, values;
            if (type == "number") {
                values = getData(a);

                // This code would increase a date even if a single cell was selected.  Seems it's
                // not desirable so I commented it out.
                // https://github.com/telerik/kendo-ui-core/issues/3565
                //
                // if (values.length == 1 && (begin > 0 || end < data.length ||
                //                            formatType(values[0], properties[begin].format) == "date")) {
                //     values.push(values[0] + 1);
                // }

                f = linearRegression(values);
            } else if (type == "string" || type == "formula" || type == "boolean") {
                // formulas are simply copied over; the sheet will internally clone the objects
                f = function(N, i) {
                    return data[i];
                };
            } else if (Array.isArray(type)) {
                if (a.length == 1) {
                    f = function(N) {
                        return type[(a[0].number + N) % type.length];
                    };
                } else {
                    // figure out the step
                    var diff = findStep(getData(a));
                    if (diff == null) {
                        // seemingly no pattern, just repeat those strings
                        f = function(N) {
                            return a[(N) % a.length].value;
                        };
                    } else {
                        f = function(N) {
                            var idx = a[0].number + diff * N;
                            return type[idx % type.length];
                        };
                    }
                }
            } else if (type != "null") {
                values = getData(a);
                if (values.length == 1) {
                    values.push(values[0] + 1);
                }
                values = linearRegression(values);
                f = function(N, i) {
                    return data[i].replace(/^(.*\D)\d+/, "$1" + values(N, i));
                };
            } else {
                f = function() { return null; };
            }
            var s = { f: f, begin: begin, end: end, len: end - begin };
            for (var i = begin; i < end; ++i) {
                series[i] = s;
            }
        });
        return function(N, i) {
            var s = series[i];
            var q = N / data.length | 0;
            var r = N % data.length;
            var n = q * s.len + r - s.begin;
            var value = s.f(n, i);
            var props = clone(properties[i]);
            delete props.enable;
            if (value instanceof Formula) {
                props.formula = value;
            } else {
                props.value = value;
            }
            return props;
        };
    }

    // function formatType(value, format) {
    //     if (format != null) {
    //         return spreadsheet.formatting.type(value, format);
    //     }
    // }

    function clone(obj) {
        var copy = {};
        Object.keys(obj || {}).forEach(function(key){
            copy[key] = obj[key];
        });
        return copy;
    }

    function forEachSeries(data, f) {
        var prev = null, start = 0, a = [], type;
        for (var i = 0; i < data.length; ++i) {
            type = getType(data[i]);
            a.push(type);
            if (prev != null && type.type !== prev.type) {
                f(start, i, prev.type, a.slice(start, i));
                start = i;
            }
            prev = type;
        }
        f(start, i, prev.type, a.slice(start, i));
    }

    function getType(el) {
        if (typeof el == "number") {
            return { type: "number", number: el };
        }
        if (typeof el == "string") {
            var lst = findStringList(el);
            if (lst) {
                return lst;
            }
            var m = /^(.*\D)(\d+)/.exec(el);
            if (m) {
                el = el.replace(/^(.*\D)\d+/, "$1-######");
                return { type: el, match: m, number: parseFloat(m[2]) };
            }
            return { type: "string" };
        }
        if (typeof el == "boolean") {
            return { type: "boolean" };
        }
        if (el == null) {
            return { type: "null" };
        }
        if (el instanceof Formula) {
            return { type: "formula" };
        }
        window.console.error(el);
        throw new Error("Cannot fill data");
    }

    function stringLists() {
        var culture = kendo.culture();
        return [
            culture.calendars.standard.days.namesAbbr,
            culture.calendars.standard.days.names,
            culture.calendars.standard.months.namesAbbr,
            culture.calendars.standard.months.names
        ];
    }

    function findStringList(str) {
        var strl = str.toLowerCase();
        var lists = stringLists();
        for (var i = 0; i < lists.length; ++i) {
            var a = lists[i];
            for (var j = a.length; --j >= 0;) {
                var el = a[j].toLowerCase();
                if (el == strl) {
                    return { type: a, number: j, value: str };
                }
            }
        }
    }

    function transpose(a) {
        var height = a.length, width = a[0].length;
        var t = [];
        for (var i = 0; i < width; ++i) {
            t[i] = [];
            for (var j = 0; j < height; ++j) {
                t[i][j] = a[j][i];
            }
        }
        return t;
    }

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/nameeditor',[ "../kendo.core" ], f);
})(function(){

(function(kendo) {

    var $ = kendo.jQuery;

    var CLASS_NAMES = {
        input: "k-spreadsheet-name-editor",
        list: "k-spreadsheet-name-list"
    };

    var NameEditor = kendo.ui.Widget.extend({
        init: function(element, options) {
            kendo.ui.Widget.call(this, element, options);
            element.addClass(CLASS_NAMES.input);

            var comboBoxTitle = options.messages.nameBox || "Name Box";
            var dataSource = new kendo.data.DataSource({
                transport: {
                    read: function(options) {
                        var data = [];
                        this._workbook.forEachName(function(def){
                            if (!def.hidden && def.value instanceof kendo.spreadsheet.Ref) {
                                data.push({ name: def.name });
                            }
                        });
                        options.success(data);
                    }.bind(this),
                    cache: false
                }
            });

            var comboElement = $("<input />")
                .attr("title", comboBoxTitle)
                .attr("aria-label", comboBoxTitle);

            this.combo = comboElement.appendTo(element)
                .kendoComboBox({
                    clearButton: false,
                    dataTextField: "name",
                    dataValueField: "name",
                    template: "#:data.name#<a role='button' class='k-button-delete' href='\\#'><span class='k-icon k-i-close'></span></a>",
                    dataSource: dataSource,
                    autoBind: false,
                    ignoreCase: true,
                    change: this._on_listChange.bind(this),
                    noDataTemplate: "<div></div>",
                    open: function() {
                        dataSource.read();
                    }
                }).getKendoComboBox();

            this.combo.input
                .on("keydown", this._on_keyDown.bind(this))
                .on("focus", this._on_focus.bind(this));

            this.combo.popup.element
                .addClass("k-spreadsheet-names-popup")

                .on("mousemove", function(ev){
                    // XXX: should remove this when we find a better
                    // solution for the popup closing as we hover the
                    // resize handles.
                    ev.stopPropagation();
                })

                .on("click", ".k-button-delete", function(ev){
                    ev.preventDefault();
                    ev.stopPropagation();
                    var item = $(ev.target).closest(".k-item");
                    item = this.combo.dataItem(item);
                    this._deleteItem(item.name);
                }.bind(this));
        },
        value: function(val) {
            if (val === undefined) {
                return this.combo.value();
            } else {
                this.combo.value(val);
            }
        },
        _deleteItem: function(name) {
            this.trigger("delete", { name: name });
        },
        _on_keyDown: function(ev) {
            switch (ev.keyCode) {
              case 27:
                this.combo.value(this._prevValue);
                this.trigger("cancel");
                break;
              case 13:
                this.trigger("enter");
                break;
            }
        },
        _on_focus: function() {
            this._prevValue = this.combo.value();
        },
        _on_listChange: function() {
            var name = this.combo.value();
            if (name) {
                this.trigger("select", { name: name });
            }
        }
    });

    kendo.spreadsheet.NameEditor = NameEditor;
})(window.kendo);
}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('spreadsheet/print',[ "../kendo.pdf", "./sheet", "./range", "./references", "./numformat", "../util/text-metrics" ], f);
})(function(){
    "use strict";

    var spreadsheet = kendo.spreadsheet;
    var CellRef = spreadsheet.CellRef;
    var kdrw = kendo.drawing;
    var formatting = spreadsheet.formatting;
    var geo = kendo.geometry;

    var GUIDELINE_WIDTH = 0.8;

    /* jshint eqnull:true, laxbreak:true, shadow:true, -W054 */
    /* jshint latedef: nofunc */

    // This takes a list of row heights and the page height, and
    // produces a list of Y coordinates for each row, such that rows
    // are not truncated across pages.  However, the algorithm will
    // decide to truncate a row in the event that more than
    // `maxEmpty` (default 0.2) of the available space would
    // otherwise be left blank.
    //
    // It will be used for horizontal splitting too (will receive
    // column widths and page width, and produce a list of X coords).
    //
    // If the third argument (headerRows) is not null, it specifies a
    // number of rows to repeat on each page.  On pages other than the
    // first, the necessary space will be skipped at the top.  Header
    // coordinates (except for the first page) are pushed in
    // headerCoords.
    function distributeCoords(heights, pageHeight, maxEmpty, headerRows, headerCoords) {
        var curr = 0;
        var out = [];
        var bottom = pageHeight;
        var header = 0;
        if (pageHeight && maxEmpty) {
            maxEmpty *= pageHeight;
        }
        heights.forEach(function(h, i){
            if (headerRows != null && i < headerRows) {
                header += h;
            }
            if (pageHeight && curr + h > bottom) {
                if (bottom - curr < maxEmpty) {
                    // align to next page
                    curr = pageHeight * Math.ceil(curr / pageHeight) + header;
                    if (header > 0) {
                        headerCoords.push(curr - header);
                    }
                }
                // update bottom anyway; don't just add pageHeight, as
                // we might need multiple pages for the pathological
                // case of one row higher than the page.
                bottom += pageHeight * Math.ceil(h / pageHeight);
            }
            out.push(curr);
            curr += h;
        });
        out.push(curr);
        return out;
    }

    function doLayout(sheet, range, options) {
        // normalize reference so we don't have to deal with Infinity here.
        var grid = sheet._grid;
        range = grid.normalize(range);

        var wholeRect = grid.rectangle(range);
        var drawings = [];
        sheet._drawings.forEach(function(d) {
            var box = sheet.drawingBoundingBox(d);
            if (box.intersects(wholeRect)) {
                drawings.push({
                    drawing: d,
                    box: box.offset(-wholeRect.left, -wholeRect.top)
                });
            }
        });

        // 1. obtain the list of cells that need to be printed, the
        //    row heights and column widths.  Place in each cell row,
        //    col (relative to range, i.e. first is 0,0), rowspan,
        //    colspan and merged.  also place a list of drawings
        //    anchored to that cell.
        var cells = [];
        var rowHeights = [];
        var colWidths = [];
        var mergedCells = sheet._getMergedCells(range);

        var maxRow = -1, maxCol = -1;
        sheet.forEach(range, function(row, col, cell){
            var relrow = row - range.topLeft.row;
            var relcol = col - range.topLeft.col;
            var rh = sheet.rowHeight(row);
            var cw = sheet.columnWidth(col);
            if (!options.forScreen) {
                // for printing we'll need the list of anchored
                // drawings so that we can adjust them after page
                // splitting.
                cell.drawings = drawings.filter(function(d){
                    var tl = d.drawing.topLeftCell;
                    if (tl && tl.row == row && tl.col == col) {
                        maxRow = Math.max(maxRow, sheet._rows.index(d.box.bottom));
                        maxCol = Math.max(maxCol, sheet._columns.index(d.box.right));
                        return true;
                    }
                });
            }
            if (!relcol) {
                rowHeights.push(rh);
            }
            if (!relrow) {
                colWidths.push(cw);
            }
            var id = new CellRef(row, col).print();
            if (mergedCells.secondary[id]) {
                return;
            }
            cell.row = relrow;
            cell.col = relcol;
            var m = mergedCells.primary[id];
            if (m) {
                delete mergedCells.primary[id];
                cell.merged = true;
                cell.rowspan = m.height();
                cell.colspan = m.width();
                if (options.forScreen) {
                    cell.width = sheet._columns.sum(m.topLeft.col, m.bottomRight.col);
                    cell.height = sheet._rows.sum(m.topLeft.row, m.bottomRight.row);
                }
            } else {
                cell.rowspan = 1;
                cell.colspan = 1;
            }
            if (!sheet._grid._columns.sum(col, col + cell.colspan - 1) ||
                !sheet._grid._rows.sum(row, row + cell.rowspan - 1)) {
                return;
            }
            var nonEmpty = options.forScreen || shouldDrawCell(cell);
            if (!(options.emptyCells || nonEmpty)) {
                return;
            }
            if (nonEmpty) {
                maxRow = Math.max(maxRow, relrow + cell.rowspan - 1);
                maxCol = Math.max(maxCol, relcol + cell.colspan - 1);
            } else {
                cell.empty = true;
            }
            cells.push(cell);
        });

        if (!options.forScreen) {
            // keep only the drawable area
            rowHeights = rowHeights.slice(0, maxRow + 1);
            colWidths = colWidths.slice(0, maxCol + 1);
        }

        var pageWidth = options.pageWidth;
        var pageHeight = options.pageHeight;
        var scaleFactor = options.scale || 1;

        // when fitWidth is requested, we must update the page size
        // with the corresponding scale factor; the algorithm below
        // (2) will continue to work, just drawing on a bigger page.
        if (options.fitWidth) {
            var width = colWidths.reduce(sum, 0);
            if (width > pageWidth) {
                scaleFactor = pageWidth / width;
            }
        }
        pageWidth = Math.ceil(pageWidth / scaleFactor);
        pageHeight = Math.ceil(pageHeight / scaleFactor);

        // 2. calculate top, left, bottom, right, width and height for
        //    printable cells.  Merged cells will be split across
        //    pages, unless the first row/col is shifted to next page.
        //    boxWidth and boxHeight get the complete drawing size.
        //    Note that cell coordinates keep increasing, i.e. they
        //    are not reset to zero for a new page.  The print
        //    function translates the view to current page.
        var hyCoords = []; // will receive header Y coordinates, if needed
        var yCoords = distributeCoords(rowHeights, pageHeight || 0, options.maxEmpty,
                                       options.headerRows, hyCoords);
        var xCoords = distributeCoords(colWidths, pageWidth || 0, options.maxEmpty);
        var boxWidth = 0;
        var boxHeight = 0;
        var headerCells = [];
        cells = cells.filter(function(cell){
            if (cell.empty && (cell.row > maxRow || cell.col > maxCol)) {
                return false;
            }
            if (options.headerRows && cell.row < options.headerRows) {
                headerCells.push(cell);
            }
            cell.left = xCoords[cell.col];
            cell.top = yCoords[cell.row];
            if (cell.merged) {
                if (!options.forScreen) {
                    cell.right = orlast(xCoords, cell.col + cell.colspan);
                    cell.bottom = orlast(yCoords, cell.row + cell.rowspan);
                    cell.width = cell.right - cell.left;
                    cell.height = cell.bottom - cell.top;
                } else {
                    cell.right = cell.left + cell.width;
                    cell.bottom = cell.top + cell.height;
                }
            } else {
                cell.width = colWidths[cell.col];
                cell.height = rowHeights[cell.row];
                cell.bottom = cell.top + cell.height;
                cell.right = cell.left + cell.width;
            }
            if (!options.forScreen) {
                // page breaking will shift cell coordinates.  adjust
                // anchored drawings.
                cell.drawings.forEach(function(d){
                    var box = d.box;
                    box.left = cell.left + d.drawing.offsetX;
                    box.top = cell.top + d.drawing.offsetY;
                    box.right = box.left + box.width;
                    box.bottom = box.top + box.height;
                });
            }
            boxWidth = Math.max(boxWidth, cell.right);
            boxHeight = Math.max(boxHeight, cell.bottom);
            return true;
        });

        // 3. if any merged cells remain in "primary", they start
        //    outside the printed range and we should still display
        //    them partially.
        Object.keys(mergedCells.primary).forEach(function(id){
            var ref = mergedCells.primary[id];
            sheet.forEach(ref.topLeft.toRangeRef(), function(row, col, cell){
                var relrow = row - range.topLeft.row;
                var relcol = col - range.topLeft.col;
                cell.merged = true;
                cell.colspan = ref.width();
                cell.rowspan = ref.height();
                if (relrow < 0) {
                    cell.top = -sheet._rows.sum(row, row - relrow - 1);
                } else {
                    cell.top = yCoords[relrow];
                }
                if (relcol < 0) {
                    cell.left = -sheet._columns.sum(col, col - relcol - 1);
                } else {
                    cell.left = xCoords[relcol];
                }
                cell.height = sheet._rows.sum(ref.topLeft.row, ref.bottomRight.row);
                cell.width = sheet._columns.sum(ref.topLeft.col, ref.bottomRight.col);
                if (cell.height > 0 && cell.width > 0) {
                    // zero means a fully hidden merged cell (all rows/columns are hidden)
                    // https://github.com/telerik/kendo-ui-core/issues/1794
                    cell.right = cell.left + cell.width;
                    cell.bottom = cell.top + cell.height;
                    cell.row = relrow;
                    cell.col = relcol;
                    cells.push(cell);
                }
            });
        });

        // 4. replicate header rows on all pages
        if (options.headerRows) {
            hyCoords.forEach(function(y){
                headerCells.forEach(function(cell){
                    cell = clone(cell);
                    cell.top += y;
                    cell.bottom = cell.top + cell.height;
                    cells.push(cell);
                });
                yCoords.push(y);
            });
            yCoords.sort(orderCoords);
        }

        return {
            width    : boxWidth,
            height   : boxHeight,
            cells    : cells.sort(orderCells),
            scale    : scaleFactor,
            xCoords  : xCoords,
            yCoords  : yCoords,
            drawings : drawings
        };
    }

    function clone(hash, target) {
        if (!target) {
            target = {};
        }
        if (Object.assign) {
            return Object.assign(target, hash);
        }
        return Object.keys(hash).reduce(function(copy, key){
            copy[key] = hash[key];
            return copy;
        }, target);
    }

    function sameBorder(a, b) {
        return a.size === b.size && a.color === b.color;
    }

    function sum(a, b) {
        return a + b;
    }

    function orlast(a, i) {
        return i < a.length ? a[i] : a[a.length - 1];
    }

    function shouldDrawCell(cell) {
        return cell.value != null
            || cell.merged
            || cell.background != null
            || cell.borderRight != null
            || cell.borderBottom != null
            || (cell.validation != null && !cell.validation.value)
            || (cell.drawings && cell.drawings.length);
    }

    function orderCells(a, b) {
        if (a.top < b.top) {
            return -1;
        } else if (a.top == b.top) {
            if (a.left < b.left) {
                return -1;
            } else if (a.left == b.left) {
                return 0;
            } else {
                return 1;
            }
        } else {
            return 1;
        }
    }

    function orderCoords(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

    function drawLayout(sheet, layout, group, options) {
        // options:
        // - pageWidth
        // - pageHeight
        // - fitWidth
        // - hCenter
        // - vCenter
        var ncols = Math.ceil(layout.width / options.pageWidth);
        var nrows = Math.ceil(layout.height / options.pageHeight);
        var pageWidth = Math.ceil(options.pageWidth / layout.scale);
        var pageHeight = Math.ceil(options.pageHeight / layout.scale);

        for (var j = 0; j < nrows; ++j) {
            for (var i = 0; i < ncols; ++i) {
                addPage(j, i);
            }
        }

        function addPage(row, col) {
            var left = col * pageWidth;
            var right = left + pageWidth;
            var top = row * pageHeight;
            var bottom = top + pageHeight;
            var endbottom = 0, endright = 0;

            function isInside(box) {
                if (box.right <= left || box.left >= right ||
                    box.bottom <= top || box.top >= bottom) {
                    return false;
                }
                endbottom = Math.max(box.bottom, endbottom);
                endright = Math.max(box.right, endright);
                return true;
            }

            // XXX: this can be optimized - discard cells that won't
            // be used again, and don't walk cells that stand no
            // chance to fit.
            var cells = layout.cells.filter(isInside);

            var drawings = layout.drawings.filter(function(d){
                return isInside(d.box);
            });

            // merged cells might stretch beyond page; limit to that
            endbottom = Math.min(endbottom, bottom);
            endright = Math.min(endright, right);

            if (cells.length || drawings.length) {
                var page = new kdrw.Group();
                group.append(page);
                // page.clip(drawing.Path.fromRect(
                //     new geo.Rect([ 0, 0 ],
                //                  [ options.pageWidth, options.pageHeight ])));

                var content = new kdrw.Group();
                page.append(content);

                content.clip(kdrw.Path.fromRect(
                    new geo.Rect([ left - 1, top - 1 ], [ endright + 1, endbottom + 1 ])
                ));

                var matrix = geo.Matrix.scale(layout.scale, layout.scale)
                    .multiplyCopy(geo.Matrix.translate(-left, -top));

                if (options.hCenter || options.vCenter) {
                    matrix = matrix.multiplyCopy(
                        geo.Matrix.translate(
                            options.hCenter ? (right - endright) / 2 : 0,
                            options.vCenter ? (bottom - endbottom) / 2 : 0)
                    );
                }

                content.transform(matrix);

                if (options.guidelines) {
                    var prev = null;
                    layout.xCoords.forEach(function(x){
                        x = Math.min(x, endright);
                        if (x !== prev && x >= left && x <= right) {
                            prev = x;
                            content.append(
                                new kdrw.Path()
                                    .moveTo(x, top)
                                    .lineTo(x, endbottom)
                                    .close()
                                    .stroke(options.guideColor, GUIDELINE_WIDTH)
                            );
                        }
                    });
                    var prev = null;
                    layout.yCoords.forEach(function(y){
                        y = Math.min(y, endbottom);
                        if (y !== prev && y >= top && y <= bottom) {
                            prev = y;
                            content.append(
                                new kdrw.Path()
                                    .moveTo(left, y)
                                    .lineTo(endright, y)
                                    .close()
                                    .stroke(options.guideColor, GUIDELINE_WIDTH)
                            );
                        }
                    });
                }

                var borders = Borders(); // jshint ignore: line
                cells.forEach(function(cell){
                    drawCell(cell, content, options);
                    borders.add(cell, sheet);
                });

                var bordersGroup = new kdrw.Group();
                borders.vert.forEach(function(a){
                    a.forEach(function(b){
                        if (!b.rendered) {
                            b.rendered = true;
                            bordersGroup.append(
                                new kdrw.Path()
                                    .moveTo(b.x, b.top)
                                    .lineTo(b.x, b.bottom)
                                    .close()
                                    .stroke(b.color, b.size)
                            );
                        }
                    });
                });
                borders.horiz.forEach(function(a){
                    a.forEach(function(b){
                        if (!b.rendered) {
                            b.rendered = true;
                            bordersGroup.append(
                                new kdrw.Path()
                                    .moveTo(b.left, b.y)
                                    .lineTo(b.right, b.y)
                                    .close()
                                    .stroke(b.color, b.size)
                            );
                        }
                    });
                });
                content.append(bordersGroup);

                drawings.forEach(function(d){
                    var drawing = d.drawing;
                    var image = drawing.image;
                    if (image != null) {
                        var box = d.box;
                        var url = sheet._workbook.imageUrl(image);
                        content.append(
                            new kdrw.Image(url, new geo.Rect(
                                [ box.left, box.top ],
                                [ box.width, box.height ]
                            )).opacity(drawing.opacity)
                        );
                    }
                });
            }
        }
    }

    function drawCell(cell, content, options) {
        var g = new kdrw.Group();
        content.append(g);
        var rect = new geo.Rect([ cell.left, cell.top ],
                                [ cell.width, cell.height ]);
        if (cell.background || cell.merged) {
            var r2d2 = rect;
            if (options.guidelines) {
                r2d2 = rect.clone();
                r2d2.origin.x += GUIDELINE_WIDTH/2 + 0.1;
                r2d2.origin.y += GUIDELINE_WIDTH/2 + 0.1;
                r2d2.size.width -= GUIDELINE_WIDTH + 0.2;
                r2d2.size.height -= GUIDELINE_WIDTH + 0.2;
            }
            g.append(
                new kdrw.Rect(r2d2)
                    .fill(cell.background || "#fff")
                    .stroke(null)
            );
        }
        var val = cell.value;
        if (val != null) {
            var type = typeof val == "number" ? "number" : null;
            var clip = new kdrw.Group();
            clip.clip(kdrw.Path.fromRect(rect));
            g.append(clip);
            var f, format = cell.format;
            if (!format && type == "number" && val != Math.floor(val)) {
                format = "0.##############";
            }
            if (format) {
                f = formatting.textAndColor(val, format);
                val = f.text;
                if (f.type) {
                    type = f.type;
                }
            } else {
                val += "";
            }
            if (!cell.textAlign) {
                switch (type) {
                  case "number":
                  case "date":
                  case "percent":
                  case "currency":
                    cell.textAlign = "right";
                    break;
                  case "boolean":
                    cell.textAlign = "center";
                    break;
                }
            }
            drawText(val, (f && f.color) || cell.color || "#000", cell, clip);
        }
    }

    function applyIndent(cell, style) {
        if (cell.indent) {
            // OOXML spec states the indent is "An integer value,
            // where an increment of 1 represents 3 spaces".  This, of
            // course, bears no resemblance to what Excel actually
            // does, so we need magic numbers here.
            var indent = 1.4 * cell.indent;
            switch (style.textAlign) {
              case null:
              case "left":
                style.paddingLeft = indent + "ch";
                break;
              case "right":
                style.paddingRight = indent + "ch";
                break;
              case "center":
                style.paddingLeft = indent/2 + "ch";
                style.paddingRight = indent/2 + "ch";
                break;
            }
        }
    }

    var CONT;
    function drawText(text, color, cell, group) {
        if (!CONT) {
            CONT = document.createElement("div");
            CONT.style.position = "fixed";
            CONT.style.left = "0px";
            CONT.style.top = "0px";
            CONT.style.visibility = "hidden";
            CONT.style.overflow = "hidden";
            CONT.style.boxSizing = "border-box";
            CONT.style.lineHeight = "normal";
            document.body.appendChild(CONT);
        }

        if (CONT.firstChild) {
            CONT.removeChild(CONT.firstChild);
        }

        CONT.style.padding = "2px 4px";
        CONT.style.color = color;
        CONT.style.font = makeFontDef(cell);
        CONT.style.width = cell.width + "px";
        CONT.style.textAlign = cell.textAlign || "left";
        CONT.style.textDecoration = cell.underline ? "underline" : "none";

        applyIndent(cell, CONT.style);

        if (cell.wrap) {
            CONT.style.whiteSpace = "pre-wrap";
            CONT.style.overflowWrap = CONT.style.wordWrap = "break-word";
        } else {
            CONT.style.whiteSpace = "pre";
            CONT.style.overflowWrap = CONT.style.wordWrap = "normal";
        }

        CONT.appendChild(document.createTextNode(text));

        var vtrans = 0;
        switch (cell.verticalAlign) {
          case "center":
            vtrans = (cell.height - CONT.offsetHeight) >> 1;
            break;

          case undefined:
          case null:
          case "bottom":
            vtrans = (cell.height - CONT.offsetHeight);
            break;
        }
        if (vtrans < 0) { vtrans = 0; }

        var text_group  = kendo.drawing.drawDOM.drawText(CONT);
        text_group.transform(geo.Matrix.translate(cell.left, cell.top + vtrans));
        group.append(text_group);
    }

    function makeFontDef(cell) {
        var font = [];
        if (cell.italic) {
            font.push("italic");
        }
        if (cell.bold) {
            font.push("bold");
        }
        font.push((cell.fontSize || 12) + "px");
        font.push((cell.fontFamily || "Arial"));
        return font.join(" ");
    }

    function draw(sheet, range, options, callback) {
        if (options == null && callback == null) {
            callback = range;
            options = {};
            range = spreadsheet.SHEETREF;
        }
        if (callback == null) {
            callback = options;
            if (range instanceof spreadsheet.Range
                || range instanceof spreadsheet.Ref
                || typeof range == "string") {
                options = {};
            } else {
                options = range;
                range = spreadsheet.SHEETREF;
            }
        }
        options = kendo.jQuery.extend({
            paperSize  : "A4",
            landscape  : true,
            margin     : "1cm",
            guidelines : true,
            guideColor : "#aaa",
            emptyCells : true,
            fitWidth   : false,
            center     : false,
            headerRows : null,
            maxEmpty   : 0.2,
            scale      : 1
        }, options);
        var group = new kdrw.Group();
        var paper = kendo.pdf.getPaperOptions(options);
        group.options.set("pdf", {
            author    : options.author,
            creator   : options.creator,
            date      : options.date,
            keywords  : options.keywords,
            margin    : paper.margin,
            multiPage : true,
            paperSize : paper.paperSize,
            subject   : options.subject,
            title     : options.title,
            autoPrint : options.autoPrint
        });
        var pageWidth = paper.paperSize[0];
        var pageHeight = paper.paperSize[1];
        if (paper.margin) {
            pageWidth -= paper.margin.left + paper.margin.right + 1;
            pageHeight -= paper.margin.top + paper.margin.bottom + 1;
        }
        options.pageWidth = pageWidth;
        options.pageHeight = pageHeight;
        var layout = doLayout(sheet, sheet._ref(range), options);
        drawLayout(sheet, layout, group, options);
        callback(group);
    }

    spreadsheet.Sheet.prototype.draw = function(range, options, callback) {
        var sheet = this;
        if (sheet._workbook) {
            sheet.recalc(sheet._workbook._context, function(){
                draw(sheet, range, options, callback);
            });
        } else {
            draw(sheet, range, options, callback);
        }
    };

    // Hack: since we index the border arrays by relative row/col we
    // could end up with negative indexes, i.e. horiz[-2] = border.
    // Array forEach will ignore these, so we provide a simple
    // container here (outside code only needs forEach at this time).
    function Container() {}
    Container.prototype = {
        forEach: function(f) {
            Object.keys(this).forEach(function(key){
                f(this[key], key, this);
            }, this);
        }
    };

    function Borders() {
        var horiz = new Container();
        var vert = new Container();
        function add(cell, sheet) {
            if (sheet) {
                // reset borders here; the propertybag doesn't keep track of merged cells :-/ this
                // is ugly, but the inner details of data storage have leaked everywhere anyway.
                var pb = sheet._properties;
                var grid = sheet._grid;
                cell.borderLeft    = pb.get("vBorders", grid.index(cell.row, cell.col));
                cell.borderRight   = pb.get("vBorders", grid.index(cell.row, cell.col + cell.colspan));
                cell.borderTop     = pb.get("hBorders", grid.index(cell.row, cell.col));
                cell.borderBottom  = pb.get("hBorders", grid.index(cell.row + cell.rowspan, cell.col));
            }
            if (cell.borderLeft) {
                addVert(cell.row, cell.col, cell.borderLeft,
                        cell.left, cell.top, cell.bottom);
            }
            if (cell.borderRight) {
                addVert(cell.row, cell.col + cell.colspan, cell.borderRight,
                        cell.right, cell.top, cell.bottom);
            }
            if (cell.borderTop) {
                addHoriz(cell.row, cell.col, cell.borderTop,
                         cell.top, cell.left, cell.right);
            }
            if (cell.borderBottom) {
                addHoriz(cell.row + cell.rowspan, cell.col, cell.borderBottom,
                         cell.bottom, cell.left, cell.right);
            }
        }
        function addVert(row, col, border, x, top, bottom) {
            var a = vert[col] || (vert[col] = new Container());
            var prev = row > 0 && a[row - 1];
            if (prev && sameBorder(prev, border)) {
                a[row] = prev;
                prev.bottom = bottom;
            } else {
                a[row] = {
                    size: border.size,
                    color: border.color,
                    x: x,
                    top: top,
                    bottom: bottom
                };
            }
        }
        function addHoriz(row, col, border, y, left, right) {
            var a = horiz[row] || (horiz[row] = new Container());
            var prev = col > 0 && a[col - 1];
            if (prev && sameBorder(prev, border)) {
                a[col] = prev;
                prev.right = right;
            } else {
                a[col] = {
                    size: border.size,
                    color: border.color,
                    y: y,
                    left: left,
                    right: right
                };
            }
        }
        return { add: add, horiz: horiz, vert: vert };
    }

    function drawTabularData(options) {
        var progress = new $.Deferred();
        var promise = progress.promise();

        options = clone(options, {
            dataSource       : null,
            guidelines       : true,
            guideColor       : "#000",
            columns          : null,
            headerBackground : "#999",
            headerColor      : "#000",
            oddBackground    : null,
            evenBackground   : null,
            fontFamily       : "Arial",
            fontSize         : 12,
            paperSize        : "A4",
            margin           : "1cm",
            landscape        : true,
            fitWidth         : false,
            scale            : 1,
            rowHeight        : 20,
            maxEmpty         : 1,
            useGridFormat    : true
        });

        // retrieve fonts; custom fonts should be already loaded
        kendo.drawing.pdf.defineFont(
            kendo.drawing.drawDOM.getFontFaces(document)
        );

        var charWidth = charWidthFunction(options.fontFamily, options.fontSize);

        function textWidth(value) {
            if (value != null) {
                var width = 12;         // magic numbers :-/
                for (var i = value.length; --i >= 0;) {
                    width += charWidth(value.charAt(i));
                }
                return width;
            }
            return 0;
        }

        var border = options.guidelines ? { size: 1, color: options.guideColor } : null;

        function mkCell(data) {
            if (!border) {
                return data;
            }
            return clone(data, {
                borderLeft: border,
                borderTop: border,
                borderRight: border,
                borderBottom: border
            });
        }

        options.dataSource.fetch(function(){
            var data = options.dataSource.data();
            if (!data.length) {
                return progress.reject("Empty dataset");
            }

            // this really must be present
            var columns = options.columns.map(function(col){
                if (typeof col == "string") {
                    return { title: col, field: col };
                } else {
                    return col;
                }
            });
            var columnTitles = columns.map(function(col){
                return col.title || col.field;
            });
            var columnWidths = columnTitles.map(textWidth);

            // prepare data for a Sheet object's fromJSON method
            var rows = data.map(function(row, rowIndex){
                return {
                    cells: columns.map(function(col, colIndex){
                        var value = row[col.field];

                        // NOTE: value might not be string.  I added option useGridFormat (default
                        // true), which will use a column's format, if present, to convert the value
                        // to a string, so that we can measure the width right now.
                        if (options.useGridFormat) {
                            if (value != null) {
                                if (col.format) {
                                    value = kendo.format(col.format, value);
                                } else {
                                    value += "";
                                }
                            }
                            // adjust the column widths while we're at it
                            columnWidths[colIndex] = Math.max(
                                textWidth(value),
                                columnWidths[colIndex]
                            );
                        }

                        // if options.useGridFormat is false and col.format is present, pass it over
                        // to the spreadsheet.  In that case we should calculate the widths after
                        // the spreadsheet is created (XXX to be implemented when someone needs it).
                        return mkCell({
                            value: value,
                            format: options.useGridFormat ? null : col.format,
                            background: rowIndex % 2 ? options.evenBackground : options.oddBackground
                        });
                    })
                };
            });

            // insert header line
            rows.unshift({
                cells: columnTitles.map(function(label){
                    return mkCell({
                        value: label,
                        background: options.headerBackground,
                        color: options.headerColor
                    });
                })
            });

            // init a Sheet object.  Note that we have to add one
            // extra-row and column, because the very last ones can't
            // have right/bottom borders (known limitation).
            var sheet = new kendo.spreadsheet.Sheet(
                rows.length + 1,        // rows
                columns.length + 1,     // columns
                options.rowHeight,      // row height
                50,                     // column width
                20,                     // header height
                20,                     // header width,
                {                       // default cell style
                    fontFamily: options.fontFamily,
                    fontSize: options.fontSize,
                    verticalAlign: "center"
                }
            );

            // load data
            sheet.fromJSON({
                name: "Sheet1",
                rows: rows,
                columns: columnWidths.map(function(w, i){
                    return { index: i, width: w };
                })
            });

            sheet.draw({
                paperSize  : options.paperSize,
                landscape  : options.landscape,
                margin     : options.margin,
                guidelines : false, // using borders instead (better contrast)
                scale      : options.scale,
                fitWidth   : options.fitWidth,
                maxEmpty   : options.maxEmpty,
                headerRows : 1
            }, progress.resolve.bind(progress));
        });

        return promise;
    }

    var CACHE_CHAR_WIDTH = {};

    var charWidthFunction = function(fontFamily, fontSize) {
        var id = fontSize + ":" + fontFamily;
        var func = CACHE_CHAR_WIDTH[id];
        if (!func) {
            var span, div = document.createElement("div");
            div.style.position = "fixed";
            div.style.left = "-10000px";
            div.style.top = "-10000px";
            div.style.fontFamily = fontFamily;
            div.style.fontSize = fontSize + "px";
            div.style.whiteSpace = "pre";
            for (var i = 32; i < 128; ++i) {
                span = document.createElement("span");
                span.appendChild(document.createTextNode(String.fromCharCode(i)));
                div.appendChild(span);
            }
            document.body.appendChild(div);
            var widths = {};
            for (i = 32, span = div.firstChild; i < 128 && span; ++i, span = span.nextSibling) {
                widths[i] = span.offsetWidth;
            }
            while ((span = div.firstChild)) {
                div.removeChild(span);
            }
            func = CACHE_CHAR_WIDTH[id] = function(ch) {
                var code = ch.charCodeAt(0);
                var width = widths[code];
                if (width == null) {
                    // probably not an ASCII character, let's cache its width as well
                    span = document.createElement("span");
                    span.appendChild(document.createTextNode(String.fromCharCode(code)));
                    div.appendChild(span);
                    width = widths[code] = span.offsetWidth;
                    div.removeChild(span);
                }
                return width;
            };
        }
        return func;
    };

    spreadsheet.draw = {
        Borders         : Borders,
        doLayout        : doLayout,
        applyIndent     : applyIndent
    };

    spreadsheet.drawTabularData = drawTabularData;

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

(function(f, define){
    define('kendo.spreadsheet',[
        "./util/undoredostack",
        "./util/text-metrics",
        "./util/parse-xml",
        "./kendo.excel",
        "./kendo.progressbar",
        "./kendo.pdf",
        "./spreadsheet/commands",
        "./spreadsheet/formulabar",
        "./spreadsheet/formulainput",
        "./spreadsheet/eventlistener",
        "./spreadsheet/rangelist",
        "./spreadsheet/propertybag",
        "./spreadsheet/references",
        "./spreadsheet/navigator",
        "./spreadsheet/axismanager",
        "./spreadsheet/clipboard",
        "./spreadsheet/range",
        "./spreadsheet/sheet",
        "./spreadsheet/sheetsbar",
        "./spreadsheet/excel-reader",
        "./spreadsheet/workbook",
        "./spreadsheet/formulacontext",
        "./spreadsheet/controller",
        "./spreadsheet/view",
        "./spreadsheet/customeditors",
        "./spreadsheet/grid",
        "./spreadsheet/axis",
        "./spreadsheet/filter",
        "./spreadsheet/sorter",
        "./spreadsheet/runtime",
        "./spreadsheet/calc",
        "./spreadsheet/numformat",
        "./spreadsheet/runtime.functions",
        "./spreadsheet/runtime.functions.2",
        "./spreadsheet/toolbar",
        "./spreadsheet/dialogs",
        "./spreadsheet/sheetbinder",
        "./spreadsheet/filtermenu",
        "./spreadsheet/editor",
        "./spreadsheet/autofill",
        "./spreadsheet/nameeditor",
        "./spreadsheet/print"
    ], f);
})(function(){
    var __meta__ = { // jshint ignore:line
        id: "spreadsheet",
        name: "Spreadsheet",
        category: "web",
        description: "Spreadsheet component",
        depends: [
            "core", "binder", "colorpicker", "combobox", "data", "dom", "dropdownlist",
            "menu", "ooxml", "popup", "sortable", "tabstrip", "toolbar", "treeview",
            "window", "validator", "excel", "pdf", "drawing" ]
    };

    (function(kendo, undefined) {
        if (kendo.support.browser.msie && kendo.support.browser.version < 9) {
            return;
        }

        var $ = kendo.jQuery;
        var keys = $.extend({F10: 121, F11: 122, B: 66, I: 73, U: 85, N: 78, H: 72, A: 65, PAGEDOWN: 34, PAGEUP: 33, DELETE: 46, R: 82}, kendo.keys);
        var Widget = kendo.ui.Widget;
        var Workbook = kendo.spreadsheet.Workbook;
        var Controller = kendo.spreadsheet.Controller;
        var View = kendo.spreadsheet.View;
        var NS = ".kendoSpreadsheet";

        var ALL_REASONS = {
            recalc: true,
            selection: true,
            activeCell: true,
            layout: true,
            sheetSelection: true,
            resize: true,
            editorChange: false,
            editorClose: false
        };

        var classNames = {
            wrapper: "k-widget k-spreadsheet"
        };

        var Spreadsheet = kendo.ui.Widget.extend({
            init: function(element, options) {
                Widget.fn.init.call(this, element, options);

                this.element.addClass(Spreadsheet.classNames.wrapper);
                this.element.attr("role", "application");

                this._view = new View(this.element, {
                    messages: this.options.messages.view,
                    toolbar: this.options.toolbar,
                    sheetsbar:this.options.sheetsbar
                });

                this._workbook = new Workbook(this.options, this._view);

                this._controller = new Controller(this._view, this._workbook);

                this._autoRefresh = true;

                this._bindWorkbookEvents();

                this._view.workbook(this._workbook);

                this._view.enableClipboard(false);
                this.refresh();
                this._view.enableClipboard(true);

                this._resizeHandler = function() { this.resize(); }.bind(this);
                $(window).on("resize" + NS, this._resizeHandler);

                this.element.on("keydown" + NS, this._keyDown.bind(this));
            },

            _keyDown: function(e) {
                var key = e.keyCode;
                var redoTool = $(".k-spreadsheet-quick-access-toolbar [title=Redo]");
                if (key === keys.F11 && e.shiftKey) {
                    this._view.sheetsbar._onAddSelect();
                    e.preventDefault();
                    return;
                } else if (e.altKey && key === keys.PAGEDOWN) {
                    this._view.sheetsbar.trigger("select", {
                                    name: this._view.sheetsbar._sheets[this._view.sheetsbar._selectedIndex + 1].name(),
                                    isAddButton: false
                    });
                } else if (e.altKey && key === keys.PAGEUP) {
                    this._view.sheetsbar.trigger("select", {
                                    name: this._view.sheetsbar._sheets[this._view.sheetsbar._selectedIndex - 1].name(),
                                    isAddButton: false
                    });
                } else if (e.altKey && key === keys.DELETE) {
                    var closeCallback = function(e) {
                        var dlg = e.sender;

                        if (dlg.isConfirmed()) {
                            this._view.sheetsbar.trigger("remove", { name: this.activeSheet()._name(), confirmation: true });
                        }
                    }.bind(this);

                    this._view.sheetsbar._openDialog("confirmation", {
                        close: closeCallback
                    });
                    e.preventDefault();
                    return;
                } else if (e.altKey && key === keys.R) {
                    this._view.sheetsbar._createEditor();
                    e.preventDefault();
                    return;
                } else if (key === keys.F10 && this._view.tabstrip || (key === keys.TAB && !e.shiftKey && $(document.activeElement).is(redoTool))) {
                    this._view.tabstrip.toolbars[this._view.tabstrip.element.find("li.k-state-active").text().toLowerCase()].element.find(":not(.k-overflow-anchor):kendoFocusable").first().trigger("focus");
                    this._view.tabstrip.toolbars[this._view.tabstrip.element.find("li.k-state-active").text().toLowerCase()].element.find(".k-toolbar-first-visible").addClass("k-focus");
                    e.preventDefault();
                    return;
                } else if (e.ctrlKey && key === keys.B) {
                    $("[data-tool=bold]")[0].click();
                } else if (e.ctrlKey && key === keys.I) {
                    $("[data-tool=italic]")[0].click();
                } else if (e.ctrlKey && key === keys.U) {
                    $("[data-tool=underline]")[0].click();
                } else if (e.altKey && key === keys.H) {
                    this._view.tabstrip.select(0);
                    e.preventDefault();
                    return;
                } else if (e.altKey && key === keys.N) {
                    this._view.tabstrip.select(1);
                    e.preventDefault();
                    return;
                } else if (e.altKey && key === keys.A) {
                    this._view.tabstrip.select(2);
                    e.preventDefault();
                    return;
                }
            },

            _resize: function() {
                this.refresh({ layout: true });
            },

            _workbookChanging: function(e) {
                if (this.trigger("changing", e)) {
                    e.preventDefault();
                }
            },

            _workbookChange: function(e) {
                if (this._autoRefresh) {
                    this.refresh(e);
                }

                if (e.recalc && e.ref) {
                    var range = e.range || new kendo.spreadsheet.Range(e.ref, this.activeSheet());
                    this.trigger("change", { range: range });
                }
            },

            _workbookCut: function(e) {
                this.trigger("cut", e);
            },

            _workbookCopy: function(e) {
                this.trigger("copy", e);
            },

            _workbookPaste: function(e) {
                this.trigger("paste", e);
            },

            activeSheet: function(sheet) {
                return this._workbook.activeSheet(sheet);
            },

            moveSheetToIndex: function (sheet, index) {
                return this._workbook.moveSheetToIndex(sheet, index);
            },

            insertSheet: function(options) {
                return this._workbook.insertSheet(options);
            },

            sheets: function() {
                return this._workbook.sheets();
            },

            removeSheet: function(sheet) {
                return this._workbook.removeSheet(sheet);
            },

            sheetByName: function(sheetName) {
                return this._workbook.sheetByName(sheetName);
            },

            sheetIndex: function(sheet) {
                return this._workbook.sheetIndex(sheet);
            },

            sheetByIndex: function(index) {
                return this._workbook.sheetByIndex(index);
            },

            renameSheet: function(sheet, newSheetName) {
                return this._workbook.renameSheet(sheet, newSheetName);
            },

            refresh: function(reason) {
                if (!reason) {
                    reason = ALL_REASONS;
                }

                if (!reason.editorClose) {
                    this._view.sheet(this._workbook.activeSheet());
                    this._controller.sheet(this._workbook.activeSheet());

                    this._workbook.refresh(reason);
                }

                if (!reason.editorChange) {
                    this._view.refresh(reason);
                    this._controller.refresh();

                    this._view.render(reason);
                    this.trigger("render");
                }

                return this;
            },

            openDialog: function(name, options) {
                return this._view.openDialog(name, options);
            },

            autoRefresh: function(value) {
                if (value !== undefined) {
                    this._autoRefresh = value;

                    if (value === true) {
                        this.refresh();
                    }

                    return this;
                }

                return this._autoRefresh;
            },

            toJSON: function() {
                return this._workbook.toJSON();
            },

            fromJSON: function(json) {
                if (json.sheets) {
                    this._workbook.destroy();

                    this._workbook = new Workbook($.extend({}, this.options, json));

                    this._bindWorkbookEvents();

                    this._view.workbook(this._workbook);
                    this._controller.workbook(this._workbook);

                    this.activeSheet(this.activeSheet());
                } else {
                    this.refresh();
                }
            },

            saveJSON: function() {
                return this._workbook.saveJSON();
            },

            fromFile: function(blob, name) {
                return this._workbook.fromFile(blob, name);
            },

            saveAsPDF: function(options) {
                this._workbook.saveAsPDF(
                    $.extend({}, this.options.pdf, options, { workbook: this._workbook })
                );
            },

            saveAsExcel: function(options) {
                this._workbook.saveAsExcel(options);
            },

            draw: function(options, callback) {
                this._workbook.draw(options, callback);
            },

            _workbookExcelExport: function(e) {
                if (this.trigger("excelExport", e)) {
                    e.preventDefault();
                }
            },

            _workbookExcelImport: function(e) {
                if (this.trigger("excelImport", e)) {
                    e.preventDefault();
                } else {
                    this._initProgress(e.promise);
                }
            },

            _initProgress: function(deferred) {
                var loading =
                    $("<div class='k-loading-mask' " +
                           "style='width: 100%; height: 100%; top: 0;'>" +
                        "<div class='k-loading-color'></div>" +
                    "</div>")
                    .appendTo(this.element);

                var pb = $("<div class='k-loading-progress'>")
                .appendTo(loading)
                .kendoProgressBar({
                    type: "chunk", chunkCount: 10,
                    min: 0, max: 1, value: 0
                }).data("kendoProgressBar");

                deferred.progress(function(e) {
                    pb.value(e.progress);
                })
                .always(function() {
                    kendo.destroy(loading);
                    loading.remove();
                });
            },

            _workbookPdfExport: function(e) {
                if (this.trigger("pdfExport", e)) {
                    e.preventDefault();
                }
            },

            _workbookInsertSheet: function(e) {
                if (this.trigger("insertSheet", e)) {
                    e.preventDefault();
                }
            },

            _workbookRemoveSheet: function(e) {
                if (this.trigger("removeSheet", e)) {
                    e.preventDefault();
                }
            },

            _workbookSelectSheet: function(e) {
                if (this.trigger("selectSheet", e)) {
                    e.preventDefault();
                }
            },

            _workbookRenameSheet: function(e) {
                if (this.trigger("renameSheet", e)) {
                    e.preventDefault();
                }
            },

            _workbookInsertRow: function(e) {
                if (this.trigger("insertRow", e)) {
                    e.preventDefault();
                }
            },

            _workbookInsertColumn: function(e) {
                if (this.trigger("insertColumn", e)) {
                    e.preventDefault();
                }
            },

            _workbookDeleteRow: function(e) {
                if (this.trigger("deleteRow", e)) {
                    e.preventDefault();
                }
            },

            _workbookDeleteColumn: function(e) {
                if (this.trigger("deleteColumn", e)) {
                    e.preventDefault();
                }
            },

            _workbookHideRow: function(e) {
                if (this.trigger("hideRow", e)) {
                    e.preventDefault();
                }
            },

            _workbookHideColumn: function(e) {
                if (this.trigger("hideColumn", e)) {
                    e.preventDefault();
                }
            },

            _workbookUnhideRow: function(e) {
                if (this.trigger("unhideRow", e)) {
                    e.preventDefault();
                }
            },

            _workbookUnhideColumn: function(e) {
                if (this.trigger("unhideColumn", e)) {
                    e.preventDefault();
                }
            },

            _workbookSelect: function(e) {
                this.trigger("select", e);
            },

            _workbookChangeFormat: function(e) {
               this.trigger("changeFormat", e);
            },

            _workbookDataBinding: function(e) {
                if (this.trigger("dataBinding", e)) {
                    e.preventDefault();
                }
            },

            _workbookDataBound: function(e) {
                this.trigger("dataBound", e);
            },

            _workbookProgress: function(e) {
                kendo.ui.progress(this.element, e.toggle);
            },

            _bindWorkbookEvents: function() {
                this._workbook.bind("cut", this._workbookCut.bind(this));
                this._workbook.bind("copy", this._workbookCopy.bind(this));
                this._workbook.bind("paste", this._workbookPaste.bind(this));
                this._workbook.bind("changing", this._workbookChanging.bind(this));
                this._workbook.bind("change", this._workbookChange.bind(this));
                this._workbook.bind("excelExport", this._workbookExcelExport.bind(this));
                this._workbook.bind("excelImport", this._workbookExcelImport.bind(this));
                this._workbook.bind("pdfExport", this._workbookPdfExport.bind(this));
                this._workbook.bind("insertSheet", this._workbookInsertSheet.bind(this));
                this._workbook.bind("removeSheet", this._workbookRemoveSheet.bind(this));
                this._workbook.bind("selectSheet", this._workbookSelectSheet.bind(this));
                this._workbook.bind("renameSheet", this._workbookRenameSheet.bind(this));
                this._workbook.bind("insertRow", this._workbookInsertRow.bind(this));
                this._workbook.bind("insertColumn", this._workbookInsertColumn.bind(this));
                this._workbook.bind("deleteRow", this._workbookDeleteRow.bind(this));
                this._workbook.bind("deleteColumn", this._workbookDeleteColumn.bind(this));
                this._workbook.bind("hideRow", this._workbookHideRow.bind(this));
                this._workbook.bind("hideColumn", this._workbookHideColumn.bind(this));
                this._workbook.bind("unhideRow", this._workbookUnhideRow.bind(this));
                this._workbook.bind("unhideColumn", this._workbookUnhideColumn.bind(this));
                this._workbook.bind("select", this._workbookSelect.bind(this));
                this._workbook.bind("changeFormat", this._workbookChangeFormat.bind(this));
                this._workbook.bind("dataBinding", this._workbookDataBinding.bind(this));
                this._workbook.bind("dataBound", this._workbookDataBound.bind(this));
                this._workbook.bind("progress", this._workbookProgress.bind(this));
            },

            destroy: function() {
                kendo.ui.Widget.fn.destroy.call(this);

                this._workbook.destroy();
                this._controller.destroy();
                this._view.destroy();

                if (this._resizeHandler) {
                    $(window).off("resize" + NS, this._resizeHandler);
                }
            },

            options: {
                name: "Spreadsheet",
                toolbar: true,
                sheetsbar: true,
                rows: 200,
                columns: 50,
                rowHeight: 20,
                columnWidth: 64,
                headerHeight: 20,
                headerWidth: 32,
                excel: {
                    proxyURL: "",
                    fileName: "Workbook.xlsx"
                },
                messages: {},
                pdf: {
                    // which part of the workbook to be exported
                    area      : "workbook",
                    fileName  : "Workbook.pdf",
                    proxyURL  : "",
                    // paperSize can be an usual name, i.e. "A4", or an array of two Number-s specifying the
                    // width/height in points (1pt = 1/72in), or strings including unit, i.e. "10mm".  Supported
                    // units are "mm", "cm", "in" and "pt".  The default "auto" means paper size is determined
                    // by content.
                    paperSize : "a4",
                    // True to reverse the paper dimensions if needed such that width is the larger edge.
                    landscape : true,
                    // An object containing { left, top, bottom, right } margins with units.
                    margin    : null,
                    // Optional information for the PDF Info dictionary; all strings except for the date.
                    title     : null,
                    author    : null,
                    subject   : null,
                    keywords  : null,
                    creator   : "Kendo UI PDF Generator v." + kendo.version,
                    // Creation Date; defaults to new Date()
                    date      : null
                },
                defaultCellStyle: {
                    fontFamily: "Arial",
                    fontSize: 12
                },
                useCultureDecimals: false
            },

            defineName: function(name, value, hidden) {
                return this._workbook.defineName(name, value, hidden);
            },

            undefineName: function(name) {
                return this._workbook.undefineName(name);
            },

            nameValue: function(name) {
                return this._workbook.nameValue(name);
            },

            forEachName: function(func) {
                return this._workbook.forEachName(func);
            },

            cellContextMenu: function() {
                return this._view.cellContextMenu;
            },

            rowHeaderContextMenu: function() {
                return this._view.rowHeaderContextMenu;
            },

            colHeaderContextMenu: function() {
                return this._view.colHeaderContextMenu;
            },

            addImage: function(image) {
                return this._workbook.addImage(image);
            },

            cleanupImages: function() {
                return this._workbook.cleanupImages();
            },

            events: [
                "cut",
                "copy",
                "paste",
                "pdfExport",
                "excelExport",
                "excelImport",
                "changing",
                "change",
                "render",
                "removeSheet",
                "selectSheet",
                "renameSheet",
                "insertRow",
                "insertColumn",
                "deleteRow",
                "insertSheet",
                "deleteColumn",
                "hideRow",
                "hideColumn",
                "unhideRow",
                "unhideColumn",
                "select",
                "changeFormat",
                "dataBinding",
                "dataBound"
            ]
        });

        kendo.spreadsheet.ALL_REASONS = ALL_REASONS;
        kendo.ui.plugin(Spreadsheet);
        $.extend(true, Spreadsheet, { classNames: classNames });
    })(window.kendo);

    return window.kendo;

}, typeof define == 'function' && define.amd ? define : function(a1, a2, a3){ (a3 || a2)(); });

